[{"title":"Java ArrayList","date":"2019-03-02T07:41:06.000Z","path":"2019/03/02/Java-ArrayList/","text":"Java 8 官方文档链接 12345678java.lang.Object java.util.AbstractCollection&lt;E&gt; java.util.AbstractList&lt;E&gt; java.util.ArrayList&lt;E&gt;All Implemented Interfaces: Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, RandomAccessDirect Known Subclasses: AttributeList, RoleList, RoleUnresolvedList [TOC] ArrayList 简介 ArrayList 是基于数组实现的，是一个动态数组，其容量能自动增长。 ArrayList 不是线程安全的。多线程环境下请考虑用一下两种方案： Collections.synchronizedList(List list) 函数返回一个线程安全的ArrayList类 concurrent并发包下的 CopyOnWriteArrayList 类 Vector 类 不建议使用。 ArrayList 实现了 Serializable 接口，因此支持序列化，能够通过序列化传输。 ArrayList 实现了 Cloneable 接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现了 RandmoAccess接口，即提供了随机访问功能。 RandmoAccess是java中用来被List实现，为List提供快速访问功能的。 在ArrayList中，我们即可以通过元素的序号快速获取元素对象. ArrayList 源码剖析源码分析基于 JDK 1.8.0_201 版本。 https://paste.ubuntu.com/p/DNqhNPpvr4/ 字段总结从类 java.util.AbstractList 继承而来的字段 modCount 构造器12345678910111213141516171819java.util.ArrayList&lt;E&gt;ArrayList()构造一个初始容量为10的空列表。ArrayList(Collection&lt;? extends E&gt; c)按照集合的迭代器返回的顺序构造一个包含指定集合元素的列表。参数：c - 要将其元素放入此列表的集合抛出：NullPointerException - 如果指定的集合为nullArrayList(int initialCapacity)构造具有指定初始容量的空列表。参数：initialCapacity - 列表的初始容量抛出：IllegalArgumentException - 如果指定的初始容量为负数 方法摘要 修饰符和类型 方法和描述 boolean add(E e)将指定的元素追加到此列表的末尾。 void add(int index, E element)将指定元素插入此列表中的指定位置。 boolean addAll(Collection&lt;? extends E&gt; c)将指定集合中的所有元素按指定集合的迭代器返回的顺序附加到此列表的末尾。 boolean addAll(int index, Collection&lt;? extends E&gt; c)从指定位置开始，将指定集合中的所有元素插入此列表。 void clear()从此列表中删除所有元素。 Object clone()返回此ArrayList实例的浅表副本。 boolean contains(Object o)如果此列表包含指定的元素，则返回true。 void ensureCapacity(int minCapacity)如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 void forEach(Consumer&lt;? super E&gt; action)对每个元素执行给定操作，Iterable 直到处理完所有元素或操作引发异常。 E get(int index)返回此列表中指定位置的元素。 int indexOf(Object o)返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1。 boolean isEmpty()如果此列表不包含任何元素，则返回true。 Iterator&lt;E&gt; iterator()以适当的顺序返回此列表中元素的迭代器。 int lastIndexOf(Object o)返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。 ListIterator&lt;E&gt; listIterator()返回此列表中元素的列表迭代器（按适当顺序）。 ListIterator&lt;E&gt; listIterator(int index)从列表中的指定位置开始，返回列表中元素的列表迭代器（按正确顺序）。 E remove(int index)删除此列表中指定位置的元素。 boolean remove(Object o)从此列表中删除指定元素的第一个匹配项（如果存在）。 boolean removeAll(Collection&lt;?&gt; c)从此列表中删除指定集合中包含的所有元素。 boolean removeIf(Predicate&lt;? super E&gt; filter)删除此集合中满足给定谓词的所有元素。 protected void removeRange(int fromIndex, int toIndex)从此列表中删除索引介于其中fromIndex，包括和toIndex不包含的所有元素 。 void replaceAll(UnaryOperator&lt;E&gt; operator)将该列表的每个元素替换为将运算符应用于该元素的结果。 boolean retainAll(Collection&lt;?&gt; c)仅保留此列表中包含在指定集合中的元素。 E set(int index, E element)用指定的元素替换此列表中指定位置的元素。 int size()返回此列表中的元素数。 void sort(Comparator&lt;? super E&gt; c)根据指定的顺序对此列表进行排序 Comparator。 Spliterator&lt;E&gt; spliterator()在此列表中的元素上创建后期绑定 和失败快速 Spliterator。 List&lt;E&gt; subList(int fromIndex, int toIndex)返回指定的fromIndex，包含的和toIndex独占的列表部分的视图 。 Object[] toArray()以适当的顺序（从第一个元素到最后一个元素）返回包含此列表中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a)以适当的顺序返回包含此列表中所有元素的数组（从第一个元素到最后一个元素）; 返回数组的运行时类型是指定数组的运行时类型。 void trimToSize()将此ArrayList实例的容量调整为列表的当前大小。 常用API小结ArrayList遍历方式 通过迭代器遍历。即通过Iterator去遍历。 12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 随机访问，通过索引值去遍历由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; for循环遍历1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; ArrayList 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class ArrayListTest &#123; public static void main(String[] args) &#123; // 创建ArrayList ArrayList list = new ArrayList(); // 将“” list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); // 将下面的元素添加到第1个位置 list.add(0, \"5\"); // 获取第1个元素 System.out.println(\"the first element is: \"+ list.get(0)); // 删除“3” list.remove(\"3\"); // 获取ArrayList的大小 System.out.println(\"Arraylist size=: \"+ list.size()); // 判断list中是否包含\"3\" System.out.println(\"ArrayList contains 3 is: \"+ list.contains(3)); // 设置第2个元素为10 list.set(1, \"10\"); // 通过Iterator遍历ArrayList for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; System.out.println(\"next is: \"+ iter.next()); &#125; // 将ArrayList转换为数组 String[] arr = (String[])list.toArray(new String[0]); for (String str:arr) System.out.println(\"str: \"+ str); // 清空ArrayList list.clear(); // 判断ArrayList是否为空 System.out.println(\"ArrayList is empty: \"+ list.isEmpty()); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java List 集合概述","date":"2019-03-01T07:39:52.000Z","path":"2019/03/01/Java-List-集合概述/","text":"List 集合包括 List 接口以及 List 接口的所有实现类。List 集合中的元素允许重复，各元素的顺序就是对象插入的顺序。类似 Java 数组，用户可通过使用索引（元素在集合中的位置）来访问集合中的元素。 List 接口List 接口继承了 Collection 接口，因此包含了 Collection 中的所有方法。此外，List 接口还定义了两个非常重要的方法。 12get(int index):获得指定索引位置的元素set(int index, Object obj):将集合中指定索引位置的对象修改为指定的对象 List 接口的实现类List 接口的常用实现类有 ArrayList 与 LinkedList。 ArrayListArrayList 类实现了可变的数组，允许保存所有元素，包括 null，并可以根据索引位置对集合进行快速的随机访问；缺点是向指定的索引位置插入对象或删除对象的速度较慢。 LinkedListLinkedList 类采用链表结构保存对象。这种结构的优点是便于向集合中插入和删除对象，需要向集合中插入、删除对象时，使用 LinkedList 类实现的 List 集合较高；但对于随机访问集合中的对象，使用 LinkedList 类实现 List 集合的效率较低。 与数组相同，集合的索引也是从 0 开始的","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java Collection 接口概述","date":"2019-02-28T04:34:09.000Z","path":"2019/02/28/Java-Collection-接口概述/","text":"Collection 接口是层次结构中的根接口。构成 Collection 的单位称为元素。 Collection 接口通常不能直接使用，但该接口提供了添加元素、删除元素、管理数据的方法。由于 List 接口与 Set 接口都继承了 Collection 接口，因此这个方法对 List 集合和 Set 集合都是通用的。 Collection 接口常用方法12345add(E e) 将指定的对象添加到该集合中remove(Object o) 将指定的对象从该集合中移除isEmpty() 返回 boolean 值，用于判断当前集合是否为空iterator() 返回在此 Collection 的元素上进行迭代的迭代器，用于遍历集合中的对象size() //返回 int 型值，获取该集合中的元素个数 123456789101112131415import java.util.*;public class Muster &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()) &#123; String str = (String)it.next(); System.out.println(str); &#125; &#125;&#125; Iterator 的 next() 方法返回的是 Object","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 集合类概述","date":"2019-02-27T08:55:41.000Z","path":"2019/02/27/Java-集合类概述/","text":"java.util 包中提供了一些集合类，这些集合类又被称为容器。提到容器不难想到数组，集合类与数组的不同之处是，数组的长度是固定的，集合的长度是可变的； 数组用来存放基本类型的数据，集合用来存放对象的引用。常用的集合有 List 集合、Set 集合和 Map 集合，其中 List 与 Set 继承了 Collection 接口，各接口还提供了不同的实现类。 Java 集合的体系结构Java 集合中有两个重要的根接口：Collection接口和Map接口。 Collection 接口Collection 接口下有三个子接口：set、List、Queue接口。 Set接口：代表的是一个无序不可重复的集合，常用的实现类有:HashSet、TreeSet. List接口：代表的是有序可重复的集合，常用的实现类有：ArrayList、Vector. Queue接口：是 Java 提供的队列实现，是一种先进先出的数据结构。 Map 接口Map 实现类主要用于保存具有映射关系（key-value）的数据。常用的实现类有：HashTable、HashMap等。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 常见异常","date":"2019-02-26T05:56:32.000Z","path":"2019/02/26/Java-常见异常/","text":"在 Java 中提供了一些异常用来描述经常发生的错误，其中，有点需要程序员进行捕获处理或声明抛出，有的是由 java 虚拟机自动进行捕获处理的。 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常类 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 newInstance() 方法常见一个类的实例，而指定的类对象无法被实例化时，抛出异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 运行时异常","date":"2019-02-25T05:42:35.000Z","path":"2019/02/25/Java-运行时异常/","text":"RunTimeException 异常是程序运行过程中产生的异常。Java类库的每个包中都定义了异常类，所有这些类都是 Throwable 类的子类。 Throwable 类派生了两个子类，分别是 Exception 和 Error 类。Error 类及其子类用来描述 Java 运行系统中的内部错误以及资源耗尽的错误，这类错误比较严重。Exception 类称为非致命性类，可以通过捕获处理使程序继续执行。Exception 类又根据错误发生的原因分为 RuntimeException 异常和除 RuntimeException 之外的异常。 常见的 RuntimeException 异常 种类 说明 NullPointerException 空指针异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArithmeticException 算术异常 ArrayStoreException 数组中包含不兼容的值抛出异常 IilegalArgumentException 非法参数异常 SecurityException 安全性异常 NegativeArraySizeException 数组长度为负异常","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 枚举类型","date":"2019-02-22T02:56:20.000Z","path":"2019/02/22/Java-枚举类型/","text":"使用枚举类型可以取代以往定义常量的方式，同时枚举类型还赋予程序在编译时进行检查的功能。 使用枚举类型设置常量以往设置常量，通常将常量放置在接口中，这样在程序中就可以直接使用，并且该常量不能被修改，因为在接口中定义常量时，该常量的修饰符为 final 与 static。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 使用 Annotation 功能","date":"2019-02-21T01:33:00.000Z","path":"2019/02/21/Java-使用-Annotation-功能/","text":"Java 中提供了 Annotation 功能，该功能可用于类、构造方法、成员变量、方法、参数等的声明中。该功能并不影响程序的运行，但是会对编译器警告灯辅助工具产生影响。 定义 Annotation 类型在定义 Annotation 类型时，也需要用到用来定义接口的 interface 关键字，但需要在 interface 关键字前加一个 @符号，即定义 Annotation 类型的关键字为 @interface，这个关键字的隐含意思是继承了 ava.lang.annotation.Annotation接口.123public @interface NoMemberAnnotation &#123;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java Class 类与 Java 反射","date":"2019-02-20T06:25:29.000Z","path":"2019/02/20/Java-Class-类与-Java-反射/","text":"通过 java 反射机制，可以在程序中访问已经装载到 JVM 中的 Java 对象的描述，实现访问、检测和修改描述 Java 对象本身信息的功能。 java 反射机制的功能十分强大，在 java.lang.reflect 包中提供了对该功能的支持。 从所周知，所有 Java 类均继承了 Object 类，在 Object 类中定义了一个 getClass() 方法，该方法返回一个类型为 Class 的对象。1Class textFieldC = textField.getClass(); 利用 Class 类的对象 textFieldC，可以访问用来返回该对象的 textField 对象的描述信息。 描述信息如下表所示： 组成部分 访问方法 返回值类型 说明 包路径 getPackage() Package 对象 获得该类的存放路径 类名称 getName() String 对象 获得该类的名称 继承类 getSuperClass() Class 对象 获得该类继承的类 实现接口 getInterfaces() Class 型数组 获得该类实现的所有接口 构造方法 getConstructors() Constructor 型数组 获得所有权限为 public 的构造方法 构造方法 getConstructor(Class&lt;?&gt;…parameterTypes) Constructor 对象 获得权限为 public 的指定构造方法 构造方法 getDeclaredConstructors() Constructors 型数组 获得所有构造方法，按声明顺序返回 构造方法 getDeclaredConstructor(Class&lt;?&gt;…parameterTypes) Constructor 对象 获得指定构造方法 方法 getMethods() Method 型数组 获得所有权限为 public 的方法 方法 getMethod(String name, Class&lt;?&gt;…parameterTypes) Method 对象 获得权限为 public 的指定方法 方法 getDeclaredMethods() Method 数组 获得所有方法，按声明顺序返回 方法 getDeclaredMethod(String name, Class&lt;?&gt;…parameterTypes) Method 对象 获得指定方法 成员变量 getFields() Field 型数组 获得所有权限为 public 的成员变量 成员变量 getField(String name) Field 对象 获得权限为 public 的指定成员变量 成员变量 getDeclaredFields() Field 型数组 获得所有成员变量，按声明顺序返回 成员变量 getDeclaredField(String name) Field 对象 获得指定成员变量 内部类 getClasses() Class 型数组 获得所有权限为public的内部类 内部类 getDeclaredClasses() Class 型数组 获得所有内部类 内部类的声明类 getDeclaringClass() Class 对象 如果该类为内部类，则返回它的成员类，否则返回 null","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 日期与时间","date":"2019-02-19T05:11:34.000Z","path":"2019/02/19/Java-日期与时间/","text":"java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 12345第一个构造函数使用当前日期和时间来初始化对象。Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。Date(long millisec) 常用方法12345678910111213141516171819202122232425262728293031boolean after(Date date)若当调用此方法的Date对象在指定日期之后返回true,否则返回false。boolean before(Date date)若当调用此方法的Date对象在指定日期之前返回true,否则返回false。Object clone( )返回此对象的副本。int compareTo(Date date)比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。int compareTo(Object obj)若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。boolean equals(Object date)当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。long getTime( )返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。int hashCode( )返回此对象的哈希码值。void setTime(long time)用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。String toString( )把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 获取当前日期时间Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示： 1234567891011121314import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125;编译结果如下：Mon May 04 09:51:52 CDT 2013 日期比较Java使用以下三种方法来比较两个日期： 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 使用 SimpleDateFormat 格式化日期SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如： 12345678910111213141516import java.util.*;import java.text.*;public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\"); System.out.println(\"Current Date: \" + ft.format(dNow)); &#125;&#125;结果：Current Date: Wed 2016.11.09 at 08:23:19 AM UTC 日期和时间的格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 ` 使用printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 12345678910111213141516171819202122232425262728293031import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\",date); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\",date); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\",date); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\",date); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\",date); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\",date); &#125;&#125;结果：全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012 年-月-日格式：2012-09-10 月/日/年格式：09/10/12 HH:MM:SS PM格式（12时制）：10:43:36 上午 HH:MM:SS格式（24时制）：10:43:36 HH:MM格式（24时制）：10:43 解析字符串为时间SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如： 1234567891011121314151617181920212223242526272829import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); String input = args.length == 0 ? \"1818-11-11\" : args[0]; System.out.print(input + \" Parses as \"); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println(\"Unparseable using \" + ft); &#125; &#125;&#125;result:$ java DateDemo1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818$ java DateDemo 2007-12-012007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007 测量时间下面的一个例子表明如何测量时间间隔（以毫秒为单位）： 1234567891011121314151617181920212223242526import java.util.*; public class DiffDemo &#123; public static void main(String args[]) &#123; try &#123; long start = System.currentTimeMillis( ); System.out.println(new Date( ) + \"\\n\"); Thread.sleep(5*60*10); System.out.println(new Date( ) + \"\\n\"); long end = System.currentTimeMillis( ); long diff = end - start; System.out.println(\"Difference is : \" + diff); &#125; catch (Exception e) &#123; System.out.println(\"Got an exception!\"); &#125; &#125;&#125;result:Fri Jan 08 09:48:47 CST 2016Fri Jan 08 09:48:50 CST 2016Difference is : 3019 利用 Calendar 类在日期做加减我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。 Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 创建一个代表系统当前日期的Calendar对象1Calendar c = Calendar.getInstance();//默认是当前日期 创建一个指定日期的Calendar对象使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。 123//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 - 1, 12); Calendar类对象字段类型Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 常量 描述 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同 Calendar.HOUR 12小时制的小时 Calendar.HOUR_OF_DAY 24小时制的小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 Calendar类对象信息的设置Set设置 如： 1Calendar c1 = Calendar.getInstance(); 调用： 12public final void set(int year,int month,int date)c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12 利用字段类型设置 如果只设定某个字段，例如日期的值，则可以使用如下set方法： 1public void set(int field,int value) 把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算 1c1.set(Calendar.DATE,10); 把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算 1c1.set(Calendar.YEAR,2008); 其他字段属性set的意义以此类推 Add设置 1Calendar c1 = Calendar.getInstance(); 把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, 10); 把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, -10); 其他字段属性的add的意义以此类推 Calendar类对象信息的获得123456789101112131415Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK); GregorianCalendar类Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。 Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 1234567891011121314151617181920GregorianCalendar() 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。GregorianCalendar(int year, int month, int date) 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendarGregorianCalendar(int year, int month, int date, int hour, int minute) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。GregorianCalendar(int year, int month, int date, int hour, int minute, int second) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。GregorianCalendar(Locale aLocale) 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendarGregorianCalendar(TimeZone zone) 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。GregorianCalendar(TimeZone zone, Locale aLocale) 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 这里是GregorianCalendar 类提供的一些有用的方法列表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void add(int field, int amount) 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。protected void computeFields() 转换UTC毫秒值为时间域值protected void computeTime() 覆盖Calendar ，转换时间域值为UTC毫秒值boolean equals(Object obj) 比较此 GregorianCalendar 与指定的 Object。int get(int field) 获取指定字段的时间值int getActualMaximum(int field) 返回当前日期，给定字段的最大值int getActualMinimum(int field) 返回当前日期，给定字段的最小值int getGreatestMinimum(int field) 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。 Date getGregorianChange() 获得格里高利历的更改日期。int getLeastMaximum(int field) 返回此 GregorianCalendar 实例给定日历字段的最低的最大值int getMaximum(int field) 返回此 GregorianCalendar 实例的给定日历字段的最大值。Date getTime()获取日历当前时间。long getTimeInMillis() 获取用长整型表示的日历的当前时间TimeZone getTimeZone() 获取时区。int getMinimum(int field) 返回给定字段的最小值。int hashCode() 重写hashCode. boolean isLeapYear(int year)确定给定的年份是否为闰年。void roll(int field, boolean up) 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。void set(int field, int value) 用给定的值设置时间字段。void set(int year, int month, int date) 设置年、月、日的值。void set(int year, int month, int date, int hour, int minute) 设置年、月、日、小时、分钟的值。void set(int year, int month, int date, int hour, int minute, int second) 设置年、月、日、小时、分钟、秒的值。void setGregorianChange(Date date) 设置 GregorianCalendar 的更改日期。void setTime(Date date) 用给定的日期设置Calendar的当前时间。void setTimeInMillis(long millis) 用给定的long型毫秒数设置Calendar的当前时间。void setTimeZone(TimeZone value) 用给定时区值设置当前时区。String toString() 返回代表日历的字符串。 实例12345678910111213141516171819202122232425262728293031323334import java.util.*; public class GregorianCalendarDemo &#123; public static void main(String args[]) &#123; String months[] = &#123; \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"&#125;; int year; // 初始化 Gregorian 日历 // 使用当前时间和日期 // 默认为本地时间和时区 GregorianCalendar gcalendar = new GregorianCalendar(); // 显示当前时间和日期的信息 System.out.print(\"Date: \"); System.out.print(months[gcalendar.get(Calendar.MONTH)]); System.out.print(\" \" + gcalendar.get(Calendar.DATE) + \" \"); System.out.println(year = gcalendar.get(Calendar.YEAR)); System.out.print(\"Time: \"); System.out.print(gcalendar.get(Calendar.HOUR) + \":\"); System.out.print(gcalendar.get(Calendar.MINUTE) + \":\"); System.out.println(gcalendar.get(Calendar.SECOND)); // 测试当前年份是否为闰年 if(gcalendar.isLeapYear(year)) &#123; System.out.println(\"当前年份是闰年\"); &#125; else &#123; System.out.println(\"当前年份不是闰年\"); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 数组排序","date":"2019-02-18T03:03:13.000Z","path":"2019/02/18/Java-数组排序/","text":"对数组进行排序的算法大致有冒泡、选择、插入和希尔排序。在这篇文章中我们将依次介绍这些算法的原理以及实现。 冒泡排序123456789101112131415161718192021package org.idcn.jse; public class SortAll &#123; public static void main(String[] args) &#123; int[] i = &#123; 1, 5, 6, 12, 4, 9, 3, 23, 39, 403, 596, 87 &#125;; System.out.println(\"----冒泡排序的结果：\"); maoPao(i); &#125; // 冒泡排序 public static void maoPao(int[] x) &#123; for (int i = 0; i &lt; x.length; i++) &#123; for (int j = i + 1; j &lt; x.length; j++) &#123; if (x[i] &gt; x[j]) &#123; int temp = x[i]; x[i] = x[j]; x[j] = temp; &#125; &#125; &#125; 选择排序12345678910111213141516171819202122232425262728293031package org.idcn.jse; public class SortAll &#123; public static void main(String[] args) &#123; int[] i = &#123; 1, 5, 6, 12, 4, 9, 3, 23, 39, 403, 596, 87 &#125;; System.out.println(\"----选择排序的结果：\"); xuanZe(i); &#125; // 选择排序 public static void xuanZe(int[] x) &#123; for (int i = 0; i &lt; x.length; i++) &#123; int lowerIndex = i; // 找出最小的一个索引 for (int j = i + 1; j &lt; x.length; j++) &#123; if (x[j] &lt; x[lowerIndex]) &#123; lowerIndex = j; &#125; &#125; // 交换 int temp = x[i]; x[i] = x[lowerIndex]; x[lowerIndex] = temp; &#125; for (int i : x) &#123; System.out.print(i + \" \"); &#125; &#125; 插入排序12345678910111213141516171819202122232425262728package org.idcn.jse; public class SortAll &#123; public static void main(String[] args) &#123; int[] i = &#123; 1, 5, 6, 12, 4, 9, 3, 23, 39, 403, 596, 87 &#125;; System.out.println(\"----插入排序的结果：\"); chaRu(i); &#125; // 插入排序 public static void chaRu(int[] x) &#123; for (int i = 1; i &lt; x.length; i++) &#123;// i从一开始，因为第一个数已经是排好序的啦 for (int j = i; j &gt; 0; j--) &#123; if (x[j] &lt; x[j - 1]) &#123; int temp = x[j]; x[j] = x[j - 1]; x[j - 1] = temp; &#125; &#125; &#125; for (int i : x) &#123; System.out.print(i + \" \"); &#125; &#125; 希尔排序12345678910111213141516171819202122232425262728293031323334package org.idcn.jse; public class SortAll &#123; public static void main(String[] args) &#123; int[] i = &#123; 1, 5, 6, 12, 4, 9, 3, 23, 39, 403, 596, 87 &#125;; System.out.println(\"----希尔（Shell）排序的结果：\"); shell(i); &#125; // 希尔排序 public static void shell(int[] x) &#123; // 分组 for (int increment = x.length / 2; increment &gt; 0; increment /= 2) &#123; // 每个组内排序 for (int i = increment; i &lt; x.length; i++) &#123; int temp = x[i]; int j = 0; for (j = i; j &gt;= increment; j -= increment) &#123; if (temp &lt; x[j - increment]) &#123; x[j] = x[j - increment]; &#125; else &#123; break; &#125; &#125; x[j] = temp; &#125; &#125; for (int i : x) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 处理程序异常错误","date":"2019-02-15T03:01:46.000Z","path":"2019/02/15/Java-处理程序异常错误/","text":"为了保证程序有效地执行，需要对发生的异常进行相应的处理。在 Java 中，如果某个方法抛出异常，即可以在当前方法中进行捕获，然后处理该异常，也可以将异常向上抛出，由方法调用者来处理。 错误异常产生后，如果不做任何处理，程序就会被终止。 123456789public class Thundering &#123; public static void main(String[] agrs) &#123; String str = \"lili\"; System.out.println(str + \"年龄是：\"); int age = Integer.parseInt(\"20L\"); System.out.println(age); &#125;&#125; 捕获异常Java 语言的异常捕获结构由 try、catch 以及 finally 3个部分组成。 1234567try&#123;&#125;catch(Exception e) &#123;&#125;finally &#123; //程序块&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 异常概述","date":"2019-02-14T03:22:53.000Z","path":"2019/02/14/Java-异常概述/","text":"在程序中，错误可能产生于程序员没有预料到的各种情况，或者是超出了程序员可控范围的环境因素，如用户的坏数据、试图打开一个根本不存在的文件等。 在 Java 中这种在程序运行时可能出现的一些错误称为异常。异常是一个在程序执行期间发生的事件，它中断了正在执行的程序的正常指令流。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 内部类","date":"2019-02-13T02:23:57.000Z","path":"2019/02/13/Java-内部类/","text":"在类中再定义一个类，则 将在类中再定义的那个类称为内部类。内部类可分为成员内部类、局部内部类等。 成员内部类成员内部类简介在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量。 成员内部类的语法如下：12345public class OuterClass &#123; private class InnerClass&#123; //... &#125;&#125; 局部内部类匿名内部类静态内部类内部类的继承","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java final 变量、方法与类","date":"2019-02-12T06:20:39.000Z","path":"2019/02/12/Java-final-变量、方法与类/","text":"final 关键字可用于变量声明，一旦该变量被设定，就不可以再改变该变量的值。通常，由 final 定义的变量为常量。例如，正在类中定义 PI 值。 final 常量1final double PI = 3.14; 在 Java 中定义全局常量，通常使用 public static final 修饰，这样的常量只能在定义时被赋值 final 方法定义为 final 的方法不能被重写。 将方法定义为 final 类型可以防止子类修改该类的定义与实现方式，同时定义为 final 的方法的执行效率要高于非 final 方法。 final 类定义为 final 的类不能被继承。 如果希望一个类不允许任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为 final 形式。 1final 类名&#123;&#125; 如果将某个类设置为 final 形式，则类中所有的方法都被隐式设置为 final 形式，但是 final 类中的成员变量可以被定义为 final 或非 final 形式。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 抽象类与接口","date":"2019-02-10T13:51:16.000Z","path":"2019/02/10/Java-抽象类与接口/","text":"在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类一般将父类定义为抽象类，需要使用这个父类进行继承与多态处理。在继承树中越是在上方的类越抽象，如鸽子类继承鸟类、鸟类继承动物类等。 123public abstract class Test &#123; abstract void testAbstract(); //定义抽象方法&#125; 使用 abstract 关键字定义的类称为抽象类，使用这个关键字定义的方法称为抽象方法。抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写，而承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义。 接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口简介接口是抽象类的延伸，可以看做是纯粹的抽象类，接口中的所有方法都没有方法体。 123public interface drawTest &#123; void draw(); //接口内的方法，省略 abstract 关键字&#125; 在接口中定义的方法必须被定义为 public 或 abstract 形式，其他修饰权限不被 Java 编译器认可，即使不将该方法声明为 public 形式，它也是 public 在接口中定义的任何字段都自动是 static 和 final 的 接口与继承在 Java 中不允许多重继承，但使用接口就可以实现多重继承，因为一个类可以同时实现多个接口，这样就可以将所有需要继承的接口放置在 implements 关键字后并使用逗号隔开，但这可能会在一个类中产生庞大的代码量，因为继承一个接口时需要实现接口中所有的方法。 多重继承的语法如下：1class 类名 implements 接口1,接口2...","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 多态","date":"2019-01-25T05:24:54.000Z","path":"2019/01/25/Java-多态/","text":"多态是同一个行为具有多个不同表现形式或形态的能力。 动态就是同一个接口，使用不同的实例执行不同的操作。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象1Parent p = new Child(); 例子当使用多态方式调用方法时，首先检查父类是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.skm.demo.web.vo;public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat) a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat) a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog) a; c.work(); &#125; &#125;&#125;abstract class Animal &#123; abstract void eat();&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void work() &#123; System.out.println(\"抓老鼠\"); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void work() &#123; System.out.println(\"看家\"); &#125;&#125;//运行结果吃鱼抓老鼠吃骨头看家吃鱼抓老鼠","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 重载与重写","date":"2019-01-24T03:29:20.000Z","path":"2019/01/24/Java-重载与重写/","text":"方法的重载就是在同一类中允许同时存在一个以上的同名方法，只要这些方法的参数个数或类型不同计即可。 初学java的时候容易将两者弄错，对两者的概念不是很清楚，这篇文章主要来讲讲两者的区别。 方法重载（Overload）方法重载指的是在一个类中可以创建多个方法，方法名字相同，而参数列表不同。 重载规则： 参数列表不同（参数的个数、类型或顺序不同） 不能以返回值类型作为重载函数的区分标准。 方法重写（Override）重写是子类对父类的允许访问的方法的实现过程重新编写，返回值和形参都不能改变。 重写的好处在于子类可以根据需要定义特定于自己的行为，子类可以根据需要实现父类的方法。 重写规则： 参数列表必须完全和被重写的方法相同。 返回值类型必须相同。 访问权限不能比父类中被重写方法的访问权限更低。（父类的一个方法为public，子类重写该方法就不能声明为protected） 声明为final的方法不能被重写 声明为static的方法不能被重写，但是能够被再次声明。 实例123456789101112131415161718192021222324public class OverLoadTest&#123; public static int add(int a, int b)&#123; return a + b; &#125; //定义与第一个方法相同名称、参数类型不同的方法 public static double add(double a, double b) &#123; return a + b; &#125; public static int add(int a) &#123; return a; &#125; public static int add(int a, double b)&#123; return 1; &#125; //这个方法与前一个方法的参数次序不同 public static int add(double a, int b) &#123; return 1; &#125; public static void main(String args[]) &#123; System.out.println(\"调用 add(int,int)方法\"+add(1,2)); System.out.println(\"调用 add(double,double)方法：\"+add(2.1,3.3)); System.out.println(\"调用 add(int)方法：\"+add(1)); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 使用 instanceof 操作符判断对象类型","date":"2019-01-23T08:04:57.000Z","path":"2019/01/23/Java-使用-instanceof-操作符判断对象类型/","text":"当程序中执行向下转型操作时，如果父类对象不是子类对象的实例，就会发生 ClassCastExcepion异常，所以在执行向下转型之前需要判断父类对象是否为子类对象的实例。 1myobject instanceof ExampleClass 例子12345678910111213141516171819202122232425class Quadrangle&#123; //四边形类 public static void draw(Quadrangle q) &#123;//四边形类方法 //SomeSentence &#125;&#125;class Square extends Quadrangle&#123; //SomeSentence&#125;class Anything&#123; //SomeSentence&#125;public class Parallelogram extends Quadrangle &#123;//平行四边形类 public static void main(String[] args) &#123; Quadrangle q = new Parallelogram(); //判断父类对象是否为 Parallelogram 子类的一个实例 if (q instanceof Parallelogram)&#123; Parallelogram p = (Parallelogram)q;//向下转型操作 &#125; //判断父类对象是否为 Square 子类的一个实例 if (q instanceof Square) &#123; Square s = (Square)q; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 对象类型的转换","date":"2019-01-22T04:46:43.000Z","path":"2019/01/22/Java-对象类型的转换/","text":"对象类型的转换在 Java 编程中经常遇到，主要包括向上转型与向下转型操作。 向上转型1234567891011class Quadrangle&#123; //四边形类 public static void draw(Quadrangle q) &#123;//四边形类方法 //SomeSentence &#125;&#125;public class Parallelogram extends Quadrangle &#123;//平行四边形类 public static void main(String[] args) &#123; Parallelogram p = new Parallelogram();//实例化平行四边形类对象引用 draw(p);//调用父类方法 &#125;&#125; 平行四边形类继承了四边形类，将子类对象看做是父类对象被称为“向上转型”。 向下转型12345678910111213class Quadrangle&#123; //四边形类 public static void draw(Quadrangle q) &#123;//四边形类方法 //SomeSentence &#125;&#125;public class Parallelogram extends Quadrangle &#123;//平行四边形类 public static void main(String[] args) &#123; draw(new Parallelogram()); //将平行四边形类对象看作是四边形对象，称为向上转型操作 Quadrangle q = new Parallelogram(); Parallelogram p = Parallelogram(q); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java Object 类","date":"2019-01-21T08:24:36.000Z","path":"2019/01/21/Java-Object-类/","text":"在 Java 中，所有的类都直接或间接继承了java.lang.Object 类。Object 类是比较特殊的类，它是所有类的父类，是 Java 类层中的最高层类。当创建一个类时，总是在继承，除非某个类已经指定要从其他类继承，否则它就是从 java.lang.Object类继承而来的。 Object类 方法详解123456789101112clone():Objectequals(Object):booleanfinalize():voidgetClass():Class&lt;?&gt;hashCode():intnotify():voidnotifyAll():voidregisterNatives():voidtoString():Stringwait():voidwait(long):voidwait(long, int):void getClass() 方法getClass() 方法是 Object 类定义的方法，它会返回对象执行的 Class 实例，然后使用此实例调用 getName() 方法可以取得类的名称。1getClass().getName(); toString() 方法toString() 方法的功能是将一个对象返回为字符串形式，它会返回一个 String 实例。 12345678public class ObjectInstance&#123; public String toString() &#123; return \"在\"+getClass().getName()+\"类中重写 toString() 方法\"; &#125; public static void main(String[] args) &#123; System.out.println(new ObjectInstance());//打印本类对象 &#125;&#125; equals()方法123456789101112class V&#123;&#125;public class OverWriteEquals&#123; public static void main(String[] args) &#123; String s1 = \"123\"; String s2 = \"123\"; System.out.println(s1.equals(s2)); V v1 = new V(); V v2 = new V(); System.out.println(v1.equals(v2)); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 类的继承","date":"2019-01-16T06:30:08.000Z","path":"2019/01/16/Java-类的继承/","text":"继承在面向对象开发思想中是一个非常重要的概念，它使整个程序架构具有一定的弹性，在程序中复用一些已经定义完善的类不仅可以减少软件开发周期，也可以提高软件的可维护性和扩展性。 其基本思想是基于某个父类的扩展，制定出一个新的子类，子类可以继承父类原有的属性和方法，也可以增加原来父类所不具备的属性和方法，或者直接重写父类中的某些方法。 例子123456789101112131415161718192021222324252627class Test &#123; public Test()&#123; //SomeSentence &#125; protected void doSomething()&#123; //SomeSentence &#125; protected Test dolt()&#123; return new Test(); &#125;&#125;class Test2 extends Test&#123; public Test2()&#123; super(); super.doSomething(); &#125; public void doSomethingnew()&#123; //SomeSentence &#125; public void doSomething()&#123; //SomeSentence &#125; protected Test2 dolt() &#123; return new Test2(); &#125;&#125; 注意事项当重写父类方法时，修改方法的修饰权限只能从小的范围到大的范围改变，例如，父类中的 doSomething() 方法的修饰权限为 protected，继承后子类中的方法 doSomething() 的修饰权限只能修改为 public，不能修改为 private。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 大数字运算","date":"2019-01-14T22:52:42.000Z","path":"2019/01/15/Java-大数字运算/","text":"在 java中提供了大数字的操作类，即 Java.math.BigInteger 类与 java.math.BigDecimal 类。这两个类用于高精度计算，其中BigInteger 类是针对大整数的处理，而BigDecimal 类则是针对大小数的处理类。 BigIntegerBigInteger 类型的数字范围较 Integer 类型的数字范围要大得多。BigInteger 支持任意精度的整数。 在 BigInteger 类中封装了多种操作，除了基本的加、减、乘、除操作之外，还提供了绝对值、相反数、最大公约数以及判断是否为质数等操作。 使用 BigInteger 类，可以实例化一个 BigInteger 对象，彬自动调用相应的构造函数。BigInteger 类具有很多构造函数，但最直接的一种是参数以字符串形式代表要处理的数字。 12345public BigInteger(String val);val 是十进制数字符串BigInteger twoInstance = new BigInteger(\"2\"); 下面列举了 BigInteger 类中常用的几种运算方法12345678910111213141516public BigInteger add(BigInteger val);//做加法运算public BigInteger subftract(BigInteger val);//做减法运算public BigInteger multiply(BigInteger val);//做乘法运算public BigInteger divide(BigInteger val);//做除法运算public BigInteger remainder(BigInteger val);//做取余运算public BigInteger[] divideAndReainder(BigInteger val);//用数组返回余数和商，结果数组中第一个值为商，第二个值为余数public BigInteger pow(int exponent);//取参数的 exponent 次方操作public BigInteger negate();//取相反数public BigInteger shiftLeft(int n);//将数字左移 n 位，如果 n 为负数，做右移操作public BigInteger shiftRight(int n);//将数字右移 n 位，如果 n 为负数，做左移操作public BigInteger and(BigInteger val);//与操作public BigInteger or(BigInteger val);//或操作public int compareTo(BigInteger val);//数字比较操作public boolean equals(Object x);//当参数x是BigInteger类型的珠子并且数值相等时，返回truepublic BigInteger min(BigInteger val);//返回较小的数字public BigInteger max(BigInteger val);//返回较大的数字 例子：实现大数的各种运算操作1234567891011121314151617181920212223import java.math.BigInteger;public class BigIntegerDemo&#123; public static void main(String[] args)&#123; BigInteger bigInstance = new BigInteger(\"4\");、、实例化一个大数字 //取该大数字 加 2 的操作 System.out.println(\"加法操作：\"+bigInstance.add(new BigInteger(\"2\"))); //取该大数字 减 2 的操作 System.out.println(\"减法操作：\"+bigInstance.subtract(new BigInteger(\"2\"))); //取该大数字 乘 2 的操作 System.out.println(\"乘法操作：\"+bigInstance.multiply(new BigInteger(\"2\"))); //取该大数字 除 2 的操作 System.out.println(\"除法操作：\"+bigInstance.divide(new BigInteger(\"2\"))); //取该大数字 除以 3 的商 System.out.println(\"取商：\"+bigInstance.divideAndReainder(new BigInteger(\"2\"))[0]); //取该大数字 除以 3 的余数 System.out.println(\"取商：\"+bigInstance.divideAndReainder(new BigInteger(\"2\"))[1]); //取该大数字的 2 次方 System.out.println(\"做 2 次方的操作：\"+bigInstance.pow(2)); //取该大数字的相反数 System.out.println(\"取相反数操作：\"+bigInstance.negate()); &#125;&#125; BigDecimal一般的 float 型和 double 型数据只可以用来做科学计算或工程计算，但由于在商业计算中要求数字精度比较高，所以要用到 java.math.BigDecimal 类。BigDecimal 类支持任何精度的定点数，可以用它来精确计算货币值。 两个常用的构造方法12publilc BigDecimal(double val);//将双精度型转换为 BigDecimal 类型public BigDecimal(String val);//将字符串转换为 BigDecimal 类型 例子：高精度大小运算操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.math.BigDecimal;public class BigDecimalDemo&#123; static final int location = 10; /** 加法运算 */ public BigDecimal add(double value1, double value2)&#123; BigDecimal b1 = new BigDecimal(double.toString(value1)); BigDecimal b2 = new BigDecimal(double.toString(value2)); return b1.add(b2); &#125; /** 减法运算 */ public BigDecimal add(double value1, double value2)&#123; BigDecimal b1 = new BigDecimal(double.toString(value1)); BigDecimal b2 = new BigDecimal(double.toString(value2)); return b1.subtract(b2); &#125; /** 乘法运算 */ public BigDecimal add(double value1, double value2)&#123; BigDecimal b1 = new BigDecimal(double.toString(value1)); BigDecimal b2 = new BigDecimal(double.toString(value2)); return b1.multiply(b2); &#125; /** 除法运算 */ public BigDecimal add(double value1, double value2)&#123; return div(value1, value2, location); &#125; //定义除法方法，参数分别为除数与被除数以及商小数点后的余数 public div(double value1, double value2, int b)&#123; if (b &lt; 0) &#123; System.out.printn(\"b 值必须大于等于 0 \"); &#125; BigDecimal b1 = new BigDecimal(double.toString(value1)); BigDecimal b2 = new BigDecimal(double.toString(value2)); return b1.divide(b2, b, BigDecimal.ROUND_HALF_UP); &#125;&#125; 面试题下列程序的输出结果是什么？123456789101112131415import java.util.＊;import java.math.BigInteger;import java.lang.＊;public class Test &#123; public static void main(String[] args) throws NumberFormatException &#123; BigInteger one=new BigInteger(\"1\"); BigInteger two=new BigInteger(\"2\"); BigInteger three=new BigInteger(\"3\"); BigInteger sum=new BigInteger(\"0\"); sum.add(one); sum.add(two); sum.add(three); System.out.println(sum.toString()); &#125;&#125; A. 6 B. 0 C. 1 D. 3 解析： 本题考的是Java中的大数类。（1）BigInteger属于java.math.BigInteger，因此，在每次使用前都要import（输入）这个类，否则会提示找不到提示符。（2）BigInteger构造方法有很多，如：123456BigInteger(String val)//将BigInteger的十进制字符串表示形式转换为BigIntegerBigInteger(String val，int radix)//将指定基数的BigInteger的字符串表示形式转换为BigInteger如要将int型的2转换为BigInteger型，要写为：BigInteger two=new BigInteger(\"2\"); //注意2的双引号不能省略 （3）BigInteger类模拟了所有的int型数学操作，如add()==+，divide()==-等，但注意进行数学运算时，不能直接使用数学运算符进行运算，必须使用其内部方法，而且其操作数也必须为BigInteger型。如：two.add(2)就是一种错误的操作，因为2没有改为BigInteger型。对本题而言，sum返回一个biginteger的值并不改变原来的变量，所以sum的值始终为0。如果想得到6的结果，必须显式地返回，代码如下：123456789101112131415import java.util.＊;import java.math.BigInteger;import java.lang.＊;public class Test &#123; public static void main(String[] args) throws NumberFormatException &#123; BigInteger one=new BigInteger(\"1\"); BigInteger two=new BigInteger(\"2\"); BigInteger three=new BigInteger(\"3\"); BigInteger sum=new BigInteger(\"0\"); sum = sum.add(one); sum = sum.add(two); sum = sum.add(three); System.out.println(sum.toString()); &#125;&#125; 答案： B","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 随机数","date":"2019-01-14T08:32:23.000Z","path":"2019/01/14/Java-随机数/","text":"在实际开发中产生随机数的使用是很普遍的，所以在程序中进行随机数操作也是很重要的。 在 Java 中主要提供了两种方式产生随机数，分别是 Math 类的 random() 方法和 Random 类提供的产生各种数据类型随机数的方法。 Math.random() 方法在 Math 类中存在一个 random() 方法，用于产生随机数字，这个方法默认生成大于等于 0.0 且小于 1.0 的 double 型随机数, 即 0 &lt;= Math.random() &lt; 1.0. 12345678910111213141516public class MathRandom&#123; public static int GetAnyNum(double num1, double num2) &#123; //产生 num1 ~ num2 之间的随机数 int s = (int)num1 + (int)(Math.random() *(num2-num1)); if(s % 2 == 0)&#123; return s; &#125;else return s + 1; &#125; public static void main(String[] args) &#123; //调用产生随机数方法 System.out.println(\"任意一个 2-32 之间的偶数：\"+ getAnyNum(2, 32)); &#125;&#125; Random 类除了 Math 类的 random() 方法可以获取谁随机数之外，Java 还提供了一种获取随机数的方式，那就是 Java.util.Random 类。 1234567891011121314151617181920import java.util.Random;public class RandomDemo&#123; public static void main(String[] args) &#123; Random r = new Random();//实例化一个 Random 类 //随机产生一个整数 System.out.println(\"随机产生一个整数：\"+r.nextInt()); //随机产生一个大于等于0且小于10的整数 System.out.println(\"随机产生一个大于等于0且小于10的整数：\"+r.nextInt(10)); //随机产生一个布尔型的值 System.out.println(\"随机产生一个布尔型的值：\"+r.nextBoolean()); //随机产生一个双精度的值 System.out.println(\"随机产生一个双精度的值：\"+r.nextDouble()); //随机产生一个浮点型的值 System.out.println(\"随机产生一个浮点型的值：\"+r.nextFloat()); //随机产生一个概率密度为高斯分布的双精度值 System.out.println(\"随机产生一个概率密度为高斯分布的双精度值：\"+r.nextGaussian()); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 数学运算","date":"2019-01-11T05:36:48.000Z","path":"2019/01/11/Java-数学运算/","text":"在 Java 语言中提供了一个执行数学基本运算的 Math 类，该类包括常用的数学运算方法，如三角函数方法、指数函数方法、对数函数方法、平方根函数方法等一些常用数学函数，初次之外还提供了一些常用的数学常量，如PI、E等。 Math 类在 Math 类中提供了众多数学函数方法，主要包括三角函数方法、指数函数方法、取整函数方法、取最大值、最小值和平均值函数方法，这些方法都被定义成 static 形式，方便调用。 常用数学运算方法在 Math 类中的常用数学运算方法较多，大致可以将其分为 4 大类别。分别为 三角函数方法、指数函数方法、取整函数方法以及取最大值、最小值好绝对值函数方法。 三角函数方法在 Math 类中包含的三角函数方法如下：12345678public static double sin(double a); 返回角的三角正弦public static double cos(double a); 返回角的三角余弦public static double tan(double a); 返回角的三角正切public static double asin(double a); 返回一个值的反正弦public static double acos(double a); 返回一个值的反余弦public static double atan(double a); 返回一个值的反正切public static double toRadians(double angdeg); 将角度转换为弧度public static double toDegrees(double angrad); 将弧度转换为角度 特别注意的是：角度和弧度转换通常是不精确地 123456789101112public class TrigonometricFunction&#123; public static void main(String args) &#123; //取 90 °的正弦 System.out.println(\"90度的正弦值：\"+Math.sin(Math.PI/2))； //取 0 ° 的余弦 System.out.println(\"0度的余弦值：\"+Math.cos(0)); //取 60 ° 的 正切 System.out.println(\"60 度的正切值:\" + Math.tan(Math.PI / 3)); &#125;&#125; 指数函数方法 Math 类中与指数相关的函数方法如下：123456public static double exp(double a); //用于获取 e 的 a 次方public static double log(double a); //用于取自然对数public static double log10(double a ); //用于取底数为10的对数public static double sqrt(double a );//用于取 a 的平方根，其中 a 不能为负值public static double cbrt(double a ); //用于取 a 的立方根public static double pow(double a, double b);//用于取 a 的 b 次方 12345678910111213public class ExponentFunction&#123; public static void main(String[] args) &#123; System.out.println(\"e 的平方值：\" + Math.exp(2)); //取以 e 为底 2 的对数 System.out.println(\"以e为底2的对数：\"+ Math.log(2)); //取以10 为底 2 的对数 System.out.println(\"以10为底 2 的对数值：\"+Math.log10(2)); System.out.println(\"4 的平方根值：\" + Math.sqrt(4)); System.out.println(\"8 的立方根值：\"+Math.cbrt(8)); System.out.println(\"2 的 2 次方值：\" + Math.pow(2,2)); &#125;&#125; 取整函数方法在具体的问题中，取整操作使用也很普遍。12345public static double ceil(double a);//返回大于等于参数的最小整数 public static double floor(double a); //返回小于等于参数的最大整数public static double rint(double a);//返回与参数最接近的整数，如果两个同为整数且童颜接近，则结果取整数、public static int round(float a);//将参数加上0.5后返回与参数最近的整数public static long round(double a );//将参数加上0.5之后返回与参数最近的整数，然后强制转换为长整型 由于数 1.0和 数 2.0 距离数 1.5 都是0.5个单位长度，因此返回偶数 2.0123456789101112131415public class intFunction&#123; //返回第一个大于等于参数的整数 System.out.println(\"使用 ceil() 方法取整：\"+Math.ceil(5.2)); //返回第一个小于等于参数的整数 System.out.println(\"使用 floor 方法取整：\"+ Math.floor(2.5)); //返回与参数最接近的整数 System.out.println(\"使用 rint() 方法取整：\"+Math.rint(2.7)); //返回与参数最接近的整数 System.out.println(\"使用 rint 方法取整：\"+ Math.rint(2.5)); //将参数加上 0.5 之后返回最接近的整数 System.out.println(使用 round方法取整：\"+Math.round(3.4f)); //将参数加上 0.5 之后返回最接近的整数，并将结果强制转换为长整型 System.out.println(\"使用 round 方法取整：\"+Math.round(2.5));&#125; 取最大值、最小值、绝对值函数方法 在程序中最常用的方法就是取最大值、最小值、绝对值等，在 Math 类中包括这些操作方法123456789public static double max(double a, double b);//取a与b之间的最大值public static int min(int a, int b);//取a与b之间的最小值，参数是整型public static long min(long a, long b);//取a与b之间的最小值，参数是长整型public static float min(float a, float b);//取a与b之间的最小值，参数是浮点型public static double min(duble a, double b);//取a与b之间的最小值，参数是双精度型public static int abs(int a);//返回整形参数的绝对值public static long abs(long a);//返回长整型参数的绝对值public static float abs(float a);//返回浮点型参数的绝对值public static double abs(double a);//返回双精度型参数的绝对值 12345678910public class AnyFunction&#123; public static void main(String[] args) &#123; System.out.println(\"4 和 8 较大者：\"+ Math.max(4,8)); //取两个参数的最小值 System.out.println(\"4.4 和 4 较小者：\"+Math.min(4.4, 4)); //取参数的绝对值 System.out.println(\"-7 的绝对值：\"+ Math.abs(-7)); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 数字格式化","date":"2019-01-10T05:38:36.000Z","path":"2019/01/10/Java-数字格式化/","text":"数字的格式化在解决实际问题时使用非常普遍，如表示某超市的商品价格，不要八六两位有效数字。Java 主要对浮点型数据进行数字格式化操作，其中浮点型数据包括 double 和 float 型数据，在 java 中使用 Java.text.DecimalFormat格式化数字。 DecimalFormat 是 NumberFormat 的一个子类，用于格式化十进制数字。他可以将一些数字格式化为整数、浮点数、百分数等。通过使用该类可以为要输出的数字加上单位或控制数字的精度。 DecimalFormat 类中特殊字符说明 格式化数字的例子 12345678910111213141516171819202122232425262728293031import java.text.DecimalFormat;public class DecimalFormatSimpleDemo &#123; //使用实例化对象时设置格式化模式 static public void SimpleFormat(String pattern, double value) &#123; //实例化 DecimalFormat 对象 DecimalFormat myFormat = new DecimalFormat(pattern); String output = myFormat.format(value);//将数字格式化 System.out.println(value+\" \"+pattern+\" \"+output): &#125; //使用 applyPattern() 方法对数字进行格式化 static public void UseApplyPatternMethodFormat(String pattern, double value) &#123; DecimalFormat myFormat = new DecimalFormat(); myFormat.applyPattern(pattern); System.out.println(value+\" \"+pattern+\" \"+myFormat.format(value)); &#125; public static void main(String[] args) &#123; SimpleFormat(\"###,###.###\", 123456.789); SImpleFormat(\"00000000.###kg\", 123456.789); //按照格式模式格式化数字，不存在的位以 0 显示 SimpleFormat(\"000000.000\", 123.78); //调用静态 UseApplyPatternMethodDormat()方法 UseApplyPatternMethodFormat(\"#.###%\", 0.789); //将小数点够格式化为两位 UseApplyPatternMethodFormat(\"###.##\", 123456.789); //将数字格式为 千分数形式 UseApplyPatternMethodFormat(\"0.00\\u2030\", 0.789); &#125;&#125; 在 DecimalFormat 类中除了可以设置格式化模式来格式化数字之外，还可以使用一些特殊方法对数字进行格式化设置。例如分组。。 1234567891011121314Import java.text.DecimalFormat;public class DecimalMethod &#123; public static void main(String[] args) &#123; DecimalFormat myFormat = new DecimalFormat(); myFormat.setGroupingSize(2);//设置将数字每两个分一组 String output = myFormat.format(123456.789); System.out.println(\"将数字以每两个数字分组\"+ output ); myFormat.setGroupingSize(false);//设置不允许分组 String output = myFormat.format(123456.789); System.out.println(\"不允许数字分组\"+ output ); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"java 包装类","date":"2019-01-09T08:12:31.000Z","path":"2019/01/09/java-包装类/","text":"Java 是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样的八个和基本数据类型对应的类统称为包装类（wrapper class）。 12345678910基本类型 大小 包装器类型boolean / Booleanchar 16bit Character byte 8bit Byte short 16bit Short int 32bit Integer long 64bit Long float 32bit Float double 64bit Doublevoid / Void Java中的包装器类有两个主要的目的： 提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。注意，java5增加了自动装箱和拆箱，程序员过去需手工执行的许多包装操作，现在可以由java自动处理了。 为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制. 自动装箱和拆箱自动装箱和拆箱问题是Java中一个老生常谈的问题了，今天就来一些看一下装箱和拆箱中的若干问题。本文先讲述装箱和拆箱最基本的东西，再来看一下面试笔试中经常遇到的与装箱、拆箱相关的问题。 定义在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行： 1Integer i = new Integer(100); 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了： 1int i = 100; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型： 12Integer i = 10; //装箱int index = i; //拆箱 简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 注意： 12Integer test = null;int f = test.intValue(); 上面的代码编写时不会报错，但编译是通不过的。 实现机制我们就以Interger类为例，下面看一段代码： 1234public static void main(String[] args)&#123; Integer i = 10; //装箱 int index = i; //拆箱&#125; 反编译class文件之后得到如下内容： 从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。 因此可以用一句话总结装箱和拆箱的实现过程： 装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。 面试问题虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题，建议先自己尝试编译看源码做做。 下面这段代码的输出结果是什么？ 1234567891011public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。这里注意“==”和“equal”的区别： 基本类型 == equals 字符串变量 对象在内存中的首地址 字符串内容 非字符串变量 对象在内存中的首地址 对象在内存中的首地址 基本类型 值 不可用 包装类 地址 内容 结果：truefalse 为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现： 123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; 从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在 [-128,127] 之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。 上面的代码中 i1 和 i2 的数值为100，因此会直接从cache中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。 下面这段代码的输出结果是什么？ 1234567891011public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为：falsefalse至于具体为什么，读者可以去查看Double类的valueOf的实现。 在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。 注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。 下面这段代码的输出结果是什么？ 1234567891011public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 输出结果为：truetrue至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现： 123public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE); &#125; 至于TRUE和FALSE的定义： 1234567891011/** * The &#123;@code Boolean&#125; object corresponding to the primitive * value &#123;@code true&#125;. */ public static final Boolean TRUE = new Boolean(true); /** * The &#123;@code Boolean&#125; object corresponding to the primitive * value &#123;@code false&#125;. */ public static final Boolean FALSE = new Boolean(false); 谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别： 1）第一种方式不会触发自动装箱的过程；而第二种方式会触发； 2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。 下面这段代码的输出结果是什么？ 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); &#125;&#125; 先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==” 运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然： 1234567truefalsetruetruetruefalsetrue 第一个和第二个输出结果没有什么疑问。第三句由于 a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 对象的创建、引用、比较与销毁","date":"2019-01-08T07:17:02.000Z","path":"2019/01/08/Java-对象的创建、引用、比较与销毁/","text":"Java 是一门面向对象的程序设计语言，对象是由类抽象出来的，所有的问题都通过对象来处理，对象可以操作类的属性和方法解决相应的问题。，所以了解对象的产生、操作和消亡是十分必要的。 对象的创建对象可以认为是在一类事物中抽象某一个特例可以通过这个特例来处理这类事物出现的问题。在 Java 语言中通过 new 操作符来创建对象。 准确地说可以在 java 语言中使用 new 操作符调用构造方法创建对象。 12Test test = new Test();Test test = new test(\"a\"); 访问对象的属性和行为用户使用 new 操作符创建一个对象后，可以使用 “对象.类成员”来获取对象的属性和行为。对象的属性和行为在类中是通过类成员变量和成员方法的形式来表示的，所以当对象获取类成员时，也相应地获取了兑现的属性和行为。 例子：展示对象是如何调用类成员的12345678910111213141516171819202122232425262728public class TransferProperty&#123; int i = 47; //定义成员变量 public void class()&#123; System.out.println(\"调用 call 方法\"); for(i=0; i&lt;3; i++)&#123; System.out.println(i + \"\"); if ( i == 2) &#123; System.out.println(\"\\n\"); ) &#125; &#125; public TransferProperty() &#123;&#125;//定义构造方法 public static void main(String[] args) &#123; TransferProperty t1 = new TransferProperty(); //创建一个对象 TransferProperty t2 = new TransferProperty(); //创建另一个对象 t2.i = 60; //将类成员变量赋值为 60 //使用第一个对象调用类成员变量 System.out.println(\"第一个实例对象调用变量 i 的结果：\"+ t1.i++); t1.call(); //使用第二个兑现调用类成员变量 System.out.println(\"第二个实例对象调用变量 i 的结果：\"+t2.i); t2.call(); &#125;&#125; 对象的引用在 Java 语言中尽管一切都可以看做对象，但真正操作标识符实质上是一个引用，那么引用在 Java 中应该如何体现？ 1类名 对象引用名称 如一个 Book 类的引用可以使用一下代码：1Book book; 通常一个引用不一定需要有一个对象相关联。引用于对象相关联的语法如下：1Book book = new Book(); 对象的比较在 Java 语言中有两种对象的比较方式，分别为“==”运算符和 equals() 方法。实质上这两种方式有着本质的区别。 说明 == 和 equals 方法的区别12345678910111213public class Compare &#123; public static void main(String[] args) &#123; String c1 = new String(\"abc\"); String c2 = new String(\"abc\"); String c3 = c1 ; //使用“==”运算符比较 c2 和 c3 System,out.println(\"c2==c3的运算结果为：\"+(c2 == c3)); //使用 &#125;&#125; 对象的销毁每个对象都有生命周期，当对象的生命周期结束时，分配给该对象的内存地址将会被回收。在其他语言中需要手动回收废弃的对象，但是 Java 拥有一套完整的垃圾回收机制，用户不必担心废弃的对象占用内存，垃圾回收期将回收无用的但占用内存的资源。 在谈到垃圾回收机制之前，首先需要了解何种对象会被Java虚拟机视为垃圾。主要包括以下两种情况。 对象引用超过其作用范围，这个对象将被视为垃圾。 将对象赋值为 null 虽然垃圾回收机制已经很完善，但垃圾回收期只能回收那些由 new 操作符创建的对象。如果某些对象不是通过 new 操作符在内存中获取一块内存区域，这种对象可能不能被垃圾回收机制所识别，所以在 Java 中提供了一个 finalize() 方法。 这个方法是 Object 类的方法，它被声明为 protected，用户可以在自己的类中定义这个方法。如果用户在类中定义了 finalize() 方法，在垃圾回收时会搜狐先调用该方法，在下一次垃圾回收动作发生时，才能真正回收被对象占用的内存。 有一点需要明确的是，垃圾回收 或 finalize() 方法不保证一定会发生，如 Java 虚拟机内存损耗殆尽时，它是不会执行垃圾回收的。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 类的主方法","date":"2019-01-08T04:05:55.000Z","path":"2019/01/08/Java-类的主方法/","text":"主方法是类的入口点，它定义了程序从何处开始；主方法提供对程序流向的控制，Java 编译器通过主方法来执行程序。主方法的语法如下： 123public static void main(String[] args) &#123; //方法体&#125; 在主方法的定义中可以看到其具有以下特性： 主方法是静态的，所以如要直接在主方法中调用其他方法，则该方法必须也是静态的。 主方法没有返回值 主方法的形参为数组。其中 args[0] ~ args[n]分别代表程序的第一个参数到第n个参数，可以使用 args.length 获取参数的个数。 12345678public class TestMain&#123; public static void main(String[] args) &#123; for(int i=0; i&lt;args.length; i++) &#123; //根据参数个数做循环操作 System.out.println(args[i]); //循环打印参数内容 &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 静态变量、常量与方法","date":"2019-01-01T11:55:08.000Z","path":"2019/01/01/Java-静态变量、常量与方法/","text":"由 static 修饰的变量、常量和方法被称做静态变量、常量和方法。 有时，在处理问题时会需要两个类在同一个内存区域共享一个数据。例如，在球类中使用 PI 这个常量，可能出了本类需要这个常量之外，在另外一个圆类中也需要使用这个常量。这时没有必要在两个类中同时创建 PI 常量，因为这样系统会将这两个不在同一个类中定义的常量分配到不同的内存空间中。为了解决这个问题，可以将这个常量设置为静态的。 被声明为 static 的变量、常量和方法被称为静态成员。静态成员属于类所有，区别于个别对象，可以在本类或其他类使用类名和 “.” 运算符调用静态成员。 例子1234567891011121314public class StaticTest&#123; final static double PI = 3.1415; //在类中定义静态常量 static int id; //在类中定义静态变量 public static void method1()&#123; //在类中定义静态方法 //do something &#125; public void method2()&#123; System.out.println(StaticTest.PI); //调用静态常量 System.out.println(StaticTest.id); //调用静态变量 StaticTest.method1(); //调用静态方法 &#125;&#125; 注意在 Java 中规定不能讲方法体内的局部变量声明为 static 的。12345public class example&#123; public void method() &#123; static int i = 0; //这句是错误的。 &#125;&#125; 技巧如果在执行类时，希望先执行类的初始化操作，可以使用 static 定义一个静态区域。12345public class example&#123; static&#123; //some &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 类构造方法","date":"2019-01-01T11:51:49.000Z","path":"2019/01/01/Java-类构造方法/","text":"在 类 中除了成员方法之外，还存在一种特殊类型的方法，那就是构造方法。构造方法是一个与类同名的方法，对象的创建就是通过构造方法完成的。每当类实例化一个对象时，类都会自动覅用构造方法。 构造方法的特点如下： 构造方法没有返回值 构造方法的名称要与本类的名称相同 在定义构造方法时，构造方法没有返回值，但这与普通美哦与返回值的方法不同，普通没有返回值的方法使用 public void methodEx() 这种形式进行定义，但构造方法并不需要使用 void 关键字进行修饰。 构造方法的定义语法格式如下：123public book()&#123; ...//构造方法体&#125; 例子12345678910public class AnyThting &#123; public AnyThting()&#123; this(\"this 调用有参构造方法\"); System.out.println(\"无参构造方法\")； &#125; public AnyThting(String name)&#123; System.out.println(\"有参构造方法\"); &#125;)&#125; 面试题下面哪个选项的说法是正确的？A. 构造函数不能被重载B. 构造函数不能被覆盖C. 一个构造函数可以返回一个私有的或一个对象的引用D. 构造函数代码执行时是从当前的类层级到它祖先的类 解析：重载构造函数是一个主要的技术，可以允许多种方式初始化一个类。通过定义，构造函数是没有返回值的。所以选项C是错误的，这种说法并没有任何意义。选项D中构造函数代码的执行是从它最老的祖先类开始向下执行调用。可以写一个继承一个基类的类来测试，当创建一个子类的时候，会发现它的祖先类的构造函数先被调用。答案： B 下列有关派生类调用父类构造函数的描述中正确的是哪个？A.派生类定义了自己的构造函数，就不会调用父类的构造函数B.派生类必须通过super调用父类的含有参数的构造函数C.派生类将会继承父类中所有的构造函数D.创建派生类对象时，先调用派生类自己的构造函数，然后调用父类的构造函数 解析：派生类被构造时一定会先调用父类的构造函数，排除选项A、D。你可以选择调用哪个构造函数，可以决定调用哪一个，但不能都不调用（至少必选一个），排除选项C。若不指定，就会调用无参数的构造函数，以下代码调用的是无参构造函数，得到 A without any parameter B with a parameter的结果。代码如下：12345678910111213141516171819202122232425262728class A&#123; public A() &#123; System.out.println(\"A without any parameter \"); &#125; public A(int i) &#123; System.out.println(\"A with a parameter\"); &#125;&#125;class B extends A&#123; public B() &#123; System.out.println(\"B without any parameters. \"); &#125; public B (int i) &#123; System.out.println(\"B with a parameter\"); &#125;&#125;class Test&#123; public static void main(String args[])&#123; B a =new B(100); &#125;&#125; 如果选定调用A(int i)，则会得到A with a parameter B with a parameter的结果，代码如下： 1234567891011121314151617181920212223242526272829class A&#123; public A() &#123; System.out.println(\"A without any parameter \"); &#125; public A(int i) &#123; System.out.println(\"A with a parameter\"); &#125;&#125;class B extends A&#123; public B() &#123; System.out.println(\"B without any parameters. \"); &#125; public B (int i) &#123; super(i); System.out.println(\"B with a parameter\"); &#125;&#125;class Test&#123; public static void main(String args[])&#123; B a =new B(100); &#125;&#125; 答案： B","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java this 和 super 关键字","date":"2019-01-01T11:49:35.000Z","path":"2019/01/01/Java-this-和-super-关键字/","text":"本文大致介绍了 java 中的两个关键字，它们分别是 this 和 super。 this 关键字this 是指向对象本身的一个指针。this 只能在类中的非静态方法中使用，静态方法 和静态代码中绝对不能出现 this 关键字。 调用本类的构造方法仅仅在类的构造函数中调用本类的其他构造函数。用法是 this(参数列表),这一句必须处于构造函数的第一句，同时一个构造函数内部只能调用另一个构造函数。 12345678910111213class A&#123; private string name; public A()&#123; System.out.print(\"无参数构造函数！\"); &#125; public A(int b)&#123; System.out.print(b); &#125; public A(String s)&#123; this(1);//调用参数为int型的构造函数 name = s; &#125;&#125; 表示类中属性和方法用this来访问类中的属性和方法。比如函数参数或者参数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用”this.成员变量名”来访问成员变量。 12345678class B&#123; private int x = 1; public void out()&#123; int x = 2; System.out.print(x);//打印2 System.out.print(this.x);//打印1 &#125;&#125; 表示当前对象在函数中，需要引用该函数所属类的当前对象时候，直接使用this。 123456789class C&#123; public static void main(String[] args)&#123; C c1 = new C(); c1.tell(); &#125; public static void tell()&#123; System.out.print(this);//打印当前对象的字符串表示 &#125;&#125; 匿名类和内部类在匿名类或者内部类中用this时，这个this指的是匿名类或内部类本身。这是如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。 例子12345678910public class Hello&#123; int i = 1; public Hello()&#123; Thread thread = new Thread()&#123;//匿名类 public void run()&#123; Hello.this.run();//调用外部类的方法 &#125; &#125;;//这里有分号 &#125;&#125; super 关键字 super关键和this作用类似，是使被屏蔽的成员变量或者成员方法变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。 在子类构造方法中调用父类的构造方法用super(参数列表)的方式调用，参数不是必须的。同时，还要注意super(参数列表)这条语句只能在子类构造方法中的第一行 。 例子1234567891011class A&#123; public A()&#123; System.out.print(\"A\"); &#125;&#125;class B extends A&#123; public B()&#123; super();//调用父类构造方法，打印A System.out.print(\"B\"); &#125;&#125; 访问父类中被覆盖的同名变量或者方法当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类变量覆盖同名父类变量时，可以使用super.成员变量名引用父类成员变量。同时，若子类的成员方法覆盖了父类的成员方法时，也可以使用super.方法名(参数列表)的方式访问父类的方法。 例子1234567891011121314151617class A&#123; public int a = 1;//可以直接赋值，不用通过构造函数 public void say()&#123; System.out.print(a); &#125;&#125;class B extends A&#123; private int a = 2; public void say()&#123; System.out.print(super.a);//访问父类的a变量，前提是父类的a变量是公有的 &#125; public void tell()&#123; super.say();//调用父类的say()方法而不是子类的say()方法 &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 局部变量以及它的有效范围","date":"2019-01-01T11:47:05.000Z","path":"2019/01/01/Java-局部变量以及它的有效范围/","text":"局部变量是在方法被执行时创建，在方法执行结束时被销毁。局部变量在使用时必须进行赋值操作或被初始化，否则会出现编译错误。 例子12345public String getName() &#123; int id = 0 ; //局部变量 setName(\"Java\"); return id + this.name;&#125; 如果将 id 这个局部变量的初始值去掉，编译器将出现错误。 局部变量的有效范围可以将局部变量的有效范围称为变量的作用域，局部变量的有效范围从该变量的声明开始到该变量的结束为止。 在作用范围外使用局部变量是一个常见的错误，因为在作用域外没有声明局部变量的代码","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 修饰符","date":"2019-01-01T09:51:26.000Z","path":"2019/01/01/Java-修饰符/","text":"Java 语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 访问修饰符在 Java 中有以下四种访问修饰符。 public protected default private public - 公有访问修饰符被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。 由于类的继承性，类所有的公有方法和变量都能被其子类继承。 以下函数使用了公有访问控制： 123public static void main(String[] arguments) &#123;// ... &#125; java 程序的 main() 方法必须设置成公有的，否则 java 解释器将不能运行该类。 protected - 受保护的访问修饰符protected 需要从以下两个点来分析说明 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问。 子类与基类不在同一包中：子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。 protected 可以修饰数据成员、构造方法、方法成员，不能修饰类（内部类除外） 接口以及接口的成员变量和成员方法不能声明为 protected 默认访问修饰符 - 不使用关键字使用默认访问修饰符声明的变量和方法，对同一个包的类是可见的。 接口里的变量都隐式声明为 public static final ，而接口里的方法默认情况下访问权限为 public. private - 私有访问修饰符私有访问修饰符是最严格的访问级别，被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。 声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。 Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 访问控制和继承方法继承规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符为了实现一些其他的功能， java 也提供了许多非访问修饰符。 static 修饰符 final 修饰符 abstract 修饰符 synchronized 修饰符 volatile 修饰符 …. static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为 static 变量 静态方法 static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。 final 修饰符 final 变量： 变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 方法： 类中的 final 方法可以被子类继承，但是不能被子类修改。 声明 final 方法的主要目的是防止该方法的内容被修改。 final 类： final 类不能被继承，没有类能够继承 final 类的任何特性。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Android 简介","date":"2018-10-28T15:03:54.000Z","path":"2018/10/28/Android-简介/","text":"Android 从面世以来到现在已经发布了二十几个版本了。在这几年的发展过程中，谷歌为Android 王国建立了一个完整的生态系统。手机厂商、开发者、用户之间相互依存，共同推进着Android的蓬勃发展。 Android 系统架构为了更好的理解 Android 系统是怎么工作的，我们先来看一下它的系统架构。Android 大致可以分为四层架构：Linux 内核层、系统运行库层、应用框架层和应用层。 Linux 内核层Android 系统是基于 Linux内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。 系统运行库层这一层通过一些 C/C++ 库来为 Android 系统提供了主要的特性支持。如SQLite 库提供了数据库的支持，OpenGL/ES 库提供了 3D 绘图的支持，WebKit 库提供了浏览器内核的支持等。 同样在这一层还有 Android 运行时库，它主要提供了一些核心库，能够允许开发者使用 Java 语言来编写 Android 应用。另外，Android 运行时库中还包含了 Dalvik 虚拟机（5.0 系统之后改为 ART 运行环境），它使得每一个 Android 应用都能运行在独立的进程当中，并且拥有一个自己的 Dalvik 虚拟机实例。相较于 Java 虚拟机，Dalvik 时专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。 应用框架层这一层主要提供了构建应用程序时可能用到的各种 API， Android 自带的一些核心应用就是使用这些 APi 完成的，开发者也可以通过使用这些 API 来构建自己的应用城固县。 应用层所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从 GooGle Play 上下载的小游戏，当然还包括你自己开发的程序等。 Android 已发布的版本2008 年 9 月，谷歌正式发布了 Android 1.0 系统，这也是 Android 系统最早的版本。随后的几年，谷歌以惊人的速度不断地更新 Android 系统。具体如下图所示： 数据来源：戳我 Android 应用开发特色 四大组件：活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider）。 丰富的系统控件 SQLite 数据库 强大的多媒体 地理位置定位","tags":[{"name":"Android","slug":"Android","permalink":"https://www.ttxxly.top/tags/Android/"}]},{"title":"HTML 简介","date":"2018-10-28T15:01:41.000Z","path":"2018/10/28/HTML-简介/","text":"超文本标记语言（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。您可以使用 HTML 来建立自己的 WEB 站点， HTML 运行在浏览器上，由浏览器来解析。 什么是 HTML ？HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言：HyperText Markup Language HTML 不是一种编程语言，而是一种标记语言。 标记语言是一套标记标签（Markup tag） HTML 使用标记标签来描网页。 HTML 文档包含了 HTML 标签以及文本内容 HTMl 文档也叫做 WEB 页面 HTML 标签HTML 标记标签通常被称为 HTML 标签（HTML tag） HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成队出现的，比如 &lt;b&gt; 和 &lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签。 开始和结束标签也被称为开放标签和闭合标签 &lt;!DOCTYPE&gt; 声明&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： 1234&lt;!DOCTYPE html&gt; &lt;!DOCTYPE HTML&gt; &lt;!doctype html&gt; &lt;!Doctype Html&gt;","tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.ttxxly.top/tags/HTML/"}]},{"title":"Java 变量与常量","date":"2018-10-28T14:50:56.000Z","path":"2018/10/28/Java-变量与常量/","text":"在程序执行过程中，其值不能被改变的量称为常量，其值能被改变的量被称为变量。变量与常量的命名都必须使用合法的标识符。 标识符和关键字标识符标识符可以简单地理解为一个名字，用来标识类名、方法名、数组名、文件名的有效字符序列。 Java 语言规定标识符由任意顺序的字母、下划线、美元符号和数字组成，并且第一个字符不能是数字。标识符不能是 Java 中的保留字，并且在 Java 语言中的字母是严格区分大小写的。 关键字关键字是 Java 语言中已经被赋予特定意义的一些单词，不可以把这些字作为标识符来使用。 声明变量变量饿使用是程序谁中一个十分重要的环；。定义变量就是要告诉编译器（compiler）这个变量的数据类型，这样编译器才知道许哟啊配置多少空间给它，以及它能够存储怎样的数据。 12int age;char char1 = 'Y'; 对变量的命名，应该遵循下面的规则 变量名必须是一个有效的标识符 变量名不能重复 变量名应该是有意义的 注：在 Java 语言中是允许使用汉字或其他语言文字作为变量名，但不建议这样做。 声明常量在程序运行过程中一直不会改变的量称为常量（constant），通常也称为 “final 变量”。常量在整个程序中通常只能被赋值一次。在为所有的对象共享值时，常量时非常有用的。 声明常量的标准语言以及例子1234final 数据类型 常量名称[=值];final double p1 = 3.1415926;final boolean b1 = true; 变量的有效范围由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，该变量会被释放掉，也就是说变量有它的生命周期。 按照变量的有效范围将变量分为成员变量和局部变量。 成员变量在类体中定义的变量被称为成员变量，成员变量在整个类中都有效。类的成员变量又可以分为静态变量和实例变量。 1234class var &#123; int x = 45; static int y = 90;&#125; 在成员变量的类型前面加上关键字 static 后，这样的变量就被称为静态变量。对于静态变量，除了能在定义它的类存取，还可以以“类名.静态变量”的方式在其他类中使用。 局部变量在类的方体中定义的变量称为局部变量。布局变量只在当前代码块中有效。 在类的方法中声明的变量，包括方法的参数，都属于局部变量。局部变量的生命周期取决于方法，当单发被调用时，Java 虚拟机为方法中的局部变量分配内存空间，当该方法的调用结束后，则会释放方法中局部变量占用的内存空间，局部变量也将会销毁。 1234567public class val&#123; static int times = 3;//定义成员变量 public static void main(String[] args)&#123; int times = 4;//定义局部变量 System.out.println(\"Times 的值为：\"+times); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Python 简介","date":"2018-10-28T14:48:59.000Z","path":"2018/10/28/Python-简介/","text":"Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 发展历史Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。 Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。 像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。 现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。 Python 特点 1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。 2.易于阅读：Python代码定义的更清晰。 3.易于维护：Python的成功在于它的源代码是相当容易维护的。 4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。 5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。 6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。 7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。 8.数据库：Python提供所有主要的商业数据库的接口。 9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。 10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.ttxxly.top/tags/Python/"}]},{"title":"Java 基本数据类型","date":"2018-10-26T12:04:43.000Z","path":"2018/10/26/Java-基本数据类型/","text":"在 Java 中有 8 种基本数据类型来存储数值、字符和布尔值。 12345数值型： 整数类型：byte、short、int、long 浮点类型：float、double字符型：char布尔型：boolean 整数类型整数类型用来存储整数数值，即没有小数部分的数值。可以是正数，也可以是负数。整数数据在Java 程序中有 3 种表示方式，分别为 十进制、八进制和十六进制。 十进制十进制的表现形式是最常见的，如 120、0、-127. 注意：不能以 0 作为十进制数的开头（0 除外） 八进制如 0123（转换成十进制就是 83）、-0123（转换成十进制是 -83）。 注意：八进制必须以 0 开头 十六进制如 0x25（转换成十进制数是 37）、0Xb1e（转换成十进制是 45086） 注意： 十六进制必须以 0X 或 0x 开头 整型数据根据它所占内存大小的不同，可分为 byte、short、int、long 4种类型，他们具有不同的取值范围，如下表所示。 数据类型 内存空间（8位=1字节） 取值范围 byte 8位 -128～127 short 16位 -32768～32767 int 32位 -2147483648～2147483647 long 64位 -9223372036854775808～9223372036854775807 下面以 int 型变量为例讲解整型变量的定义。 定义 int 型变量，示例代码如下：123int x; //定义 int 型变量 xint x,y;//定义 int 型变量 x、yint x = 450, y = -463; //定义 int 型变量 x、y 并赋初值 注意1：定义以上 4 种类型变量时，需要注意变量的取值范围，超出相应范围就会出错。注意2: 对于 long 型数值，若赋的初值大于 int 型的最大值或小于 int 型的最小值，则需要在数值后加 L 或 l，表示该值是长整型，如 long num = 2147483650L。 运算操作，输出和1234567891011121314public class Number &#123; public static void main(String[] args) &#123; byte mybyte = 124; short myshort = 32564; int myint = 45784612; long mylong = 4678951; long result = mybyte + myshort + myint + mylong; System.out.println(\"结果为：\"+ result); &#125;&#125;程序运行结果为：结果为：92606751 浮点类型浮点类型表示有小数部分的数字。Java 语言中浮点类型可分为单精度浮点类型（float）和双精度浮点型（double），它们具有不同的取值范围，如下表所示。 数据类型 内存空间（8位=1字节） 取值范围 float 32位 1.4E-45～3.4028235E38 double 64位 4.9E-324～1.797693234862315E308 在默认情况下，小数都被看作是 double 型，若使用 float 型小数，则需要在小数后面加上F或f。 定义浮点类型变量，示例代码如下：123float f1 = 13.23f;double d1 = 354.12d;double d2 = 23456.2345; 字符类型char 型字符类型（char）用于存储单个字符，占用 16 位（两个字节）的内存空间。在定义字符型变量时，要以单引号表示，如 &#39;s&#39; 表示一个字符，而 &quot;s&quot;则表示一个字符串。 使用 char 关键字可定义字符变量，下面举例说明。 1234char x = 'a';注意：字符 a 在 unicode 表中的排序位置是 97 ，所以上面的语句等同于：char x = 97; 同 c 和 C++ 语言一样，Java 语言也可以把字符作为整数对待。由于unicode 编码采用无符号编码，可以存储 65536 个字符（0x0000 ～ 0xffff），所以 Java 中的字符几乎可以处理所有国家的语言文字。 在控制台输出 unicode 表中的字符以及在表中字符对应的位置 12345678910111213141516public class gess &#123; public static void main(String[] args) &#123; char word = 'd', word2 = '@'; int p = 23045, p2 = 45213; System.out.println(\"d 在 unicode 表中的顺序位置是：\"+(int)word); System.out.println(\"@ 在 unicode 表中的顺序位置是：\"+(int)word2); System.out.println(\"unicode 表中的第 23045 位是：\"+(char)p); System.out.println(\"unicode 表中的第 45213 位是：\"+(char)p2); &#125;&#125;输出结果为：d 在 unicode 表中的顺序位置是：100@ 在 unicode 表中的顺序位置是：64unicode 表中的第 23045 位是：娅unicode 表中的第 45213 位是： ? 转义字符转义字符是一种特殊的字符变量，它以反斜杠 &quot;\\&quot; 开头，后跟一个或多个字符。转义字符具有特殊的含义，不同于字符原有的意义，故称 “转义”。Java 中的转义字符如下表所示： 转义字符 含义 \\ddd 1～3位八进制数所表示的字符，如\\123 \\uxxxx 4 位十六进制数所表示的字符，如 \\u0052 \\’ 单引号字符 \\ 反斜杠字符 \\t 垂直制表符，将光标移动下一个制表符的位置 \\r 回车 \\n 换行 \\b 退格 \\f 换页 将转义字符赋值给字符变量时，与字符常量值一样需要使用单引号。 1234char c1 = '\\\\';char char1 = \"\\u2605\";System.out.println(c1);System.out.println(char1); 布尔类型布尔类型又称逻辑类型，通过关键值 boolean 来定义布尔类型变量。只有 true 和 false 两个值，它们分别代表布尔逻辑中的 真 和 假。 布尔类型不能与整数类型进行转换。布尔类型通常被用在流程控制中作为判断条件。 123boolean b;boolean b1,b2;boolean b = true;","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-编程大题","date":"2018-10-20T10:15:48.000Z","path":"2018/10/20/Java-面试题系列篇-编程大题/","text":"Java 编程题如何读取eclipse中 src目录下的文件？至少两种http://note.youdao.com/noteshare?id=f60ff6c6169c0f5211410a8ff3350000&amp;sub=8CA55EE3DA474C98A6C33F1988387FC6 有两个list 集合怎么取无重复并集？如何将系统时间转化为 2017/5/28 格式？http://note.youdao.com/noteshare?id=b634c901a7b2739d3d9c439c57ce99b8&amp;sub=34424049F77F421E9249AE3622E4A8DE 页面二级级联菜单如何实现？如 第一个下拉列表为省，第二个下拉列表为市。请简述如何模拟实现 IOC 和 DI？ 代码或者具体细节步骤？","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-虚拟机","date":"2018-10-20T10:15:37.000Z","path":"2018/10/20/Java-面试题系列篇-虚拟机/","text":"虚拟机 （JVM）【JVM】你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？https://blog.csdn.net/chenleixing/article/details/46706039/ 【JVM】Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机制是什么意思？有什么好处？启动Bootstrap类加载、扩展Extension类加载、系统System类加载。 父子关系如下： 启动类加载器 ，由C++ 实现，没有父类； 扩展类加载器，由Java语言实现，父类加载器为null； 系统类加载器，由Java语言实现，父类加载器为扩展类加载器； 自定义类加载器，父类加载器肯定为AppClassLoader。 双亲委派机制：类加载器收到类加载请求，自己不加载，向上委托给父类加载，父类加载不了，再自己加载。 优势避免Java核心API篡改。 https://blog.csdn.net/javazejian/article/details/73413292/ 【JVM】如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？自定义类加载的意义： 加载特定路径的class文件 加载一个加密的网络class文件 热部署加载class文件 【JVM】jstack 是⼲什么的? jstat 呢？如果线上程序周期性地出现卡顿，你怀疑可 能是 GC 导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么 部分？jstack 用来查询 Java 进程的堆栈信息。 jvisualvm 监控内存泄露，跟踪垃圾回收、执行时内存、cpu分析、线程分析。 详见Java jvisualvm简要说明，可参考 线上FullGC频繁的排查。 Java jvisualvm简要说明 https://blog.csdn.net/a19881029/article/details/8432368/ 线上FullGC频繁的排查 https://blog.csdn.net/wilsonpeng3/article/details/70064336/ 【JVM】StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？栈内存溢出，一般由栈内存的局部变量过爆了，导致内存溢出。出现在递归方法，参数个数过多，递归过深，递归没有出口。 什么是垃圾回收？垃圾回收是Java中自动内存管理的另一种叫法。垃圾回收的目的是为程序保持尽可能多的可用堆（heap）。 JVM会删除堆上不再需要从堆引用的对象。 用一个例子解释垃圾回收？比方说，下面这个方法就会从函数调用。 void method(){ ​ Calendar calendar = new GregorianCalendar(2000,10,30); ​ System.out.println(calendar); } 通过函数第一行代码中参考变量calendar，在堆上创建了GregorianCalendar类的一个对象。 函数结束执行后，引用变量calendar不再有效。因此，在方法中没有创建引用到对象。 JVM认识到这一点，会从堆中删除对象。这就是所谓的垃圾回收。 什么时候运行垃圾回收？垃圾回收在JVM突发奇想和心血来潮时运行（没有那么糟糕）。运行垃圾收集的可能情况是： 堆可用内存不足 CPU空闲 垃圾回收的最佳做法？用编程的方式，我们可以要求（记住这只是一个请求——不是一个命令）JVM通过调用System.gc()方法来运行垃圾回收。 当内存已满，且堆上没有对象可用于垃圾回收时，JVM可能会抛出OutOfMemoryException。 对象在被垃圾回收从堆上删除之前，会运行finalize()方法。我们建议不要用finalize()方法写任何代码。 Java 中会存在内存泄漏吗，请简单描述。答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 import java.util.Arrays; import java.util.EmptyStackException; public class MyStack { ​ private T[] elements; ​ private int size = 0; ​ private static final int INIT_CAPACITY = 16; ​ public MyStack() { ​ elements = (T[]) new Object[INIT_CAPACITY]; ​ } ​ public void push(T elem) { ​ ensureCapacity(); ​ elements[size++] = elem; ​ } ​ public T pop() { ​ if(size == 0) ​ throw new EmptyStackException(); ​ return elements[–size]; ​ } ​ private void ensureCapacity() { ​ if(elements.length == size) { ​ elements = Arrays.copyOf(elements, 2 * size + 1); ​ } ​ } } 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 GC是什么？为什么要有GC？答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的JVM参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让System.gc()不产生任何作用 -XX:+PrintGCDetails — 打印GC的细节 -XX:+PrintGCDateStamps — 打印GC操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-SpringMVC 框架","date":"2018-10-20T10:15:02.000Z","path":"2018/10/20/Java-面试题系列篇-SpringMVC-框架/","text":"SpringMVC 框架如何在Web项目中配置Spring MVC？答：要使用Spring MVC需要在Web项目配置文件中配置其前端控制器DispatcherServlet，如下所示： ​ ​ example ​ ​ org.springframework.web.servlet.DispatcherServlet ​ ​ 1 ​ ​ ​ example ​ *.html ​ 说明：上面的配置中使用了*.html的后缀映射，这样做一方面不能够通过URL推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。 Spring MVC的工作原理是怎样的？答：Spring MVC的工作原理如下图所示：① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 大型网站在架构上应当考虑哪些问题？答： 分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。 分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。 分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。 集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。 缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。 异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。”；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。 冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 你用过的网站前端优化的技术有哪些？答：① 浏览器访问优化： 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 启用压缩 CSS前置，JavaScript后置 减少Cookie传输② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。 你使用过的应用服务器优化技术有哪些？答：① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题： 频繁修改的数据； 数据不一致与脏读； 缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）； 缓存预热； 缓存穿透（恶意持续请求不存在的数据）。② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。③ 使用集群。④ 代码优化： 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？ 答： XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。 补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。 贫血模型 充血模型 贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点： 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文《贫血领域模型是如何导致糟糕的软件产生》对这个问题做了比较细致的阐述。 谈一谈测试驱动开发（TDD）的好处以及你的理解。答：TDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括： 更清晰的代码 — 只写需要的代码 更好的设计 更出色的灵活性 — 鼓励程序员面向接口编程 更快速的反馈 — 不会到系统上线时才知道bug的存在 补充：敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。 TDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。关于实施TDD的详细步骤请参考另一篇文章《测试驱动开发之初窥门径》。在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类： 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多） 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应Java世界中实现模拟替身的第三方工具非常多，包括EasyMock、Mockito、jMock等。 什么是可变参数？可变参数允许调用参数数量不同的方法。请看下面例子中的求和方法。此方法可以调用1个int参数，或2个int参数，或多个int参数。 //int(type) followed … (three dot’s) is syntax of a variable argument. ​ public int sum(int… numbers) { ​ //inside the method a variable argument is similar to an array. ​ //number can be treated as if it is declared as int[] numbers; ​ int sum = 0; ​ for (int number: numbers) { ​ sum += number; ​ } ​ return sum; ​ } ​ public static void main(String[] args) { ​ VariableArgumentExamples example = new VariableArgumentExamples(); ​ //3 Arguments ​ System.out.println(example.sum(1, 4, 5));//10 ​ //4 Arguments ​ System.out.println(example.sum(1, 4, 5, 20));//30 ​ //0 Arguments ​ System.out.println(example.sum());//0 } 断言的用途？断言是在Java 1.4中引入的。它能让你验证假设。如果断言失败（即返回false），就会抛出AssertionError（如果启用断言）。基本断言如下所示。 private int computerSimpleInterest(int principal,float interest,int years){ ​ assert(principal&gt;0); ​ return 100; } 什么时候使用断言？断言不应该用于验证输入数据到一个public方法或命令行参数。IllegalArgumentException会是一个更好的选择。在public方法中，只用断言来检查它们根本不应该发生的情况。 什么是初始化数据块？初始化数据块——当创建对象或加载类时运行的代码。 有两种类型的初始化数据块： 静态初始化器：加载类时运行的的代码 实例初始化器：创建新对象时运行的代码 什么是静态初始化器？请看下面的例子：static{ 和 }之间的代码被称为静态初始化器。它只有在第一次加载类时运行。只有静态变量才可以在静态初始化器中进行访问。虽然创建了三个实例，但静态初始化器只运行一次。 /** Java学习交流QQ群：589809992 我们一起学Java！ */ public class InitializerExamples { ​ static int count; ​ int i; ​ static{ ​ //This is a static initializers. Run only when Class is first loaded. ​ //Only static variables can be accessed ​ System.out.println(“Static Initializer”); ​ //i = 6;//COMPILER ERROR ​ System.out.println(“Count when Static Initializer is run is “ + count); ​ } ​ public static void main(String[] args) { ​ InitializerExamples example = new InitializerExamples(); ​ InitializerExamples example2 = new InitializerExamples(); ​ InitializerExamples example3 = new InitializerExamples(); ​ } } 示例输出 Static Initializer Count when Static Initializer is run is 0. 什么是实例初始化块？让我们来看一个例子：每次创建类的实例时，实例初始化器中的代码都会运行。 /** Java学习交流QQ群：589809992 我们一起学Java！ */ public class InitializerExamples { ​ static int count; ​ int i; ​ { ​ //This is an instance initializers. Run every time an object is created. ​ //static and instance variables can be accessed ​ System.out.println(“Instance Initializer”); ​ i = 6; ​ count = count + 1; ​ System.out.println(“Count when Instance Initializer is run is “ + count); ​ } ​ public static void main(String[] args) { ​ InitializerExamples example = new InitializerExamples(); ​ InitializerExamples example1 = new InitializerExamples(); ​ InitializerExamples example2 = new InitializerExamples(); ​ } } 示例输出 Instance Initializer ​ Count when Instance Initializer is run is 1 ​ Instance Initializer ​ Count when Instance Initializer is run is 2 ​ Instance Initializer ​ Count when Instance Initializer is run is 3 什么是正则表达式？正则表达式能让解析、扫描和分割字符串变得非常容易。Java中常用的正则表达式——Patter，Matcher和Scanner类。 什么是令牌化？令牌化是指在分隔符的基础上将一个字符串分割为若干个子字符串。例如，分隔符；分割字符串ac;bd;def;e为四个子字符串ac，bd，def和e。 分隔符自身也可以是一个常见正则表达式。 String.split(regex)函数将regex作为参数。 给出令牌化的例子？private static void tokenize(String string,String regex) { ​ String[] tokens = string.split(regex); ​ System.out.println(Arrays.toString(tokens)); } tokenize(“ac;bd;def;e”,”;”);//[ac, bd, def, e] 如何使用扫描器类（Scanner Class）令牌化？private static void tokenizeUsingScanner(String string,String regex) { ​ Scanner scanner = new Scanner(string); ​ scanner.useDelimiter(regex); ​ List matches = new ArrayList(); ​ while(scanner.hasNext()){ ​ matches.add(scanner.next()); ​ } ​ System.out.println(matches); } tokenizeUsingScanner(“ac;bd;def;e”,”;”);//[ac, bd, def, e] 如何添加小时(hour)到一个日期对象（Date Objects）？现在，让我们如何看看添加小时到一个date对象。所有在date上的日期操作都需要通过添加毫秒到date才能完成。例如，如果我们想增加6个小时，那么我们需要将6小时换算成毫秒。6小时= 6 60 60 * 1000毫秒。请看以下的例子。 Date date = new Date(); //Increase time by 6 hrs date.setTime(date.getTime() + 6 60 60 * 1000); System.out.println(date); //Decrease time by 6 hrs date = new Date(); date.setTime(date.getTime() - 6 60 60 * 1000); System.out.println(date); 如何格式化日期对象？格式化日期需要使用DateFormat类完成。让我们看几个例子。 //Formatting Dates System.out.println(DateFormat.getInstance().format( ​ date));//10/16/12 5:18 AM 带有区域设置的格式化日期如下所示： System.out.println(DateFormat.getDateInstance( ​ DateFormat.FULL, new Locale(“it”, “IT”)) ​ .format(date));//marted“ 16 ottobre 2012 System.out.println(DateFormat.getDateInstance( ​ DateFormat.FULL, Locale.ITALIAN) ​ .format(date));//marted“ 16 ottobre 2012 //This uses default locale US System.out.println(DateFormat.getDateInstance( ​ DateFormat.FULL).format(date));//Tuesday, October 16, 2012 System.out.println(DateFormat.getDateInstance() ​ .format(date));//Oct 16, 2012 System.out.println(DateFormat.getDateInstance( ​ DateFormat.SHORT).format(date));//10/16/12 System.out.println(DateFormat.getDateInstance( ​ DateFormat.MEDIUM).format(date));//Oct 16, 2012 System.out.println(DateFormat.getDateInstance( ​ DateFormat.LONG).format(date));//October 16, 2012 Java中日历类（Calendar Class）的用途？Calendar类在Java中用于处理日期。Calendar类提供了增加和减少天数、月数和年数的简便方法。它还提供了很多与日期有关的细节（这一年的哪一天？哪一周？等等） 如何在Java中获取日历类（Calendar Class）的实例？Calendar类不能通过使用new Calendar创建。得到Calendar类实例的最好办法是在Calendar中使用getInstance() static方法。 //Calendar calendar = new Calendar(); //COMPILER ERROR Calendar calendar = Calendar.getInstance(); 解释一些日历类（Calendar Class）中的重要方法？在Calendar对象上设置日（day），月（month）或年（year）不难。对Day，Month或Year调用恰当Constant的set方法。下一个参数就是值。 calendar.set(Calendar.DATE, 24); calendar.set(Calendar.MONTH, 8);//8 - September calendar.set(Calendar.YEAR, 2010); calendar get方法 要获取一个特定日期的信息——2010年9月24日。我们可以使用calendar get方法。已被传递的参数表示我们希望从calendar中获得的值—— 天或月或年或……你可以从calendar获取的值举例如下： System.out.println(calendar.get(Calendar.YEAR));//2010 System.out.println(calendar.get(Calendar.MONTH));//8 System.out.println(calendar.get(Calendar.DATE));//24 System.out.println(calendar.get(Calendar.WEEK_OF_MONTH));//4 System.out.println(calendar.get(Calendar.WEEK_OF_YEAR));//39 System.out.println(calendar.get(Calendar.DAY_OF_YEAR));//267 System.out.println(calendar.getFirstDayOfWeek());//1 -&gt; Calendar.SUNDAY 数字格式化类（Number Format Class）的用途？数字格式用于格式化数字到不同的区域和不同格式中。 使用默认语言环境的数字格式 System.out.println(NumberFormat.getInstance().format(321.24f));//321.24 使用区域设置的数字格式 使用荷兰语言环境格式化数字： System.out.println(NumberFormat.getInstance(new Locale(“nl”)).format(4032.3f));//4.032,3 使用德国语言环境格式化数字： System.out.println(NumberFormat.getInstance(Locale.GERMANY).format(4032.3f));//4.032,3 使用默认语言环境格式化货币 System.out.println(NumberFormat.getCurrencyInstance().format(40324.31f));//$40,324.31 使用区域设置格式化货币 使用荷兰语言环境格式化货币： System.out.println(NumberFormat.getCurrencyInstance(new Locale(“nl”)).format(40324.31f));/ 后台从前端页面获取到表单数据的方法？请具体到细节，如Servlet如何接收？SpringMVC怎么接收或Structs2？Spring 中 IOC 和 DI 的区别以及关系是什么、AOP是怎么实现的？","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-struts 框架","date":"2018-10-20T10:14:47.000Z","path":"2018/10/20/Java-面试题系列篇-Struts-框架/","text":"Struts 框架Struts2 中action 是多实例还是单实例的？为什么？Struts2 中的拦截器如何配置？SSH 框架或 SSM 框架整合思想是什么？关键 jar 包是哪几个？请具体阐述 jar 包的作用？页面数据分页如何实现？","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-Spring 框架","date":"2018-10-20T10:14:37.000Z","path":"2018/10/20/Java-面试题系列篇-Spring-框架/","text":"Spring 框架【Spring】使用Spring框架的好处是什么？轻量：Spring 是轻量的，基本的版本大约2MB 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开 容器：Spring 包含并管理应用中对象的生命周期和配置 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA） 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常 什么是IoC和DI？DI是如何实现的？答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。 举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。 Spring中Bean的作用域有哪些？答：在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。 补充：设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。 Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。 说明：单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。 ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。 ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法： void set(T value)：设置当前线程的线程局部变量的值。 T get()：获得当前线程所对应的线程局部变量的值。 void remove()：删除当前线程中线程局部变量的值。 ThreadLocal是如何做到为每一个线程维护一份独立的变量副本的呢？在ThreadLocal类中有一个Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个ThreadLocal类其实并不困难，代码如下所示： import java.util.Collections; import java.util.HashMap; import java.util.Map; public class MyThreadLocal { ​ private Map&lt;Thread, T&gt; map = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;()); ​ public void set(T newValue) { ​ map.put(Thread.currentThread(), newValue); ​ } ​ public T get() { ​ return map.get(Thread.currentThread()); ​ } ​ public void remove() { ​ map.remove(Thread.currentThread()); ​ } } 解释一下什么叫AOP（面向切面编程）？答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。 你是如何理解”横切关注”这个概念的？答：”横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？答：a. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。b. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。c. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。 说明： Advice在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。 d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。f. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。 补充：代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。 下面用一个找枪手代考的例子演示代理模式的使用： /** 参考人员接口 @author 骆昊 * */ public interface Candidate { ​ /** ​ * 答题 ​ */ ​ public void answerTheQuestions(); } /** 懒学生 @author 骆昊 * */ public class LazyStudent implements Candidate { ​ private String name; // 姓名 ​ public LazyStudent(String name) { ​ this.name = name; ​ } ​ @Override ​ public void answerTheQuestions() { ​ // 懒学生只能写出自己的名字不会答题 ​ System.out.println(“姓名: “ + name); ​ } } /** 枪手 @author 骆昊 * */ public class Gunman implements Candidate { ​ private Candidate target; // 被代理对象 ​ public Gunman(Candidate target) { ​ this.target = target; ​ } ​ @Override ​ public void answerTheQuestions() { ​ // 枪手要写上代考的学生的姓名 ​ target.answerTheQuestions(); ​ // 枪手要帮助懒学生答题并交卷 ​ System.out.println(“奋笔疾书正确答案”); ​ System.out.println(“交卷”); ​ } } public class ProxyTest1 { ​ public static void main(String[] args) { ​ Candidate c = new Gunman(new LazyStudent(“王小二”)); ​ c.answerTheQuestions(); ​ } } 说明：从JDK 1.3开始，Java提供了动态代理技术，允许开发者在运行时创建接口的代理实例，主要包括Proxy类和InvocationHandler接口。下面的例子使用动态代理为ArrayList编写一个代理，在添加和删除元素时，在控制台打印添加或删除的元素以及ArrayList的大小： import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.List; public class ListProxy implements InvocationHandler { ​ private List target; ​ public ListProxy(List target) { ​ this.target = target; ​ } ​ @Override ​ public Object invoke(Object proxy, Method method, Object[] args) ​ throws Throwable { ​ Object retVal = null; ​ System.out.println(“[“ + method.getName() + “: “ + args[0] + “]”); ​ retVal = method.invoke(target, args); ​ System.out.println(“[size=” + target.size() + “]”); ​ return retVal; ​ } } import java.lang.reflect.Proxy; import java.util.ArrayList; import java.util.List; public class ProxyTest2 { ​ @SuppressWarnings(“unchecked”) ​ public static void main(String[] args) { ​ List list = new ArrayList(); ​ Class&lt;?&gt; clazz = list.getClass(); ​ ListProxy myProxy = new ListProxy(list); ​ List newList = (List) ​ Proxy.newProxyInstance(clazz.getClassLoader(), ​ clazz.getInterfaces(), myProxy); ​ newList.add(“apple”); ​ newList.add(“banana”); ​ newList.add(“orange”); ​ newList.remove(“banana”); ​ } } 说明：使用Java的动态代理有一个局限性就是代理的类必须要实现接口，虽然面向接口编程是每个优秀的Java程序都知道的规则，但现实往往不尽如人意，对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段，虽然继承常常被初学者滥用，但继承也常常被进阶的程序员忽视。CGLib采用非常底层的字节码生成技术，通过为一个类创建子类来生成代理，它弥补了Java动态代理的不足，因此Spring中动态代理和CGLib都是创建代理的重要手段，对于实现了接口的类就用动态代理为其生成代理类，而没有实现接口的类就用CGLib通过继承的方式为其创建代理。 Spring中自动装配的方式有哪些？ 答： no：不进行自动装配，手动设置Bean的依赖关系。 byName：根据Bean的名字进行自动装配。 byType：根据Bean的类型进行自动装配。 constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。 说明：自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。 Spring中如何使用注解来配置Bean？有哪些相关的注解？答：首先需要在Spring配置文件中增加如下配置： &lt;context:component-scan base-package=”org.example”/&gt; 然后可以用@Component、@Controller、@Service、@Repository注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过@Controller通常用于控制器，@Service通常用于业务逻辑类，@Repository通常用于仓储类（例如我们的DAO实现类），普通的类用@Component来标注。 Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？答：Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。 事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。 Spring提供了如下所示的事务管理器。 事务管理器实现类 目标对象 DataSourceTransactionManager 注入DataSource HibernateTransactionManager 注入SessionFactory JdoTransactionManager 管理JDO事务 JtaTransactionManager 使用JTA管理事务 PersistenceBrokerTransactionManager 管理Apache的OJB事务 这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。 编程式事务管理如下所示。 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; ​ &lt;context:component-scan base-package=”com.jackfrued”/&gt;​ ​ ​ jdbc.properties​ ​ ​ ​ ​ ${db.driver}​ ​ ​ ${db.url}​ ​ ​ ${db.username}​ ​ ​ ${db.password}​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ package com.jackfrued.dao.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import com.jackfrued.dao.EmpDao; import com.jackfrued.entity.Emp; @Repository public class EmpDaoImpl implements EmpDao { ​ @Autowired ​ private JdbcTemplate jdbcTemplate; ​ @Override ​ public boolean save(Emp emp) { ​ String sql = “insert into emp values (?,?,?)”; ​ return jdbcTemplate.update(sql, emp.getId(), emp.getName(), emp.getBirthday()) == 1; ​ } } package com.jackfrued.biz.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.TransactionCallbackWithoutResult; import org.springframework.transaction.support.TransactionTemplate; import com.jackfrued.biz.EmpService; import com.jackfrued.dao.EmpDao; import com.jackfrued.entity.Emp; @Service public class EmpServiceImpl implements EmpService { ​ @Autowired ​ private TransactionTemplate txTemplate; ​ @Autowired ​ private EmpDao empDao; ​ @Override ​ public void addEmp(final Emp emp) { ​ txTemplate.execute(new TransactionCallbackWithoutResult() { ​ @Override ​ protected void doInTransactionWithoutResult(TransactionStatus txStatus) { ​ empDao.save(emp); ​ } ​ }); ​ } } 声明式事务如下图所示，以Spring整合Hibernate 3为例，包括完整的DAO和业务逻辑代码。 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; ​ ​ &lt;context:component-scan base-package=”com.jackfrued” /&gt;​ ​ &lt;aop:aspectj-autoproxy /&gt;​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ hibernate.dialect=org.hibernate.dialect.MySQL5Dialect​ ​ ​ ​ ​ ​ ​ ​ ​ ​ &lt;tx:annotation-driven /&gt; package com.jackfrued.dao; import java.io.Serializable; import java.util.List; import com.jackfrued.comm.QueryBean; import com.jackfrued.comm.QueryResult; /** 数据访问对象接口(以对象为单位封装CRUD操作) @author 骆昊 * @param 实体类型 @param 实体标识字段的类型 */ public interface BaseDao &lt;E, K extends Serializable&gt; { ​ /** ​ * 新增 ​ * @param entity 业务实体对象 ​ * @return 增加成功返回实体对象的标识 ​ */ ​ public K save(E entity); ​ /** ​ * 删除 ​ * @param entity 业务实体对象 ​ */ ​ public void delete(E entity); ​ /** ​ * 根据ID删除 ​ * @param id 业务实体对象的标识 ​ * @return 删除成功返回true否则返回false ​ */ ​ public boolean deleteById(K id); ​ /** ​ * 修改 ​ * @param entity 业务实体对象 ​ * @return 修改成功返回true否则返回false ​ */ ​ public void update(E entity); ​ /** ​ * 根据ID查找业务实体对象 ​ * @param id 业务实体对象的标识 ​ * @return 业务实体对象对象或null ​ */ ​ public E findById(K id); ​ /** ​ * 根据ID查找业务实体对象 ​ * @param id 业务实体对象的标识 ​ * @param lazy 是否使用延迟加载 ​ * @return 业务实体对象对象 ​ */ ​ public E findById(K id, boolean lazy); ​ /** ​ * 查找所有业务实体对象 ​ * @return 装所有业务实体对象的列表容器 ​ */ ​ public List findAll(); ​ /** ​ * 分页查找业务实体对象 ​ * @param page 页码 ​ * @param size 页面大小 ​ * @return 查询结果对象 ​ */ ​ public QueryResult findByPage(int page, int size); ​ /** ​ * 分页查找业务实体对象 ​ * @param queryBean 查询条件对象 ​ * @param page 页码 ​ * @param size 页面大小 ​ * @return 查询结果对象 ​ */ ​ public QueryResult findByPage(QueryBean queryBean, int page, int size); } package com.jackfrued.dao; import java.io.Serializable; import java.util.List; import com.jackfrued.comm.QueryBean; import com.jackfrued.comm.QueryResult; /** BaseDao的缺省适配器 @author 骆昊 * @param 实体类型 @param 实体标识字段的类型 */ public abstract class BaseDaoAdapter&lt;E, K extends Serializable&gt; implements ​ BaseDao&lt;E, K&gt; { ​ @Override ​ public K save(E entity) { ​ return null; ​ } ​ @Override ​ public void delete(E entity) { ​ } ​ @Override ​ public boolean deleteById(K id) { ​ E entity = findById(id); ​ if(entity != null) { ​ delete(entity); ​ return true; ​ } ​ return false; ​ } ​ @Override ​ public void update(E entity) { ​ } ​ @Override ​ public E findById(K id) { ​ return null; ​ } ​ @Override ​ public E findById(K id, boolean lazy) { ​ return null; ​ } ​ @Override ​ public List findAll() { ​ return null; ​ } ​ @Override ​ public QueryResult findByPage(int page, int size) { ​ return null; ​ } ​ @Override ​ public QueryResult findByPage(QueryBean queryBean, int page, int size) { ​ return null; ​ } } package com.jackfrued.dao; import java.io.Serializable; import java.lang.reflect.ParameterizedType; import java.util.ArrayList; import java.util.Collections; import java.util.List; import org.hibernate.Query; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.springframework.beans.factory.annotation.Autowired; import com.jackfrued.comm.HQLQueryBean; import com.jackfrued.comm.QueryBean; import com.jackfrued.comm.QueryResult; /** 基于Hibernate的BaseDao实现类 @author 骆昊 * @param 实体类型 @param 主键类型 */ @SuppressWarnings(value = {“unchecked”}) public abstract class BaseDaoHibernateImpl&lt;E, K extends Serializable&gt; extends BaseDaoAdapter&lt;E, K&gt; { ​ @Autowired ​ protected SessionFactory sessionFactory; ​ private Class&lt;?&gt; entityClass; // 业务实体的类对象 ​ private String entityName; // 业务实体的名字 ​ public BaseDaoHibernateImpl() { ​ ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass(); ​ entityClass = (Class&lt;?&gt;) pt.getActualTypeArguments()[0]; ​ entityName = entityClass.getSimpleName(); ​ } ​ @Override ​ public K save(E entity) { ​ return (K) sessionFactory.getCurrentSession().save(entity); ​ } ​ @Override ​ public void delete(E entity) { ​ sessionFactory.getCurrentSession().delete(entity); ​ } ​ @Override ​ public void update(E entity) { ​ sessionFactory.getCurrentSession().update(entity); ​ } ​ @Override ​ public E findById(K id) { ​ return findById(id, false); ​ } ​ @Override ​ public E findById(K id, boolean lazy) { ​ Session session = sessionFactory.getCurrentSession(); ​ return (E) (lazy? session.load(entityClass, id) : session.get(entityClass, id)); ​ } ​ @Override ​ public List findAll() { ​ return sessionFactory.getCurrentSession().createCriteria(entityClass).list(); ​ } ​ @Override ​ public QueryResult findByPage(int page, int size) { ​ return new QueryResult( ​ findByHQLAndPage(“from “ + entityName , page, size), ​ getCountByHQL(“select count(*) from “ + entityName) ​ ); ​ } ​ @Override ​ public QueryResult findByPage(QueryBean queryBean, int page, int size) { ​ if(queryBean instanceof HQLQueryBean) { ​ HQLQueryBean hqlQueryBean = (HQLQueryBean) queryBean; ​ return new QueryResult( ​ findByHQLAndPage(hqlQueryBean.getQueryString(), page, size, hqlQueryBean.getParameters()), ​ getCountByHQL(hqlQueryBean.getCountString(), hqlQueryBean.getParameters()) ​ ); ​ } ​ return null; ​ } ​ /** ​ * 根据HQL和可变参数列表进行查询 ​ * @param hql 基于HQL的查询语句 ​ * @param params 可变参数列表 ​ * @return 持有查询结果的列表容器或空列表容器 ​ */ ​ protected List findByHQL(String hql, Object… params) { ​ return this.findByHQL(hql, getParamList(params)); ​ } ​ /** ​ * 根据HQL和参数列表进行查询 ​ * @param hql 基于HQL的查询语句 ​ * @param params 查询参数列表 ​ * @return 持有查询结果的列表容器或空列表容器 ​ */ ​ protected List findByHQL(String hql, List params) { ​ List list = createQuery(hql, params).list(); ​ return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST; ​ } ​ /** ​ * 根据HQL和参数列表进行分页查询 ​ * @param hql 基于HQL的查询语句 ​ * @page 页码 ​ * @size 页面大小 ​ * @param params 可变参数列表 ​ * @return 持有查询结果的列表容器或空列表容器 ​ */ ​ protected List findByHQLAndPage(String hql, int page, int size, Object… params) { ​ return this.findByHQLAndPage(hql, page, size, getParamList(params)); ​ } ​ /** ​ * 根据HQL和参数列表进行分页查询 ​ * @param hql 基于HQL的查询语句 ​ * @page 页码 ​ * @size 页面大小 ​ * @param params 查询参数列表 ​ * @return 持有查询结果的列表容器或空列表容器 ​ */ ​ protected List findByHQLAndPage(String hql, int page, int size, List params) { ​ List list = createQuery(hql, params) ​ .setFirstResult((page - 1) * size) ​ .setMaxResults(size) ​ .list(); ​ return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST; ​ } ​ /** ​ * 查询满足条件的记录数 ​ * @param hql 基于HQL的查询语句 ​ * @param params 可变参数列表 ​ * @return 满足查询条件的总记录数 ​ */ ​ protected long getCountByHQL(String hql, Object… params) { ​ return this.getCountByHQL(hql, getParamList(params)); ​ } ​ /** ​ * 查询满足条件的记录数 ​ * @param hql 基于HQL的查询语句 ​ * @param params 参数列表容器 ​ * @return 满足查询条件的总记录数 ​ */ ​ protected long getCountByHQL(String hql, List params) { ​ return (Long) createQuery(hql, params).uniqueResult(); ​ } ​ // 创建Hibernate查询对象(Query) ​ private Query createQuery(String hql, List params) { ​ Query query = sessionFactory.getCurrentSession().createQuery(hql); ​ for(int i = 0; i &lt; params.size(); i++) { ​ query.setParameter(i, params.get(i)); ​ } ​ return query; ​ } ​ // 将可变参数列表组装成列表容器 ​ private List getParamList(Object… params) { ​ List paramList = new ArrayList&lt;&gt;(); ​ if(params != null) { ​ for(int i = 0; i &lt; params.length; i++) { ​ paramList.add(params[i]); ​ } ​ } ​ return paramList.size() == 0? Collections.EMPTY_LIST : paramList; ​ } } package com.jackfrued.comm; import java.util.List; /** 查询条件的接口 @author 骆昊 * */ public interface QueryBean { ​ /** ​ * 添加排序字段 ​ * @param fieldName 用于排序的字段 ​ * @param asc 升序还是降序 ​ * @return 查询条件对象自身(方便级联编程) ​ */ ​ public QueryBean addOrder(String fieldName, boolean asc); ​ /** ​ * 添加排序字段 ​ * @param available 是否添加此排序字段 ​ * @param fieldName 用于排序的字段 ​ * @param asc 升序还是降序 ​ * @return 查询条件对象自身(方便级联编程) ​ */ ​ public QueryBean addOrder(boolean available, String fieldName, boolean asc); ​ /** ​ * 添加查询条件 ​ * @param condition 条件 ​ * @param params 替换掉条件中参数占位符的参数 ​ * @return 查询条件对象自身(方便级联编程) ​ */ ​ public QueryBean addCondition(String condition, Object… params); ​ /** ​ * 添加查询条件 ​ * @param available 是否需要添加此条件 ​ * @param condition 条件 ​ * @param params 替换掉条件中参数占位符的参数 ​ * @return 查询条件对象自身(方便级联编程) ​ */ ​ public QueryBean addCondition(boolean available, String condition, Object… params); ​ /** ​ * 获得查询语句 ​ * @return 查询语句 ​ */ ​ public String getQueryString(); ​ /** ​ * 获取查询记录数的查询语句 ​ * @return 查询记录数的查询语句 ​ */ ​ public String getCountString(); ​ /** ​ * 获得查询参数 ​ * @return 查询参数的列表容器 ​ */ ​ public List getParameters(); } package com.jackfrued.comm; import java.util.List; /** 查询结果 @author 骆昊 * @param 泛型参数 */ public class QueryResult { ​ private List result; // 持有查询结果的列表容器 ​ private long totalRecords; // 查询到的总记录数 ​ /** ​ * 构造器 ​ */ ​ public QueryResult() { ​ } ​ /** ​ * 构造器 ​ * @param result 持有查询结果的列表容器 ​ * @param totalRecords 查询到的总记录数 ​ */ ​ public QueryResult(List result, long totalRecords) { ​ this.result = result; ​ this.totalRecords = totalRecords; ​ } ​ public List getResult() { ​ return result; ​ } ​ public void setResult(List result) { ​ this.result = result; ​ } ​ public long getTotalRecords() { ​ return totalRecords; ​ } ​ public void setTotalRecords(long totalRecords) { ​ this.totalRecords = totalRecords; ​ } } package com.jackfrued.dao; import com.jackfrued.comm.QueryResult; import com.jackfrued.entity.Dept; /** 部门数据访问对象接口 @author 骆昊 * */ public interface DeptDao extends BaseDao&lt;Dept, Integer&gt; { ​ /** ​ * 分页查询顶级部门 ​ * @param page 页码 ​ * @param size 页码大小 ​ * @return 查询结果对象 ​ */ ​ public QueryResult findTopDeptByPage(int page, int size); } package com.jackfrued.dao.impl; import java.util.List; import org.springframework.stereotype.Repository; import com.jackfrued.comm.QueryResult; import com.jackfrued.dao.BaseDaoHibernateImpl; import com.jackfrued.dao.DeptDao; import com.jackfrued.entity.Dept; @Repository public class DeptDaoImpl extends BaseDaoHibernateImpl&lt;Dept, Integer&gt; implements DeptDao { ​ private static final String HQL_FIND_TOP_DEPT = “ from Dept as d where d.superiorDept is null “; ​ @Override ​ public QueryResult findTopDeptByPage(int page, int size) { ​ List list = findByHQLAndPage(HQL_FIND_TOP_DEPT, page, size); ​ long totalRecords = getCountByHQL(“ select count(*) “ + HQL_FIND_TOP_DEPT); ​ return new QueryResult&lt;&gt;(list, totalRecords); ​ } } package com.jackfrued.comm; import java.util.List; /** 分页器 @author 骆昊 * @param 分页数据对象的类型 */ public class PageBean { ​ private static final int DEFAUL_INIT_PAGE = 1; ​ private static final int DEFAULT_PAGE_SIZE = 10; ​ private static final int DEFAULT_PAGE_COUNT = 5; ​ private List data; // 分页数据 ​ private PageRange pageRange; // 页码范围 ​ private int totalPage; // 总页数 ​ private int size; // 页面大小 ​ private int currentPage; // 当前页码 ​ private int pageCount; // 页码数量 ​ /** ​ * 构造器 ​ * @param currentPage 当前页码 ​ * @param size 页码大小 ​ * @param pageCount 页码数量 ​ */ ​ public PageBean(int currentPage, int size, int pageCount) { ​ this.currentPage = currentPage &gt; 0 ? currentPage : 1; ​ this.size = size &gt; 0 ? size : DEFAULT_PAGE_SIZE; ​ this.pageCount = pageCount &gt; 0 ? size : DEFAULT_PAGE_COUNT; ​ } ​ /** ​ * 构造器 ​ * @param currentPage 当前页码 ​ * @param size 页码大小 ​ */ ​ public PageBean(int currentPage, int size) { ​ this(currentPage, size, DEFAULT_PAGE_COUNT); ​ } ​ /** ​ * 构造器 ​ * @param currentPage 当前页码 ​ */ ​ public PageBean(int currentPage) { ​ this(currentPage, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT); ​ } ​ /** ​ * 构造器 ​ */ ​ public PageBean() { ​ this(DEFAUL_INIT_PAGE, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT); ​ } ​ public List getData() { ​ return data; ​ } ​ public int getStartPage() { ​ return pageRange != null ? pageRange.getStartPage() : 1; ​ } ​ public int getEndPage() { ​ return pageRange != null ? pageRange.getEndPage() : 1; ​ } ​ public long getTotalPage() { ​ return totalPage; ​ } ​ public int getSize() { ​ return size; ​ } ​ public int getCurrentPage() { ​ return currentPage; ​ } ​ /** ​ * 将查询结果转换为分页数据 ​ * @param queryResult 查询结果对象 ​ */ ​ public void transferQueryResult(QueryResult queryResult) { ​ long totalRecords = queryResult.getTotalRecords(); ​ data = queryResult.getResult(); ​ totalPage = (int) ((totalRecords + size - 1) / size); ​ totalPage = totalPage &gt;= 0 ? totalPage : Integer.MAX_VALUE; ​ this.pageRange = new PageRange(pageCount, currentPage, totalPage); ​ } } package com.jackfrued.comm; /** 页码范围 @author 骆昊 * */ public class PageRange { ​ private int startPage; // 起始页码 ​ private int endPage; // 终止页码 ​ /** ​ * 构造器 ​ * @param pageCount 总共显示几个页码 ​ * @param currentPage 当前页码 ​ * @param totalPage 总页数 ​ */ ​ public PageRange(int pageCount, int currentPage, int totalPage) { ​ startPage = currentPage - (pageCount - 1) / 2; ​ endPage = currentPage + pageCount / 2; ​ if(startPage &lt; 1) { ​ startPage = 1; ​ endPage = totalPage &gt; pageCount ? pageCount : totalPage; ​ } ​ if (endPage &gt; totalPage) { ​ endPage = totalPage; ​ startPage = (endPage - pageCount &gt; 0) ? endPage - pageCount + 1 : 1; ​ } ​ } ​ /** ​ * 获得起始页页码 ​ * @return 起始页页码 ​ */ ​ public int getStartPage() { ​ return startPage; ​ } ​ /** ​ * 获得终止页页码 ​ * @return 终止页页码 ​ */ ​ public int getEndPage() { ​ return endPage; ​ } } package com.jackfrued.biz; import com.jackfrued.comm.PageBean; import com.jackfrued.entity.Dept; /** 部门业务逻辑接口 @author 骆昊 * */ public interface DeptService { ​ /** ​ * 创建新的部门 ​ * @param department 部门对象 ​ * @return 创建成功返回true否则返回false ​ */ ​ public boolean createNewDepartment(Dept department); ​ /** ​ * 删除指定部门 ​ * @param id 要删除的部门的编号 ​ * @return 删除成功返回true否则返回false ​ */ ​ public boolean deleteDepartment(Integer id); ​ /** ​ * 分页获取顶级部门 ​ * @param page 页码 ​ * @param size 页码大小 ​ * @return 部门对象的分页器对象 ​ */ ​ public PageBean getTopDeptByPage(int page, int size); } package com.jackfrued.biz.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import com.jackfrued.biz.DeptService; import com.jackfrued.comm.PageBean; import com.jackfrued.comm.QueryResult; import com.jackfrued.dao.DeptDao; import com.jackfrued.entity.Dept; @Service @Transactional // 声明式事务的注解 public class DeptServiceImpl implements DeptService { ​ @Autowired ​ private DeptDao deptDao; ​ @Override ​ public boolean createNewDepartment(Dept department) { ​ return deptDao.save(department) != null; ​ } ​ @Override ​ public boolean deleteDepartment(Integer id) { ​ return deptDao.deleteById(id); ​ } ​ @Override ​ public PageBean getTopDeptByPage(int page, int size) { ​ QueryResult queryResult = deptDao.findTopDeptByPage(page, size); ​ PageBean pageBean = new PageBean&lt;&gt;(page, size); ​ pageBean.transferQueryResult(queryResult); ​ return pageBean; ​ } } 如何在Web项目中配置Spring的IoC容器？ 答：如果需要在Web项目中使用Spring的IoC容器，可以在Web项目配置文件web.xml中做出如下配置： ​ contextConfigLocation ​ classpath:applicationContext.xml ​ ​ org.springframework.web.context.ContextLoaderListener​ 如何在Spring IoC容器中配置数据源？答：DBCP配置： ​ ​ ​ ​ &lt;context:property-placeholder location=”jdbc.properties”/&gt; C3P0配置： ​ ​ ​ ​ &lt;context:property-placeholder location=”jdbc.properties”/&gt; 提示： DBCP的详细配置在第153题中已经完整的展示过了。 如何配置配置事务增强？答： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;tx:advice id=”txAdvice” transaction-manager=”txManager”&gt; tx:attributes​ ​ &lt;tx:method name=”get“ read-only=”true”/&gt;​ ​ &lt;tx:method name=”“/&gt; /tx:attributes /tx:advice aop:config &lt;aop:pointcut id=”fooServiceOperation”​ expression=”execution( x.y.service.FooService.(..))”/&gt; &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”fooServiceOperation”/&gt; /aop:config 选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？答：可以从以下几个方面作答： 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。 IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。 AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。 MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。 Spring IoC容器配置Bean的方式？答： 基于XML文件进行配置。 基于注解进行配置。 基于Java程序进行配置（Spring 3+） package com.jackfrued.bean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Person { ​ private String name; ​ private int age; ​ @Autowired ​ private Car car; ​ public Person(String name, int age) { ​ this.name = name; ​ this.age = age; ​ } ​ public void setCar(Car car) { ​ this.car = car; ​ } ​ @Override ​ public String toString() { ​ return “Person [name=” + name + “, age=” + age + “, car=” + car + “]”; ​ } } package com.jackfrued.bean; import org.springframework.stereotype.Component; @Component public class Car { ​ private String brand; ​ private int maxSpeed; ​ public Car(String brand, int maxSpeed) { ​ this.brand = brand; ​ this.maxSpeed = maxSpeed; ​ } ​ @Override ​ public String toString() { ​ return “Car [brand=” + brand + “, maxSpeed=” + maxSpeed + “]”; ​ } } package com.jackfrued.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.jackfrued.bean.Car; import com.jackfrued.bean.Person; @Configuration public class AppConfig { ​ @Bean ​ public Car car() { ​ return new Car(“Benz”, 320); ​ } ​ @Bean ​ public Person person() { ​ return new Person(“骆昊”, 34); ​ } } package com.jackfrued.test; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import com.jackfrued.bean.Person; import com.jackfrued.config.AppConfig; class Test { ​ public static void main(String[] args) { ​ // TWR (Java 7+) ​ try(ConfigurableApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class)) { ​ Person person = factory.getBean(Person.class); ​ System.out.println(person); ​ } ​ } } 阐述Spring框架中Bean的生命周期？答：① Spring IoC容器找到关于Bean的定义并实例化该Bean。② Spring IoC容器对Bean进行依赖注入。③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。 依赖注入时如何注入集合属性？答：可以在定义Bean属性时，通过 / / / 分别为其注入列表、集合、映射和键值都是字符串的映射属性。 Spring中的自动装配有哪些限制？ 答： 如果使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系。 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入。 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配。 在Web项目中如何获得Spring的IoC容器？答： WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext); Spring由哪些模块组成？以下是Spring 框架的基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 【Spring】什么是Spring IOC 容器？Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 【Spring】IOC的优点是什么？IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。 【Spring】ApplicationContext通常的实现是什么？FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。 【Spring】Bean 工厂和 Application contexts 有什么区别？Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。 【Spring】什么是Spring的依赖注入？依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 【Spring】有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 【Spring】哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 【Spring】什么是Spring beans？Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。 Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。 【Spring】一个 Spring Bean 定义 包含什么？一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。 【Spring】如何给Spring 容器提供配置元数据？这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。 【Spring】解释Spring支持的几种bean的作用域Spring框架支持以下五种bean的作用域： singleton : bean在每个Spring ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 缺省的Spring bean 的作用域是Singleton。 【Spring】Spring框架中的单例bean是线程安全的吗？不，Spring框架中的单例bean不是线程安全的。 【Spring】解释Spring框架中bean的生命周期Spring容器 从XML 文件中读取bean的定义，并实例化bean。 Spring根据bean的定义填充所有的属性。 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。 如果bean实现了 DisposableBean，它将调用destroy()方法。 【Spring】哪些是重要的bean生命周期方法？ 你能重载它们吗？有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。 The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。 【Spring】在 Spring中如何注入一个java集合？Spring提供以下几种集合的配置元素： 类型用于注入一列值，允许有相同的值。 类型用于注入一组值，不允许有相同的值。 类型用于注入一组键值对，键和值都可以为任意类型。 类型用于注入一组键值对，键和值都只能为String类型。 【Spring】什么是bean装配？装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。 【Spring】什么是bean的自动装配？Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。 【Spring】解释不同方式的自动装配有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入 no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。 byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。 【Spring】自动装配有哪些局限性？自动装配的局限性是： 重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。 基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。 模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。 【Spring】你可以在Spring中注入一个null 和一个空字符串吗？可以 【Spring】什么是基于Java的Spring注解配置? 给一些注解的例子基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。 以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。点击这里学习JAVA几大元注解。 【Spring】什么是基于注解的容器配置？相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。 开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。 【Spring】怎样开启注解装配？注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 context:annotation-config/元素。 【Spring】@Required 注解这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。 【Spring】@Autowired 注解@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。 【Spring】@Qualifier 注解当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。 【Spring】在Spring框架中如何更有效地使用JDBC？使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate （例子见这里here） 【Spring】 JdbcTemplateJdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。 【Spring】Spring对DAO的支持Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。 【Spring】使用Spring通过什么方式访问Hibernate？在Spring中有两种方式访问Hibernate： 控制反转 Hibernate Template和 Callback 继承 HibernateDAOSupport提供一个AOP 拦截器 【Spring】Spring支持的ORMSpring支持以下ORM： Hibernate iBatis JPA (Java Persistence API) TopLink JDO (Java Data Objects) OJB 【Spring】如何通过HibernateDaoSupport将Spring和Hibernate结合起来？用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步： 配置the Hibernate SessionFactory 继承HibernateDaoSupport实现一个DAO 在AOP支持的事务中装配 【Spring】Spring支持的事务管理类型Spring支持两种类型的事务管理： 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 【Spring】Spring框架的事务管理有哪些优点？它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。 它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如 它支持声明式事务管理。 它和Spring各种数据访问抽象层很好得集成。 【Spring】你更倾向用那种事务管理类型？大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。 【Spring】 解释AOP面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。 【Spring】Aspect 切面AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 【Spring】在Spring AOP 中，关注点和横切关注的区别是什么？关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 【Spring】连接点连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。 【Spring】通知通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。 Spring切面可以应用五种类型的通知： before：前置通知，在一个方法执行前被调用 after：在方法执行之后调用的通知，无论方法执行是否成功 after-returning：仅当方法成功完成后执行的通知 after-throwing：在方法抛出异常退出时执行的通知 around：在方法执行之前和之后调用的通知 【Spring】切点切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 【Spring】什么是引入？引入允许我们在已存在的类中增加新的方法和属性。 【Spring】什么是目标对象？被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。 【Spring】什么是代理？代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 【Spring】有几种不同类型的自动代理？BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying 【Spring】什么是织入。什么是织入应用的不同点？织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。 织入可以在编译时，加载时，或运行时完成。 【Spring】解释基于XML Schema方式的切面实现在这种情况下，切面由常规类以及基于XML的配置实现。 【Spring】解释基于注解的切面实现在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。 【Spring】什么是Spring的MVC框架？Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。 【Spring】DispatcherServletSpring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。 【Spring】WebApplicationContextWebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。 【Spring】什么是Spring MVC框架的控制器？控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。 【Spring】@Controller 注解该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。 【Spring】@RequestMapping 注解该注解是用来映射一个URL到一个类或一个特定的方处理法上。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-Mybatis 框架","date":"2018-10-20T10:14:27.000Z","path":"2018/10/20/Java-面试题系列篇-Mybatis-框架/","text":"Mybatis 框架【MyBatis】MyBatis中使用#和$书写占位符有什么区别？答：#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；将传入的数据直接显示生成在SQL中。注意：使用​占位符可能会导致SQL注射攻击，能用#的地方就不要使用，写order by子句的时候应该用​而不是#。 {}是预编译处理，${}是字符串替换。 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理{}时，就是把​{}替换成变量的值。 使用#{}可以有效的防止SQL注入，提高系统安全性。 【MyBatis】解释一下MyBatis中命名空间（namespace）的作用。答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。 【MyBatis】动态SQL是什么意思？答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： if choose / when / otherwise trim where set foreach 下面是映射文件的片段。 ​ ​ select * from t_blog where 1 = 1 ​ ​ and title = #{title} ​ ​ ​ and content = #{content} ​ ​ ​ and owner = #{owner} ​ 当然也可以像下面这些书写。 ​ ​ select * from t_blog where 1 = 1 ​ ​ ​ and title = #{title} ​ ​ ​ and content = #{content} ​ ​ ​ and owner = “owner1” ​ ​ ​ 再看看下面这个例子。 ​ ​ select * from t_blog where id in ​ &lt;foreach collection=”array” index=”index” ​ item=”item” open=”(“ separator=”,” close=”)”&gt; ​ #{item} ​ Mybatis当实体类中的属性名和表中的字段名不一样 ，怎么办 ？第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致 ​ ​ select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; 第2种： 通过来映射字段名和实体类属性名的一一对应的关系 ​ ​ select * from orders where order_id=#{id} ​ ​ &lt;!–用id属性来映射主键字段–&gt;​ ​ &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;​","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-Hibernate 框架","date":"2018-10-20T10:14:12.000Z","path":"2018/10/20/Java-面试题系列篇-Hibernate-框架/","text":"Hibernate 框架什么是ORM？答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ 答：所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。 持久层设计的目标包括： 数据存储逻辑的分离，提供抽象化的数据访问接口。 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 数据抽象，提供更面向对象的数据操作。 持久层框架有： Hibernate MyBatis TopLink Guzz jOOQ Spring Data ActiveJDBC Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？ 答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。 Hibernate中Session的load和get方法的区别是什么？答：主要有以下三项区别：① 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。② get方法直接返回实体类对象，load方法返回实体类对象的代理。③ 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。 说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。 Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？ 答：Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。 阐述Session加载实体对象的过程。答：Session加载实体对象的步骤是：① Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；② 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；③ 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；④ 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；⑤ 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象；⑥ 将对象纳入Session（一级缓存）的管理；⑦ 如果有对应的拦截器，则执行拦截器的onLoad方法；⑧ 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；⑨ 返回数据对象。 Query接口的list方法和iterate方法有什么区别？ 答：① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题 说明：关于N+1查询问题，可以参考CSDN上的一篇文章《什么是N+1查询》 Hibernate如何实现分页查询？答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。 锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在《Java面试题大全（上）》中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。 提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。 阐述实体对象的三种状态以及转换关系。 答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。 瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。 持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。 游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。 提示：关于这个问题，在Hibernate的官方文档中有更为详细的解读。 如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。 延迟加载与session关闭的矛盾一般可以这样处理：① 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。② 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。③ 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。 举一个多对多关联的例子，并说明如何实现多对多关联映射。 答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。 谈一下你对继承映射的理解。 答：继承关系的映射策略有三种：① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。 简述Hibernate常见优化策略。 答：这个问题应当挑自己使用过的优化策略回答，常用的有：① 制定合理的缓存策略（二级缓存、查询缓存）。② 采用合理的Session管理机制。③ 尽量使用延迟加载特性。④ 设定合理的批处理参数。⑤ 如果可以，选用UUID作为主键生成器。⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。⑦ 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。 谈一谈Hibernate的一级缓存、二级缓存和查询缓存。答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。 Hibernate中DetachedCriteria类是做什么的？答：DetachedCriteria和Criteria的用法基本上是一致的，但Criteria是由Session的createCriteria()方法创建的，也就意味着离开创建它的Session，Criteria就无法使用了。DetachedCriteria不需要Session就可以创建（使用DetachedCriteria.forClass()方法创建），所以通常也称其为离线的Criteria，在需要进行查询操作的时候再和Session绑定（调用其getExecutableCriteria(Session)方法），这也就意味着一个DetachedCriteria可以在需要的时候和不同的Session进行绑定。 @OneToMany注解的mappedBy属性有什么作用？答：@OneToMany用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用标签的inverse=”true”设置来达到同样的效果。 Hibernate 的缓存原理是什么？延迟加载原理是什么？","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-概念解释","date":"2018-10-20T10:14:01.000Z","path":"2018/10/20/Java-面试题系列篇-概念解释/","text":"概念解释解释一下网络应用的模式及其特点。答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。 补充：此题要跟”电子商务模式”区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去百度上面科普一下。 什么是Web Service（Web服务）？答：从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。 补充：这里必须要提及的一个概念是SOA（Service-Oriented Architecture，面向服务的架构），SOA是一种思想，它将应用程序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种形式的功能单元能够更好的集成。显然，Web Service是SOA的一种较好的解决方案，它更多的是一种标准，而不是一种具体的技术。 概念解释：SOAP、WSDL、UDDI。答： SOAP：简单对象访问协议（Simple Object Access Protocol），是Web Service中交换数据的一种协议规范。 WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。 UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。 提示：关于Web Service的相关概念和知识可以在W3CSchool上找到相关的资料。 Java规范中和Web Service相关的规范有哪些？答：Java规范中和Web Service相关的有三个： JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。 JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。 JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。 介绍一下你了解的Java领域的Web Service框架。答：Java领域的Web Service框架很多，包括Axis2（Axis的升级版本）、Jersey（RESTful的Web Service框架）、CXF（XFire的延续版本）、Hessian、Turmeric、JBoss SOA等，其中绝大多数都是开源框架。 提示：面试被问到这类问题的时候一定选择自己用过的最熟悉的作答，如果之前没有了解过就应该在面试前花一些时间了解其中的两个，并比较其优缺点，这样才能在面试时给出一个漂亮的答案。 JDK和JRE的区别是什么？Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-JSP和servlet","date":"2018-10-20T10:13:49.000Z","path":"2018/10/20/Java-面试题系列篇-JSP和servlet/","text":"JSP 和 Servlet什么是JSP页面？JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。 JSP请求是如何被处理的？浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。 JSP有哪些内置对象？作用分别是什么？答：JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 补充：如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。我们可以看一段JSP代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。 JSP页面： &lt;%@ page pageEncoding=”UTF-8”%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + “://“ + request.getServerName() + “:” + request.getServerPort() + path + “/“; %&gt; &lt;!DOCTYPE html&gt; ​ ​ 首页 ​ * { font-family: “Arial”; }​ ​ Hello, World!​ ​ Current time is: &lt;%= new java.util.Date().toString() %&gt; 对应的Java代码： /* Generated by the Jasper component of Apache Tomcat Version: Apache Tomcat/7.0.52 Generated at: 2014-10-13 13:28:38 UTC Note: The last modified time of this file was set to the last modified time of the source file after generation to assist with modification tracking. */ package org.apache.jsp; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase ​ implements org.apache.jasper.runtime.JspSourceDependent { ​ private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory ​ .getDefaultFactory(); ​ private static java.util.Map&lt;java.lang.String, java.lang.Long&gt; _jspx_dependants; ​ private javax.el.ExpressionFactory _el_expressionfactory; ​ private org.apache.tomcat.InstanceManager _jsp_instancemanager; ​ public java.util.Map&lt;java.lang.String, java.lang.Long&gt; getDependants() { ​ return _jspx_dependants; ​ } ​ public void _jspInit() { ​ _el_expressionfactory = _jspxFactory.getJspApplicationContext( ​ getServletConfig().getServletContext()).getExpressionFactory(); ​ _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory ​ .getInstanceManager(getServletConfig()); ​ } ​ public void _jspDestroy() { ​ } ​ public void _jspService( ​ final javax.servlet.http.HttpServletRequest request, ​ final javax.servlet.http.HttpServletResponse response) ​ throws java.io.IOException, javax.servlet.ServletException { ​ // 内置对象就是在这里定义的 ​ final javax.servlet.jsp.PageContext pageContext; ​ javax.servlet.http.HttpSession session = null; ​ final javax.servlet.ServletContext application; ​ final javax.servlet.ServletConfig config; ​ javax.servlet.jsp.JspWriter out = null; ​ final java.lang.Object page = this; ​ javax.servlet.jsp.JspWriter _jspx_out = null; ​ javax.servlet.jsp.PageContext _jspx_page_context = null; ​ try { ​ response.setContentType(“text/html;charset=UTF-8”); ​ pageContext = _jspxFactory.getPageContext(this, request, response, ​ null, true, 8192, true); ​ _jspx_page_context = pageContext; ​ application = pageContext.getServletContext(); ​ config = pageContext.getServletConfig(); ​ session = pageContext.getSession(); ​ out = pageContext.getOut(); ​ _jspx_out = out; ​ out.write(‘\\r’); ​ out.write(‘\\n’); ​ String path = request.getContextPath(); ​ String basePath = request.getScheme() + “://“ ​ + request.getServerName() + “:” + request.getServerPort() ​ + path + “/“; // 以下代码通过输出流将HTML标签输出到浏览器中 ​ out.write(“\\r\\n”); ​ out.write(“\\r\\n”); ​ out.write(“&lt;!DOCTYPE html&gt;\\r\\n”); ​ out.write(“\\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ &lt;base href=””); ​ out.print(basePath); ​ out.write(“”&gt;\\r\\n”); ​ out.write(“ 首页\\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ \\t* { font-family: “Arial”; }\\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ Hello, World!\\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“ Current time is: “); ​ out.print(new java.util.Date().toString()); ​ out.write(“\\r\\n”); ​ out.write(“ \\r\\n”); ​ out.write(“\\r\\n”); ​ } catch (java.lang.Throwable t) { ​ if (!(t instanceof javax.servlet.jsp.SkipPageException)) { ​ out = _jspx_out; ​ if (out != null &amp;&amp; out.getBufferSize() != 0) ​ try { ​ out.clearBuffer(); ​ } catch (java.io.IOException e) { ​ } ​ if (_jspx_page_context != null) ​ _jspx_page_context.handlePageException(t); ​ else ​ throw new ServletException(t); ​ } ​ } finally { ​ jspxFactory.releasePageContext(jspx_page_context); ​ } ​ } } JSP有什么优点？下面列出了使用JSP的优点： JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。 JSP页面可以被预编译。 JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。 开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。 开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive： 包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。 页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。 Taglib指令： 用来声明页面中使用的自定义的标签库。 什么是JSP动作(JSP action)？JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作： jsp:include-当JSP页面被请求的时候包含一个文件。 jsp:useBean-找出或者是初始化Javabean。 jsp:setProperty-设置JavaBean的属性。 jsp:getProperty-获取JavaBean的属性。 jsp:forward-把请求转发到新的页面。 jsp:plugin-产生特定浏览器的代码。 什么是Scriptlets？JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。 get和post请求的区别？答： get请求用来从服务器上获得资源，而post是用来向服务器提交数据； get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式； 使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。 声明(Decalaration)在哪里？声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。 什么是表达式(Expression)？【列表很长，可以分上、中、下发布】 JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在&lt;%=和%&gt;这两个标签之间定义的。 隐含对象是什么意思？有哪些隐含对象？JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象： application page request response session exception out config pageContext JSP和Servlet是什么关系？答：其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 常用的Web服务器有哪些？答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介： IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。 WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。 Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。 Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。 如何实现JSP或Servlet的单线程模式？答：对于JSP页面，可以通过page指令进行设置。 &lt;%@page isThreadSafe=”false”%&gt; 1 对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。 说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。 实现会话跟踪的技术有哪些？答：由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。①URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。②设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。③cookie：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。④HttpSession：在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。 补充：HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。 过滤器有哪些作用和用法？ 答： Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。 常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。 和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。 编码过滤器的例子： import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.annotation.WebInitParam; @WebFilter(urlPatterns = { “*” }, ​ initParams = {@WebInitParam(name=”encoding”, value=”utf-8”)}) public class CodingFilter implements Filter { ​ private String defaultEncoding = “utf-8”; ​ @Override ​ public void destroy() { ​ } ​ @Override ​ public void doFilter(ServletRequest req, ServletResponse resp, ​ FilterChain chain) throws IOException, ServletException { ​ req.setCharacterEncoding(defaultEncoding); ​ resp.setCharacterEncoding(defaultEncoding); ​ chain.doFilter(req, resp); ​ } ​ @Override ​ public void init(FilterConfig config) throws ServletException { ​ String encoding = config.getInitParameter(“encoding”); ​ if (encoding != null) { ​ defaultEncoding = encoding; ​ } ​ } } 下载计数过滤器的例子： import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; @WebFilter(urlPatterns = {“/*”}) public class DownloadCounterFilter implements Filter { ​ private ExecutorService executorService = Executors.newSingleThreadExecutor(); ​ private Properties downloadLog; ​ private File logFile; ​ @Override ​ public void destroy() { ​ executorService.shutdown(); ​ } ​ @Override ​ public void doFilter(ServletRequest req, ServletResponse resp, ​ FilterChain chain) throws IOException, ServletException { ​ HttpServletRequest request = (HttpServletRequest) req; ​ final String uri = request.getRequestURI(); ​ executorService.execute(new Runnable() { ​ @Override ​ public void run() { ​ String value = downloadLog.getProperty(uri); ​ if(value == null) { ​ downloadLog.setProperty(uri, “1”); ​ } ​ else { ​ int count = Integer.parseInt(value); ​ downloadLog.setProperty(uri, String.valueOf(++count)); ​ } ​ try { ​ downloadLog.store(new FileWriter(logFile), “”); ​ } ​ catch (IOException e) { ​ e.printStackTrace(); ​ } ​ } ​ }); ​ chain.doFilter(req, resp); ​ } ​ @Override ​ public void init(FilterConfig config) throws ServletException { ​ String appPath = config.getServletContext().getRealPath(“/“); ​ logFile = new File(appPath, “downloadLog.txt”); ​ if(!logFile.exists()) { ​ try { ​ logFile.createNewFile(); ​ } ​ catch(IOException e) { ​ e.printStackTrace(); ​ } ​ } ​ downloadLog = new Properties(); ​ try { ​ downloadLog.load(new FileReader(logFile)); ​ } catch (IOException e) { ​ e.printStackTrace(); ​ } ​ } } 说明：这里使用了Servlet 3规范中的注解来部署过滤器，当然也可以在web.xml中使用和标签部署过滤器，如108题中所示。 监听器有哪些作用和用法？答：Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：①ServletContextListener：对Servlet上下文的创建和销毁进行监听。②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。③HttpSessionListener：对Session的创建和销毁进行监听。 补充：session的销毁有两种情况：1). session超时（可以在web.xml中通过/标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。 ④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。 下面是一个统计网站最多在线人数监听器的例子。 import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; /** 上下文监听器，在服务器启动时初始化onLineCount和maxOnLineCount两个变量 并将其置于服务器上下文（ServletContext）中，其初始值都是0 */ @WebListener public class InitListener implements ServletContextListener { ​ @Override ​ public void contextDestroyed(ServletContextEvent evt) { ​ } ​ @Override ​ public void contextInitialized(ServletContextEvent evt) { ​ evt.getServletContext().setAttribute(“onLineCount”, 0); ​ evt.getServletContext().setAttribute(“maxOnLineCount”, 0); ​ } } import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import javax.servlet.ServletContext; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; /** 会话监听器，在用户会话创建和销毁的时候根据情况 修改onLineCount和maxOnLineCount的值 */ @WebListener public class MaxCountListener implements HttpSessionListener { ​ @Override ​ public void sessionCreated(HttpSessionEvent event) { ​ ServletContext ctx = event.getSession().getServletContext(); ​ int count = Integer.parseInt(ctx.getAttribute(“onLineCount”).toString()); ​ count++; ​ ctx.setAttribute(“onLineCount”, count); ​ int maxOnLineCount = Integer.parseInt(ctx.getAttribute(“maxOnLineCount”).toString()); ​ if (count &gt; maxOnLineCount) { ​ ctx.setAttribute(“maxOnLineCount”, count); ​ DateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); ​ ctx.setAttribute(“date”, df.format(new Date())); ​ } ​ } ​ @Override ​ public void sessionDestroyed(HttpSessionEvent event) { ​ ServletContext app = event.getSession().getServletContext(); ​ int count = Integer.parseInt(app.getAttribute(“onLineCount”).toString()); ​ count–; ​ app.setAttribute(“onLineCount”, count); ​ } } 说明：这里使用了Servlet 3规范中的@WebListener注解配置监听器，当然你可以在web.xml文件中用标签配置监听器，如108题中所示。 web.xml文件中可以配置哪些内容？答：web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置： ①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器： ​ contextConfigLocation ​ classpath:applicationContext.xml ​ ​ org.springframework.web.context.ContextLoaderListener​ ②配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾： ​ openSessionInView​ ​ org.springframework.orm.hibernate3.support.OpenSessionInViewFilter​ ​ openSessionInView ​ /* ③配置会话超时时间为10分钟： ​ 10 ④配置404和Exception的错误页面： ​ 404 ​ /error.jsp ​ java.lang.Exception ​ /error.jsp ⑤配置安全认证方式： ​ ​ ProtectedArea ​ /admin/* ​ GET ​ POST ​ ​ ​ admin ​ ​ BASIC ​ admin 说明：对Servlet（小服务）、Listener（监听器）和Filter（过滤器）等Web组件的配置，Servlet 3规范提供了基于注解的配置方式，可以分别使用@WebServlet、@WebListener、@WebFilter注解进行配置。 补充：如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类：A. What you know? — 口令B. What you have? — 数字证书（U盾、密保卡）C. Who you are? — 指纹识别、虹膜识别在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。 你的项目中使用过哪些JSTL标签？答：项目中主要使用了JSTL的核心标签库，包括c:if、c:choose、&lt;c: when&gt;、&lt;c: otherwise&gt;、c:forEach等，主要用于构造循环和分支结构以控制显示逻辑。 说明：虽然JSTL标签库提供了core、sql、fmt、xml等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。 使用标签库有什么好处？如何自定义JSP标签？答：使用标签库的好处包括以下几个方面： 分离JSP页面的内容和逻辑，简化了Web开发； 开发者可以创建自定义标签来封装业务逻辑和显示逻辑； 标签具有很好的可移植性、可维护性和可重用性； 避免了对Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在JSP中书写小脚本） 自定义JSP标签包括以下几个步骤： 编写一个Java类实现实现Tag/BodyTag/IterationTag接口（开发中通常不直接实现这些接口而是继承TagSupport/BodyTagSupport/SimpleTagSupport类，这是对缺省适配模式的应用），重写doStartTag()、doEndTag()等方法，定义标签要完成的功能 编写扩展名为tld的标签描述文件对自定义标签进行部署，tld文件通常放在WEB-INF文件夹下或其子目录中 在JSP页面中使用taglib指令引用该标签库 下面是一个自定义标签库的例子。 步骤1 - 标签类源代码TimeTag.java： package com.jackfrued.tags; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import javax.servlet.jsp.JspException; import javax.servlet.jsp.JspWriter; import javax.servlet.jsp.tagext.TagSupport; public class TimeTag extends TagSupport { ​ private static final long serialVersionUID = 1L; ​ private String format = “yyyy-MM-dd hh:mm:ss”; ​ private String foreColor = “black”; ​ private String backColor = “white”; ​ public int doStartTag() throws JspException { ​ SimpleDateFormat sdf = new SimpleDateFormat(format); ​ JspWriter writer = pageContext.getOut(); ​ StringBuilder sb = new StringBuilder(); ​ sb.append(String.format(“%s”, ​ foreColor, backColor, sdf.format(new Date()))); ​ try { ​ writer.print(sb.toString()); ​ } catch(IOException e) { ​ e.printStackTrace(); ​ } ​ return SKIP_BODY; ​ } ​ public void setFormat(String format) { ​ this.format = format; ​ } ​ public void setForeColor(String foreColor) { ​ this.foreColor = foreColor; ​ } ​ public void setBackColor(String backColor) { ​ this.backColor = backColor; ​ } } 步骤2 - 编写标签库描述文件my.tld： &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt; ​ 定义标签库​ 1.0​ MyTag​ ​ time​ com.jackfrued.tags.TimeTag​ empty​ ​ format​ false​ ​ ​ foreColor​ ​ ​ backColor​ ​ 步骤3 - 在JSP页面中使用自定义标签： &lt;%@ page pageEncoding=”UTF-8”%&gt; &lt;%@ taglib prefix=”my” uri=”/WEB-INF/tld/my.tld” %&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + “://“ + request.getServerName() + “:” + request.getServerPort() + path + “/“; %&gt; &lt;!DOCTYPE html&gt; ​ ​ 首页 ​ * { font-family: “Arial”; font-size:72px; }​ ​ &lt;my:time format=”yyyy-MM-dd” backColor=”blue” foreColor=”yellow”/&gt; 提示：如果要将自定义的标签库发布成JAR文件，需要将标签库描述文件（tld文件）放在JAR文件的META-INF目录下，可以JDK中的jar工具完成JAR文件的生成，如果不清楚如何操作，可以请教谷老师和百老师。 说一下表达式语言（EL）的隐式对象及其作用。 答：EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。 用法如下所示： ${pageContext.request.method} ${pageContext”request”} ${pageContext.request[“method”]} ${pageContext[“request”].method} ${initParam.defaultEncoding} ${header[“accept-language”]} ${headerValues”accept-language”} ${cookie.jsessionid.value} ${sessionScope.loginUser.username} 补充：表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[]运算符而不能使用.运算符获取它的值 表达式语言（EL）支持哪些运算符？答：除了.和[]运算符，EL还提供了： 算术运算符：+、-、*、/或div、%或mod 关系运算符：==或eq、!=或ne、&gt;或gt、&gt;=或ge、&lt;或lt、&lt;=或le 逻辑运算符：&amp;&amp;或and、||或or、!或not 条件运算符：${statement? A : B}（跟Java的条件运算符类似） empty运算符：检查一个值是否为null或者空（数组长度为0或集合中没有元素也返回true） Java Web开发的Model 1和Model 2分别指的是什么？答：Model 1是以页面为中心的Java Web开发，使用JSP+JavaBean技术将页面显示逻辑和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现业务逻辑。Model 2是基于MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视图的彻底分离，利于团队开发和代码复用，如下图所示。 Servlet 3中的异步处理指的是什么？答：在Servlet 3中引入了一项新的技术可以让Servlet异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么Servlet或Filter会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个Runnable对象交给Executor并立即返回即可。（如果不清楚多线程和线程池的相关内容，请查看《Java面试题全集（上）》关于多线程和线程池的部分或阅读我的另一篇文章《关于Java并发编程的总结和思考》） 补充：多线程在Java诞生初期无疑是一个亮点，而Servlet单实例多线程的工作方式也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦的相对论颠覆了牛顿的经典力学一般。事实上，异步处理绝不是Serlvet 3首创，如果你了解Node.js的话，对Servlet 3的这个重要改进就不以为奇了。 下面是一个支持异步处理请求的Servlet的例子。 import java.io.IOException; import javax.servlet.AsyncContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(urlPatterns = {“/async”}, asyncSupported = true) public class AsyncServlet extends HttpServlet { ​ private static final long serialVersionUID = 1L; ​ @Override ​ public void doGet(HttpServletRequest req, HttpServletResponse resp) ​ throws ServletException, IOException { ​ // 开启Tomcat异步Servlet支持 ​ req.setAttribute(“org.apache.catalina.ASYNC_SUPPORTED”, true); ​ final AsyncContext ctx = req.startAsync(); // 启动异步处理的上下文 ​ // ctx.setTimeout(30000); ​ ctx.start(new Runnable() { ​ @Override ​ public void run() { ​ // 在此处添加异步处理的代码 ​ ctx.complete(); ​ } ​ }); ​ } } 讲解JSP中的四种作用域。答：JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 如何在基于Java的Web项目中实现文件上传和下载？答：在Sevlet 3 以前，Servlet API中没有支持上传功能的API，因此要实现上传功能需要引入第三方工具从POST请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用Apache的commons-fileupload。从Servlet 3开始，文件上传变得无比简单，相信看看下面的例子一切都清楚了。 上传页面index.jsp： &lt;%@ page pageEncoding=”utf-8”%&gt; &lt;!DOCTYPE html&gt; Photo UploadSelect your photo and upload${hint}​ Photo file: ​ 支持上传的Servlet： package com.jackfrued.servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.MultipartConfig; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.Part; @WebServlet(“/UploadServlet”) @MultipartConfig public class UploadServlet extends HttpServlet { ​ private static final long serialVersionUID = 1L; ​ protected void doPost(HttpServletRequest request, ​ HttpServletResponse response) throws ServletException, IOException { ​ // 可以用request.getPart()方法获得名为photo的上传附件 ​ // 也可以用request.getParts()获得所有上传附件（多文件上传） ​ // 然后通过循环分别处理每一个上传的文件 ​ Part part = request.getPart(“photo”); ​ if (part != null &amp;&amp; part.getSubmittedFileName().length() &gt; 0) { ​ // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径 ​ String savePath = request.getServletContext().getRealPath(“/upload”); ​ // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名 ​ // 更好的做法是为上传的文件进行重命名（避免同名文件的相互覆盖） ​ part.write(savePath + “/“ + part.getSubmittedFileName()); ​ request.setAttribute(“hint”, “Upload Successfully!”); ​ } else { ​ request.setAttribute(“hint”, “Upload failed!”); ​ } ​ // 跳转回到上传页面 ​ request.getRequestDispatcher(“index.jsp”).forward(request, response); ​ } } 服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？ 答：HTML的元素有一个method属性，用来指定提交表单的方式，其值可以是get或post。我们自定义的Servlet一般情况下会重写doGet()或doPost()两个方法之一或全部，如果是GET请求就调用doGet()方法，如果是POST请求就调用doPost()方法，那为什么为什么这样呢？我们自定义的Servlet通常继承自HttpServlet，HttpServlet继承自GenericServlet并重写了其中的service()方法，这个方法是Servlet接口中定义的。HttpServlet重写的service()方法会先获取用户请求的方法，然后根据请求方法调用doGet()、doPost()、doPut()、doDelete()等方法，如果在自定义Servlet中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java与模式》一书的第37章）。当然，自定义Servlet中也可以直接重写service()方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。 117、JSP中的静态包含和动态包含有什么区别？答：静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作jsp:forward包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的”contentType”属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。代码如下所示： &lt;%– 静态包含 –%&gt; &lt;%@ include file=”…” %&gt; &lt;%– 动态包含 –%&gt; &lt;jsp:include page=”…”&gt; ​ &lt;jsp:param name=”…” value=”…” /&gt; /jsp:include Servlet中如何获取用户提交的查询参数或表单数据？答：可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。 119、Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？答：可以通过重写Servlet接口的init(ServletConfig)方法并通过ServletConfig对象的getInitParameter()方法来获取Servlet的初始化参数。可以通过ServletConfig对象的getServletContext()方法获取ServletContext对象，并通过该对象的getInitParameter()方法来获取服务器上下文参数。当然，ServletContext对象也在处理用户请求的方法（如doGet()方法）中通过请求对象的getServletContext()方法来获得。 如何设置请求的编码以及响应内容的类型？答：通过请求对象（ServletRequest）的setCharacterEncoding(String)方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是UTF-8；通过响应对象（ServletResponse）的setContentType(String)方法可以设置响应内容的类型，当然也可以通过HttpServletResponsed对象的setHeader(String, String)方法来设置。 说明：现在如果还有公司在面试的时候问JSP的声明标记、表达式标记、小脚本标记这些内容的话，这样的公司也不用去了，其实JSP内置对象、JSP指令这些东西基本上都可以忘却了，关于Java Web开发的相关知识，可以看一下我的《Servlet&amp;JSP思维导图》，上面有完整的知识点的罗列。想了解如何实现自定义MVC框架的，可以看一下我的《Java Web自定义MVC框架详解》。 阐述Servlet和CGI的区别?答：Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。 补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。 什么是Servlet？Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。 Servlet接口中有哪些方法？答：Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destory() java.lang.String getServletInfo() ServletConfig getServletConfig() Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。 说一下Servlet的体系结构。所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。 Applet和Servlet有什么区别？Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。 GenericServlet和HttpServlet有什么区别？GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。 HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法。 解释下Servlet的生命周期。对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。 doGet()方法和doPost()方法有什么区别？doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。 doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。 什么是Web应用程序？Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。 什么是服务端包含(Server Side Include)？服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。 什么是Servlet链(Servlet Chaining)？Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 如何知道是哪一个客户端的机器正在请求你的Servlet？ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。看下这里的例子。 HTTP响应的结构是怎么样的？HTTP响应由三个部分组成： 状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。 HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。 主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。 什么是cookie？session和cookie有什么区别？cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别： 无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。 在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。 浏览器和Servlet通信使用的是什么协议？浏览器和Servlet通信使用的是HTTP协议。 什么是HTTP隧道？HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。 sendRedirect()和forward()方法有什么区别？sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。 什么是URL编码和URL解码？URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 转发（forward）和重定向（redirect）的区别？答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-序列化相关","date":"2018-10-20T10:13:40.000Z","path":"2018/10/20/Java-面试题系列篇-序列化相关/","text":"序列化相关解释下Marshalling和demarshalling。当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。 解释下Serialization和Deserialization。Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-基础算法","date":"2018-10-20T10:13:20.000Z","path":"2018/10/20/Java-面试题系列篇-基础算法/","text":"基础算法用Java写一个冒泡排序。答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码： import java.util.Comparator; /** 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) @author骆昊 * */ public interface Sorter { /** ​ * 排序 ​ * @param list 待排序的数组 ​ */ public &lt;T extends Comparable&gt; void sort(T[] list); /** ​ * 排序 ​ * @param list 待排序的数组 ​ * @param comp 比较两个对象的比较器 ​ */ public void sort(T[] list, Comparator comp); } import java.util.Comparator; /** 冒泡排序 @author骆昊 * */ public class BubbleSorter implements Sorter { ​ @Override ​ public &lt;T extends Comparable&gt; void sort(T[] list) { ​ boolean swapped = true; ​ for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) { ​ swapped = false; ​ for (int j = 0; j &lt; len - i; ++j) { ​ if (list[j].compareTo(list[j + 1]) &gt; 0) { ​ T temp = list[j]; ​ list[j] = list[j + 1]; ​ list[j + 1] = temp; ​ swapped = true; ​ } ​ } ​ } ​ } ​ @Override ​ public void sort(T[] list, Comparator comp) { ​ boolean swapped = true; ​ for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) { ​ swapped = false; ​ for (int j = 0; j &lt; len - i; ++j) { ​ if (comp.compare(list[j], list[j + 1]) &gt; 0) { ​ T temp = list[j]; ​ list[j] = list[j + 1]; ​ list[j + 1] = temp; ​ swapped = true; ​ } ​ } ​ } ​ } } 用Java写一个折半查找。答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。 import java.util.Comparator; public class MyUtil { public static &lt;T extends Comparable&gt; int binarySearch(T[] x, T key) { ​ return binarySearch(x, 0, x.length- 1, key); } // 使用循环实现的二分查找 public static int binarySearch(T[] x, T key, Comparator comp) { ​ int low = 0; ​ int high = x.length - 1; ​ while (low &lt;= high) { ​ int mid = (low + high) &gt;&gt;&gt; 1; ​ int cmp = comp.compare(x[mid], key); ​ if (cmp &lt; 0) { ​ low= mid + 1; ​ } ​ else if (cmp &gt; 0) { ​ high= mid - 1; ​ } ​ else { ​ return mid; ​ } ​ } ​ return -1; } // 使用递归实现的二分查找 private static&lt;T extends Comparable&gt; int binarySearch(T[] x, int low, int high, T key) { ​ if(low &lt;= high) { ​ int mid = low + ((high -low) &gt;&gt; 1); ​ if(key.compareTo(x[mid])== 0) { ​ return mid; ​ } ​ else if(key.compareTo(x[mid])&lt; 0) { ​ return binarySearch(x,low, mid - 1, key); ​ } ​ else { ​ return binarySearch(x,mid + 1, high, key); ​ } ​ } ​ return -1; } } 说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2或low + (high – low) &gt;&gt; 1或(low + high) &gt;&gt;&gt; 1（&gt;&gt;&gt;是逻辑右移，是不带符号位的右移） 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。 是否可以在static环境中访问非static变量？static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 Java支持的数据类型有哪些？什么是自动拆装箱？Java语言支持的8种基本数据类型是： byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程 Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。 Java支持多继承么？Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 接口和抽象类的区别是什么？Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 也可以参考JDK8中抽象类和接口的区别 什么是值传递和引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 进程和线程的区别是什么？进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。 线程的划分小于进程，线程隶属于某个进程。 进程是程序的一种动态形式，是CPU、内存等资源占用的基本单位，而线程是不能占有这些资源的。 进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信比较方便。 进程在执行的过程中，包含比较固定的入口，执行顺序，出口，而线程的这些过程会被应用程序所控制。 创建线程有几种不同的方式？你喜欢哪一种？为什么？有4种方式可以用来创建线程： 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 还有一种方式是实现Callable接口。 概括的解释下线程的几种可用状态。\\1. 新建( new )：新创建了一个线程对象。 \\2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 \\3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 \\4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种： (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 \\5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 同步方法和同步代码块的区别是什么？区别： 同步方法默认用this或者当前类class对象作为锁； 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法； 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰； 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 什么是死锁(deadlock)？所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件： 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类框架的基本接口有哪些？集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有： Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的Collection。 List：有顺序的collection，并且可以包含重复元素。 Map：可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 什么是迭代器(Iterator)？Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的 迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的 remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 Iterator和ListIterator的区别是什么？下面列出了他们的区别： Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： HashMap允许键和值是null，而Hashtable不允许键或者值是null。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。 一般认为Hashtable是一个遗留的类。 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？下面列出了Array和ArrayList的不同点： Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 也可以参考ArrayList vs. LinkedList。 Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是一个渐进上界 。 大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。 如何权衡是使用无序的数组还是有序的数组？有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 Enumeration接口和Iterator接口的区别有哪些？Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 HashSet和TreeSet有什么区别？HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。 垃圾回收的目的是通过识别并且丢弃应用不再使用的对象来释放和重用资源。 System.gc()和Runtime.gc()会做什么事情？这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要 的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 永久代是用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含： 类的方法(字节码…) 类名(Sring对象) .class文件读到的常量信息 class对象相关的对象列表和类型列表 (e.g., 方法对象的array). JVM创建的内部对象 JIT编译器优化用的信息 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 JVM的永久代中会发生垃圾回收么？垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) Java中的两种异常类型是什么？他们有什么区别？Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。 Java中Exception和Error有什么区别？Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。 throw和throws有什么区别？throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 finally代码块和finalize()方法有什么区别？无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 什么是Applet？java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。 解释一下Applet的生命周期applet可以经历下面的状态： Init：每次被载入的时候都会被初始化。 Start：开始执行applet。 Stop：结束执行applet。 Destroy：卸载applet之前，做最后的清理工作。 当applet被载入的时候会发生什么？首先，创建applet控制类的实例，然后初始化applet，最后开始运行。 Applet和普通的Java应用程序有什么区别？applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。 进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。 最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。 Java applet有哪些限制条件？主要是由于安全的原因，给applet施加了以下的限制： applet不能够载入类库或者定义本地方法。 applet不能在宿主机上读写文件。 applet不能读取特定的系统属性。 applet不能发起网络连接，除非是跟宿主机。 applet不能够开启宿主机上其他任何的程序。 什么是不受信任的applet？不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。 从网络上加载的applet和从本地文件系统加载的applet有什么区别？当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。 当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。 从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。 applet类加载器是什么？它会做哪些工作？当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。 当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。 applet安全管理器是什么？它会做哪些工作？applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。 弹出式选择菜单(Choice)和列表(List)有什么区别Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。 什么是布局管理器？布局管理器用来在容器中组织组件。 什么是JDBC？JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 Class.forName()方法有什么作用？初始化参数指定的类，并且返回此类对应的Class 对象 PreparedStatement比Statement有什么优势？PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStatement Connection.prepareCall(); 数据库连接池是什么意思？像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-设计模式","date":"2018-10-20T10:13:04.000Z","path":"2018/10/20/Java-面试题系列篇-设计模式/","text":"设计模式简述一下你了解的设计模式。答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 用Java写一个单例类。答： 饿汉式单例 public class Singleton { ​ private Singleton(){} ​ private static Singleton instance = new Singleton(); ​ public static Singleton getInstance(){ ​ return instance; ​ } } 懒汉式单例 public class Singleton { ​ private static Singleton instance = null; ​ private Singleton() {} ​ public static synchronized Singleton getInstance(){ ​ if (instance == null) instance ＝ new Singleton(); ​ return instance; ​ } } 注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-正则表达式","date":"2018-10-20T10:12:50.000Z","path":"2018/10/20/Java-面试题系列篇-正则表达式/","text":"正则表达式简述正则表达式及其用途。 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 Java中是如何支持正则表达式操作的？答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？ import java.util.regex.Matcher; import java.util.regex.Pattern; class RegExpTest { ​ public static void main(String[] args) { ​ String str = “北京市(朝阳区)(西城区)(海淀区)”; ​ Pattern p = Pattern.compile(“.*?(?=()”); ​ Matcher m = p.matcher(str); ​ if(m.find()) { ​ System.out.println(m.group()); ​ } ​ } } 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-JDBC","date":"2018-10-20T10:12:41.000Z","path":"2018/10/20/Java-面试题系列篇-JDBC/","text":"JDBC阐述JDBC操作数据库的步骤。答：下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。 加载驱动。 ​ Class.forName(“oracle.jdbc.driver.OracleDriver”); 创建连接。 ​ Connection con = DriverManager.getConnection(“jdbc:oracle:thin:@localhost:1521:orcl”, “scott”, “tiger”); 创建语句。 ​ PreparedStatement ps = con.prepareStatement(“select * from emp where sal between ? and ?”); ​ ps.setInt(1, 1000); ​ ps.setInt(2, 3000); 执行语句。 ​ ResultSet rs = ps.executeQuery(); 处理结果。 ​ while(rs.next()) { ​ System.out.println(rs.getInt(“empno”) + “ - “ + rs.getString(“ename”)); ​ } 关闭资源。 ​ finally { ​ if(con != null) { ​ try { ​ con.close(); ​ } catch (SQLException e) { ​ e.printStackTrace(); ​ } ​ } ​ } 提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。 Statement和PreparedStatement有什么区别？哪个性能更好？ 答：与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。 补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。 使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。 在进行数据库编程时，连接池有什么作用？ 答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 什么是DAO模式？ 答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 事务的ACID是指什么？答： 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性(Consistent)：事务结束后系统状态是一致的； 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。 补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。 脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 取出500元余额修改为500元 T5 查询账户余额为500元（脏读） T6 撤销事务余额恢复为1000元 T7 汇入100元把余额修改为600元 T8 提交事务 不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 取出100元修改余额为900元 T6 提交事务 T7 查询账户余额为900元（不可重复读） 幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。 时间 统计金额事务A 转账事务B T1 开始事务 T2 开始事务 T3 统计总存款为10000元 T4 新增一个存款账户存入100元 T5 提交事务 T6 再次统计总存款为10100元（幻读） 第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。 时间 取款事务A 转账事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 汇入100元修改余额为1100元 T6 提交事务 T7 取出100元将余额修改为900元 T8 撤销事务 T9 余额恢复为1000元（丢失更新） 第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 取出100元将余额修改为900元 T6 提交事务 T7 汇入100元将余额修改为1100元 T8 提交事务 T9 查询账户余额为1100元（丢失更新） 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示： 隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READ COMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。 JDBC中如何进行事务处理？ 答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 JDBC能否处理Blob和Clob？答： Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB：下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下： create table tb_user ( id int primary key auto_increment, name varchar(20) unique not null, photo longblob ); 下面的Java代码向数据库中插入一条记录： import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.SQLException; class JdbcLobTest { ​ public static void main(String[] args) { ​ Connection con = null; ​ try { ​ // 1. 加载驱动（Java6以上版本可以省略） ​ Class.forName(“com.mysql.jdbc.Driver”); ​ // 2. 建立连接 ​ con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/test”, “root”, “123456”); ​ // 3. 创建语句对象 ​ PreparedStatement ps = con.prepareStatement(“insert into tb_user values (default, ?, ?)”); ​ ps.setString(1, “骆昊”); // 将SQL语句中第一个占位符换成字符串 ​ try (InputStream in = new FileInputStream(“test.jpg”)) { // Java 7的TWR ​ ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 ​ // 4. 发出SQL语句获得受影响行数 ​ System.out.println(ps.executeUpdate() == 1 ? “插入成功” : “插入失败”); ​ } catch(IOException e) { ​ System.out.println(“读取照片失败!”); ​ } ​ } catch (ClassNotFoundException | SQLException e) { // Java 7的多异常捕获 ​ e.printStackTrace(); ​ } finally { // 释放外部资源的代码都应当放在finally中保证其能够得到执行 ​ try { ​ if(con != null &amp;&amp; !con.isClosed()) { ​ con.close(); // 5. 释放数据库连接 ​ con = null; // 指示垃圾回收器可以回收该对象 ​ } ​ } catch (SQLException e) { ​ e.printStackTrace(); ​ } ​ } ​ } }","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-数据库","date":"2018-10-20T10:12:34.000Z","path":"2018/10/20/Java-面试题系列篇-数据库/","text":"","tags":[]},{"title":"Java 面试题系列篇-反射","date":"2018-10-20T10:12:21.000Z","path":"2018/10/20/Java-面试题系列篇-反射/","text":"反射 获得一个类的类对象有哪些方式？ 答： 方法1：类型.class，例如：String.class 方法2：对象.getClass()，例如：”hello”.getClass() 方法3：Class.forName()，例如：Class.forName(“java.lang.String”) 如何通过反射创建对象？ 答： 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 如何通过反射获取和设置对象私有字段的值？ 答：可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.List; /** 反射工具类 @author 骆昊 * */ public class ReflectionUtil { private ReflectionUtil() { throw new AssertionError(); } /** * 通过反射取对象指定字段(属性)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) { Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split(&quot;.&quot;); try { for(int i = 0; i &lt; fs.length - 1; i++) { Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); } Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); } catch (Exception e) { throw new RuntimeException(e); } } /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) { Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split(&quot;.&quot;); try { for(int i = 0; i &lt; fs.length - 1; i++) { Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) { Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); } target = val; clazz = target.getClass(); } Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); } catch (Exception e) { throw new RuntimeException(e); } } } 如何通过反射调用对象的方法？ 答：请看下面的代码： import java.lang.reflect.Method; class MethodInvokeTest { public static void main(String[] args) throws Exception { String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO } }","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇(五)-IO流","date":"2018-10-20T10:11:45.000Z","path":"2018/10/20/Java-面试题系列篇-IO流/","text":"","tags":[]},{"title":"Java 面试题系列篇(四)-集合","date":"2018-10-20T10:11:28.000Z","path":"2018/10/20/Java-面试题系列篇-集合/","text":"","tags":[]},{"title":"Java 面试题系列篇-常用API","date":"2018-10-20T10:11:13.000Z","path":"2018/10/20/Java-面试题系列篇-常用API/","text":"","tags":[]},{"title":"Java 面试题系列篇-多线程","date":"2018-10-20T10:10:10.000Z","path":"2018/10/20/Java-面试题系列篇-多线程/","text":"多线程什么是线程？线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。 比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒 什么是线程安全和线程不安全？通俗的说：加锁的就是是线程安全的，不加锁的就是是线程不安全的 线程安全 线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。 Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。 线程不安全 线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 什么是自旋锁？基本概念 自旋锁是SMP架构中的一种low-level的同步机制。 当线程A想要获取一把自选锁而该锁又被其它线程锁持有时，线程A会在一个循环中自选以检测锁是不是已经可用了。 自选锁需要注意： 由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。 持有自旋锁的线程在sleep之前应该释放自旋锁以便其它线程可以获得自旋锁。 实现自旋锁 参考 segmentfault.com/q/101000000… 一个简单的while就可以满足你的要求。 目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大。 public class MyWaitNotify3{ MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait(){ ​ synchronized(myMonitorObject){ ​ while(!wasSignalled){ ​ try{ ​ myMonitorObject.wait(); ​ } catch(InterruptedException e){…} ​ } ​ //clear signal and continue running. ​ wasSignalled = false; ​ } } public void doNotify(){ ​ synchronized(myMonitorObject){ ​ wasSignalled = true; ​ myMonitorObject.notify(); ​ } } } 什么是Java内存模型？Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。 Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。 “一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反映了缓存的影响。 此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。 看下面代码展示的一个简单例子： ClassReordering { ​ ​ int x = 0, y = 0; ​ public void writer() { ​ x = 1; ​ y = 2; ​ } ​ public void reader() { ​ int r1 = y; ​ int r2 = x; ​ } }复制代码 让我们看在两个并发线程中执行这段代码，读取Y变量将会得到2这个值。因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定会得到1。但是，写入操作可能被重排序过。如果重排序发生了，那么，就能发生对Y变量的写入操作，读取两个变量的操作紧随其后，而且写入到X这个操作能发生。程序的结果可能是r1变量的值是2，但是r2变量的值为0。 但是面试官，有时候不这么认为，认为就是JVM内存结构 JVM内存结构主要有三大块：堆内存、方法区和栈。 堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。 JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method) java堆（Java Heap） 可通过参数 -Xms 和-Xmx设置 Java堆是被所有线程共享,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建。 Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里。 Java堆为了便于更好的回收和分配内存，可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor区。 新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。 老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 Survivor空间等Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可（就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的）。 据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 java虚拟机栈(stack) 可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置 1.Java虚拟机栈是线程私有的，它的生命周期与线程相同。 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：每个方法在执行的同时都会创建一个栈帧，用于存储 局部变量表、操作数栈、动态链接、方法出口等信息。 局部变量表：32位变量槽，存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。 操作数栈：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。 动态连接：每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态连接 方法出口：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。 在方法运行期间不会改变局部变量表的大小。主要存放了编译期可知的各种基本数据类型、对象引用 （reference类型）、returnAddress类型）。 java虚拟机栈,规定了两种异常状况： 如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机栈动态扩展，而扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈 可通过参数 栈容量可由-Xss设置 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。 本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一 方法区（Method Area） 可通过参数-XX:MaxPermSize设置 线程共享内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）。 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 如何实现方法区，属于虚拟机的实现细节，不受虚拟机规范约束。 方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收,但不是没有垃圾回收。 方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池。 运行时常量池 JDK1.6之前字符串常量池位于方法区之中。 JDK1.7字符串常量池已经被挪到堆之中。 可通过参数-XX:PermSize和-XX:MaxPermSize设置 常量池（Constant Pool）：常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量。 字符串池/字符串常量池（String Pool/String Constant Pool）：是常量池中的一部分，存储编译期类中产生的字符串类型数据。 运行时常量池（Runtime Constant Pool）：方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。 字面量：文本字符串、声明为final的常量值等。 符号引用：类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。 直接内存 可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。 总结的简单一点 java堆（Java Heap） 可通过参数 -Xms 和-Xmx设置 Java堆是被所有线程共享,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建 Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里 Java堆为了便于更好的回收和分配内存，可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor区 新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。 老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 java虚拟机栈(stack) 可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置 Java虚拟机栈是线程私有的，它的生命周期与线程相同。 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：每个方法在执行的同时都会创建一个栈帧，用于存储 局部变量表、操作数栈、动态链接、方法出口等信息 方法区（Method Area） 可通过参数-XX:MaxPermSize设置 线程共享内存区域），用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）。 方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收,但不是没有垃圾回收。 方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池。 什么是CAS？CAS（compare and swap）的缩写，中文翻译成比较并交换。 CAS 不通过JVM,直接利用java本地方 JNI（Java Native Interface为JAVA本地调用）,直接调用CPU 的cmpxchg（是汇编指令）指令。 利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。其它原子操作都是利用类似的特性完成的。 整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。 CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS应用 CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 CAS优点 确保对内存的读-改-写操作都是原子操作执行 CAS缺点 CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作 总结 使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用。 synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。 参考 blog.52itstyle.com/archives/94… 什么是乐观锁和悲观锁？悲观锁 Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。 乐观锁 乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 什么是AQS？AbstractQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。 AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。 CAS 原子操作在concurrent包的实现 参考 blog.52itstyle.com/archives/94… 由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式： A线程写volatile变量，随后B线程读这个volatile变量。 A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。 Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为volatile； 然后，使用CAS的原子条件更新来实现线程之间的同步； 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 AQS，非阻塞数据结构和原子变量类（Java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下： AQS没有锁之类的概念，它有个state变量，是个int类型，在不同场合有着不同含义。 AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程，并提供一系列判断和处理方法，简单说几点： state是独占的，还是共享的； state被获取后，其他线程需要等待； state被释放后，唤醒等待线程； 线程等不及时，如何退出等待。 至于线程是否可以获得state，如何释放state，就不是AQS关心的了，要由子类具体实现。 AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。 AbstractQueuedSynchronizer继承了AbstractOwnableSynchronizer，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。 ReentrantLock实现原理 www.cnblogs.com/maypattis/p… 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。 到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。 什么是Executors框架？Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。 Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。 利用Executors框架可以非常方便的创建一个线程池， Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？JDK7提供了7个阻塞队列。（也属于并发容器） ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 什么是阻塞队列？ 阻塞队列是一个在队列基础上又支持了两个附加操作的队列。 2个附加操作： 支持阻塞的插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：队列空时，获取元素的线程会等待队列变为非空。 阻塞队列的应用场景 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者获取元素的容器。 几个方法 在阻塞队列不可用的时候，上述2个附加操作提供了四种处理方法 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 JAVA里的阻塞队列 JDK 7 提供了7个阻塞队列，如下 1、ArrayBlockingQueue 数组结构组成的有界阻塞队列。 此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。 2、LinkedBlockingQueue一个由链表结构组成的有界阻塞队列 此队列按照先出先进的原则对元素进行排序 3、PriorityBlockingQueue支持优先级的无界阻塞队列 4、DelayQueue支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素 5、SynchronousQueue不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。 6、LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法 transfer方法 如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。 tryTransfer方法 用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。 7、LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。 如何使用阻塞队列来实现生产者-消费者模型？ 通知模式实现：所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。 使用BlockingQueue解决生产者消费者问题 为什么BlockingQueue适合解决生产者消费者问题 任何有效的生产者-消费者问题解决方案都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你将解决该问题。 Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。 BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正是解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。 生产者 以下代码用于生产者线程 package io.ymq.example.thread; import java.util.concurrent.BlockingQueue; /** 描述:生产者 * @author yanpenglei @create 2018-03-14 15:52 **/class Producer implements Runnable { ​ protected BlockingQueue queue; ​ Producer(BlockingQueue theQueue) { ​ this.queue = theQueue; ​ } ​ public void run() { ​ try { ​ while (true) { ​ Object justProduced = getResource(); ​ queue.put(justProduced); ​ System.out.println(“生产者资源队列大小= “ + queue.size()); ​ } ​ } catch (InterruptedException ex) { ​ System.out.println(“生产者 中断”); ​ } ​ } ​ Object getResource() { ​ try { ​ Thread.sleep(100); ​ } catch (InterruptedException ex) { ​ System.out.println(“生产者 读 中断”); ​ } ​ return new Object(); ​ } }复制代码 消费者 以下代码用于消费者线程 package io.ymq.example.thread; import java.util.concurrent.BlockingQueue; /** 描述: 消费者 * @author yanpenglei @create 2018-03-14 15:54 **/class Consumer implements Runnable { ​ protected BlockingQueue queue; ​ Consumer(BlockingQueue theQueue) { ​ this.queue = theQueue; ​ } ​ public void run() { ​ try { ​ while (true) { ​ Object obj = queue.take(); ​ System.out.println(“消费者 资源 队列大小 “ + queue.size()); ​ take(obj); ​ } ​ } catch (InterruptedException ex) { ​ System.out.println(“消费者 中断”); ​ } ​ } ​ void take(Object obj) { ​ try { ​ Thread.sleep(100); // simulate time passing ​ } catch (InterruptedException ex) { ​ System.out.println(“消费者 读 中断”); ​ } ​ System.out.println(“消费对象 “ + obj); ​ } }复制代码 测试该解决方案是否运行正常 package io.ymq.example.thread;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue; /** 描述: 测试 * @author yanpenglei @create 2018-03-14 15:58 **/public class ProducerConsumerExample { ​ public static void main(String[] args) throws InterruptedException { ​ int numProducers = 4; ​ int numConsumers = 3; ​ BlockingQueue myQueue = new LinkedBlockingQueue(5); ​ for (int i = 0; i &lt; numProducers; i++) { ​ new Thread(new Producer(myQueue)).start(); ​ } ​ for (int i = 0; i &lt; numConsumers; i++) { ​ new Thread(new Consumer(myQueue)).start(); ​ } ​ Thread.sleep(1000); ​ System.exit(0); ​ } }复制代码 运行结果 生产者资源队列大小= 1 生产者资源队列大小= 1 消费者 资源 队列大小 1 生产者资源队列大小= 1 消费者 资源 队列大小 1 消费者 资源 队列大小 1 生产者资源队列大小= 1 生产者资源队列大小= 3 消费对象 java.lang.Object@1e1aa52b 生产者资源队列大小= 2 生产者资源队列大小= 5 消费对象 java.lang.Object@6e740a76 消费对象 java.lang.Object@697853f6 …… 消费对象 java.lang.Object@41a10cbc 消费对象 java.lang.Object@4963c8d1 消费者 资源 队列大小 5 生产者资源队列大小= 5 生产者资源队列大小= 5 消费者 资源 队列大小 4 消费对象 java.lang.Object@3e49c35d 消费者 资源 队列大小 4 生产者资源队列大小= 5复制代码 从输出结果中,我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源。 什么是Callable和Future?Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。 Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。 在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。 代码示例 Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。 为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。 public class CallableFutureTest { ​ public static void main(String[] args) throws InterruptedException, ExecutionException { ​ System.out.println(“start main thread “); ​ ExecutorService exec = Executors.newFixedThreadPool(2); ​ //新建一个Callable 任务，并将其提交到一个ExecutorService. 将返回一个描述任务情况的Future. ​ Callable call = new Callable() { ​ @Override ​ public String call() throws Exception { ​ System.out.println(“start new thread “); ​ Thread.sleep(5000); ​ System.out.println(“end new thread “); ​ return “我是返回的内容”; ​ } ​ }; ​ Future task = exec.submit(call); ​ Thread.sleep(1000); ​ String retn = task.get(); ​ //关闭线程池 ​ exec.shutdown(); ​ System.out.println(retn + “–end main thread”); ​ } }复制代码 控制台打印 start main thread start new thread end new thread 我是返回的内容–end main thread复制代码 什么是FutureTask?FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。 1.执行多任务计算 FutureTask执行多任务计算的使用场景 利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。 import java.util.ArrayList;import java.util.List;import java.util.concurrent.*; public class FutureTaskForMultiCompute { ​ public static void main(String[] args) { ​ FutureTaskForMultiCompute inst = new FutureTaskForMultiCompute(); ​ // 创建任务集合 ​ List&lt;FutureTask&gt; taskList = new ArrayList&lt;FutureTask&gt;(); ​ // 创建线程池 ​ ExecutorService exec = Executors.newFixedThreadPool(5); ​ for (int i = 0; i &lt; 10; i++) { ​ // 传入Callable对象创建FutureTask对象 ​ FutureTask ft = new FutureTask(inst.new ComputeTask(i, “” + i)); ​ taskList.add(ft); ​ // 提交给线程池执行任务，也可以通过exec.invokeAll(taskList)一次性提交所有任务; ​ exec.submit(ft); ​ } ​ System.out.println(“所有计算任务提交完毕, 主线程接着干其他事情！”); ​ // 开始统计各计算线程计算结果 ​ Integer totalResult = 0; ​ for (FutureTask ft : taskList) { ​ try { ​ //FutureTask的get方法会自动阻塞,直到获取计算结果为止 ​ totalResult = totalResult + ft.get(); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } catch (ExecutionException e) { ​ e.printStackTrace(); ​ } ​ } ​ // 关闭线程池 ​ exec.shutdown(); ​ System.out.println(“多任务计算后的总结果是:” + totalResult); ​ } ​ private class ComputeTask implements Callable { ​ private Integer result = 0; ​ private String taskName = “”; ​ public ComputeTask(Integer iniResult, String taskName) { ​ result = iniResult; ​ this.taskName = taskName; ​ System.out.println(“生成子线程计算任务: “ + taskName); ​ } ​ public String getTaskName() { ​ return this.taskName; ​ } ​ @Override ​ public Integer call() throws Exception { ​ // TODO Auto-generated method stub ​ for (int i = 0; i &lt; 100; i++) { ​ result = +i; ​ } ​ // 休眠5秒钟，观察主线程行为，预期的结果是主线程会继续执行，到要取得FutureTask的结果是等待直至完成。 ​ Thread.sleep(5000); ​ System.out.println(“子线程计算任务: “ + taskName + “ 执行完成!”); ​ return result; ​ } ​ } }复制代码 生成子线程计算任务: 0 生成子线程计算任务: 1 生成子线程计算任务: 2 生成子线程计算任务: 3 生成子线程计算任务: 4 生成子线程计算任务: 5 生成子线程计算任务: 6 生成子线程计算任务: 7 生成子线程计算任务: 8 生成子线程计算任务: 9 所有计算任务提交完毕, 主线程接着干其他事情！ 子线程计算任务: 0 执行完成! 子线程计算任务: 2 执行完成! 子线程计算任务: 3 执行完成! 子线程计算任务: 4 执行完成! 子线程计算任务: 1 执行完成! 子线程计算任务: 8 执行完成! 子线程计算任务: 7 执行完成! 子线程计算任务: 6 执行完成! 子线程计算任务: 9 执行完成! 子线程计算任务: 5 执行完成! 多任务计算后的总结果是:990复制代码 2.高并发环境下 FutureTask在高并发环境下确保任务只执行一次 在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，则创建连接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应关系，典型的代码如下面所示： private Map&lt;String, Connection&gt; connectionPool = new HashMap&lt;String, Connection&gt;(); ​ private ReentrantLock lock = new ReentrantLock(); ​ public Connection getConnection(String key) { ​ try { ​ lock.lock(); ​ if (connectionPool.containsKey(key)) { ​ return connectionPool.get(key); ​ } else { ​ //创建 Connection ​ Connection conn = createConnection(); ​ connectionPool.put(key, conn); ​ return conn; ​ } ​ } finally { ​ lock.unlock(); ​ } ​ } ​ //创建Connection ​ private Connection createConnection() { ​ return null; ​ } 复制代码 在上面的例子中，我们通过加锁确保高并发环境下的线程安全，也确保了connection只创建一次，然而确牺牲了性能。改用ConcurrentHash的情况下，几乎可以避免加锁的操作，性能大大提高，但是在高并发的情况下有可能出现Connection被创建多次的现象。这时最需要解决的问题就是当key不存在时，创建Connection的动作能放在connectionPool之后执行，这正是FutureTask发挥作用的时机，基于ConcurrentHashMap和FutureTask的改造代码如下： private ConcurrentHashMap&lt;String, FutureTask&gt; connectionPool = new ConcurrentHashMap&lt;String, FutureTask&gt;(); ​ public Connection getConnection(String key) throws Exception { ​ FutureTask connectionTask = connectionPool.get(key); ​ if (connectionTask != null) { ​ return connectionTask.get(); ​ } else { ​ Callable callable = new Callable() { ​ @Override ​ public Connection call() throws Exception { ​ // TODO Auto-generated method stub ​ return createConnection(); ​ } ​ }; ​ FutureTask newTask = new FutureTask(callable); ​ connectionTask = connectionPool.putIfAbsent(key, newTask); ​ if (connectionTask == null) { ​ connectionTask = newTask; ​ connectionTask.run(); ​ } ​ return connectionTask.get(); ​ } ​ } ​ //创建Connection ​ private Connection createConnection() { ​ return null; ​ }复制代码 经过这样的改造，可以避免由于并发带来的多次创建连接及锁的出现。 什么是同步容器和并发容器的实现？一、同步容器 主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。 锁的粒度为当前对象整体。 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。 二、并发容器 主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。 锁的粒度是分散的、细粒度的，即读和写是使用不同的锁。 迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。 JDK 7 ConcurrentHashMap 采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问； JDK 8 ConcurrentHashMap 采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问； 三、阻塞队列 主要代表有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable,Comparator)、SynchronousQueue。 提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。 适用于生产者、消费者模式（线程池和工作队列-Executor），同时也是同步容器 四、双端队列 主要代表有ArrayDeque和LinkedBlockingDeque。 意义：正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。 如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。 在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。 适用于：网页爬虫等任务中 五、比较及适用场景 如果不需要阻塞队列，优先选择ConcurrentLinkedQueue； 如果需要阻塞队列，队列大小固定优先选择ArrayBlockingQueue，队列大小不固定优先选择LinkedBlockingQueue； 如果需要对队列进行排序，选择PriorityBlockingQueue； 如果需要一个快速交换的队列，选择SynchronousQueue； 如果需要对队列中的元素进行延时操作，则选择DelayQueue。 什么是多线程？优缺点？什么是多线程？ 多线程：是指从软件或者硬件上实现多个线程的并发技术。 多线程的好处： 使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载 发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好 多线程的缺点： 大量的线程降低代码的可读性； 更多的线程需要更多的内存空间 当多个线程对同一个资源出现争夺时候要注意线程安全的问题。 什么是多线程的上下文切换？即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms） 上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态 从任务保存到再加载的过程就是一次上下文切换 ThreadLocal的设计理念与作用？Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量 ThreadLocal 如何创建ThreadLocal变量 以下代码展示了如何创建一个ThreadLocal变量： private ThreadLocal myThreadLocal = new ThreadLocal();复制代码 通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。 如何访问ThreadLocal变量 一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值： myThreadLocal.set(“A thread local value”);复制代码 可以通过下面方法读取保存在ThreadLocal变量中的值： String threadLocalValue = (String) myThreadLocal.get();复制代码 get()方法返回一个Object对象，set()对象需要传入一个Object类型的参数。 为ThreadLocal指定泛型类型 public static ThreadLocal myThreadLocal = new ThreadLocal();复制代码 我们可以创建一个指定泛型类型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值作强制类型转换了。下面展示了指定泛型类型的ThreadLocal例子： ThreadLocal的设计理念与作用 http://blog.csdn.net/u011860731/article/details/48733073http://blog.csdn.net/u011860731/article/details/48733073) InheritableThreadLocal public static ThreadLocal threadLocal = new InheritableThreadLocal();复制代码 InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。 InheritableThreadLocal 原理 Java 多线程：InheritableThreadLocal 实现原理 blog.csdn.net/ni357103403… ThreadPool（线程池）用法与优势？为什么要用线程池: 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 new Thread 缺点 每次new Thread新建对象性能差。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 ThreadPool 优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机) 减少在创建和销毁线程上所花的时间以及系统资源的开销 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存 Java提供的四种线程池的好处在于： 重用存在的线程，减少对象创建、销毁的开销，提高性能。 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 比较重要的几个类： 类 描述 ExecutorService 真正的线程池接口。 ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。 ThreadPoolExecutor ExecutorService的默认实现。 ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 Executors提供四种线程池 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 一般都不用Executors提供的线程创建方式 使用ThreadPoolExecutor创建线程池 ThreadPoolExecutor的构造函数 public ThreadPoolExecutor(int corePoolSize, ​ int maximumPoolSize, ​ long keepAliveTime, ​ TimeUnit unit, ​ BlockingQueue workQueue, ​ ThreadFactory threadFactory, ​ RejectedExecutionHandler handler) { ​ if (corePoolSize &lt; 0 || ​ maximumPoolSize &lt;= 0 || ​ maximumPoolSize &lt; corePoolSize || ​ keepAliveTime &lt; 0) ​ throw new IllegalArgumentException(); ​ if (workQueue == null || threadFactory == null || handler == null) ​ throw new NullPointerException(); ​ this.corePoolSize = corePoolSize; ​ this.maximumPoolSize = maximumPoolSize; ​ this.workQueue = workQueue; ​ this.keepAliveTime = unit.toNanos(keepAliveTime); ​ this.threadFactory = threadFactory; ​ this.handler = handler; ​ }复制代码 参数： corePoolSize核心线程数大小，当线程数&lt;corePoolSize ，会创建线程执行runnable maximumPoolSize 最大线程数， 当线程数 &gt;= corePoolSize的时候，会把runnable放入workQueue中 keepAliveTime 保持存活时间，当线程数大于corePoolSize的空闲线程能保持的最大时间。 unit 时间单位 workQueue 保存任务的阻塞队列 threadFactory 创建线程的工厂 handler 拒绝策略 任务执行顺序： 当线程数小于corePoolSize时，创建线程执行任务。 当线程数大于等于corePoolSize并且workQueue没有满时，放入workQueue中 线程数大于等于corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize 当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecution。也就是拒绝策略。 ThreadPoolExecutor默认有四个拒绝策略： ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行 ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务 ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务 当然可以自己继承 RejectedExecutionHandler 来写拒绝策略. java 四种线程池的使用 juejin.im/post/59df0c… Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。 阻塞队列 1、ArrayBlockingQueue 数组结构组成的有界阻塞队列。 此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。 CountDownLatch CountDownLatch 允许一个或多个线程等待其他线程完成操作。 应用场景 假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。 在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join。代码如下： public class JoinCountDownLatchTest { ​ public static void main(String[] args) throws InterruptedException { ​ Thread parser1 = new Thread(new Runnable() { ​ @Override ​ public void run() { ​ } ​ }); ​ Thread parser2 = new Thread(new Runnable() { ​ @Override ​ public void run() { ​ System.out.println(“parser2 finish”); ​ } ​ }); ​ parser1.start(); ​ parser2.start(); ​ parser1.join(); ​ parser2.join(); ​ System.out.println(“all parser finish”); ​ } }复制代码 join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait，代码片段如下，wait(0)表示永远等待下去。 while (isAlive()) { wait(0); }复制代码 方法isAlive()功能是判断当前线程是否处于活动状态。 活动状态就是线程启动且尚未终止，比如正在运行或准备开始运行。 CountDownLatch用法 public class Test { ​ public static void main(String[] args) { ​ ​ final CountDownLatch latch = new CountDownLatch(2); ​ new Thread(){ ​ public void run() { ​ try { ​ System.out.println(“子线程”+Thread.currentThread().getName()+”正在执行”); ​ Thread.sleep(3000); ​ System.out.println(“子线程”+Thread.currentThread().getName()+”执行完毕”); ​ latch.countDown(); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ }; ​ }.start(); ​ new Thread(){ ​ public void run() { ​ try { ​ System.out.println(“子线程”+Thread.currentThread().getName()+”正在执行”); ​ Thread.sleep(3000); ​ System.out.println(“子线程”+Thread.currentThread().getName()+”执行完毕”); ​ latch.countDown(); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ }; ​ }.start(); ​ try { ​ System.out.println(“等待2个子线程执行完毕…”); ​ latch.await(); ​ System.out.println(“2个子线程已经执行完毕”); ​ System.out.println(“继续执行主线程”); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } }复制代码 线程Thread-0正在执行 线程Thread-1正在执行 等待2个子线程执行完毕… 线程Thread-0执行完毕 线程Thread-1执行完毕 2个子线程已经执行完毕 继续执行主线程复制代码 new CountDownLatch(2)的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。 当我们调用一次CountDownLatch的countDown()方法时，N就会减1，CountDownLatch的await()会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，你只需要把这个CountDownLatch的引用传递到线程里。 Java并发编程：CountDownLatch、CyclicBarrier和 Semaphore www.importnew.com/21889.html synchronized和ReentrantLock的区别？java在编写多线程程序时，为了保证线程安全，需要对数据同步，经常用到两种同步方式就是Synchronized和重入锁ReentrantLock。 基础知识 可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。 可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。 公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。 CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Synchronized synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性 例如： 当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。 如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。 ReentrantLock ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。 代码示例 private Lock lock = new ReentrantLock();public void test(){ lock.lock(); try{ doSomeThing(); }catch (Exception e){ // ignored }finally { lock.unlock(); } }复制代码 lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁 tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false； tryLock(long timeout,TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false； lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 ReentrantLock 一些特性 等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false） 公平锁与非公平锁多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。 公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO； 非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。 Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。 ReenTrantLock实现的原理： 简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。 总结一下 在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。 synchronized： 在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。 ReentrantLock: ReentrantLock用起来会复杂一些。在基本的加锁和解锁上，两者是一样的，所以无特殊情况下，推荐使用synchronized。ReentrantLock的优势在于它更灵活、更强大，增加了轮训、超时、中断等高级功能。 ReentrantLock默认使用非公平锁是基于性能考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。 ReentrantLock实现原理 www.cnblogs.com/maypattis/p… 分析ReentrantLock的实现原理(ReentrantLock和同步工具类的实现基础都是AQS) www.jianshu.com/p/fe027772e… Semaphore有什么作用？Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。 Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问， 如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。 由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 Semaphore类位于java.util.concurrent包下，它提供了2个构造器： //参数permits表示许可数目，即同时可以允许多少线程进行访问 public Semaphore(int permits) { ​ sync = new NonfairSync(permits); } //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可 public Semaphore(int permits, boolean fair) { ​ sync = (fair)? new FairSync(permits) : new NonfairSync(permits); } 复制代码 Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。 Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。复制代码 这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法： //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false public boolean tryAcquire() { }; //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //得到当前可用的许可数目 public int availablePermits(); 复制代码 示例 假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现： public class Test { ​ public static void main(String[] args) { ​ int N = 8; //工人数 ​ Semaphore semaphore = new Semaphore(5); //机器数目 ​ for(int i=0;i&lt;N;i++) ​ new Worker(i,semaphore).start(); ​ } ​ static class Worker extends Thread{ ​ private int num; ​ private Semaphore semaphore; ​ public Worker(int num,Semaphore semaphore){ ​ this.num = num; ​ this.semaphore = semaphore; ​ } ​ @Override ​ public void run() { ​ try { ​ semaphore.acquire(); ​ System.out.println(“工人”+this.num+”占用一个机器在生产…”); ​ Thread.sleep(2000); ​ System.out.println(“工人”+this.num+”释放出机器”); ​ semaphore.release(); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } ​ } } 复制代码 运行结果： 工人0占用一个机器在生产… 工人1占用一个机器在生产… 工人2占用一个机器在生产… 工人4占用一个机器在生产… 工人5占用一个机器在生产… 工人0释放出机器 工人2释放出机器 工人3占用一个机器在生产… 工人7占用一个机器在生产… 工人4释放出机器 工人5释放出机器 工人1释放出机器 工人6占用一个机器在生产… 工人3释放出机器 工人7释放出机器 工人6释放出机器复制代码 Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。 而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 ConcurrentHashMap的并发度是什么？ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势 ReentrantReadWriteLock读写锁的使用Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁； 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ ReentrantReadWriteLock会使用两把锁来解决问题，一个读锁，一个写锁 线程进入读锁的前提条件： 没有其他线程的写锁 没有写请求或者有写请求，但调用线程和持有锁的线程是同一个 线程进入写锁的前提条件： 没有其他线程的读锁 没有其他线程的写锁 读锁的重入是允许多个申请读操作的线程的，而写锁同时只允许单个线程占有，该线程的写操作可以重入。 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。 对于同时占有读锁和写锁的线程，如果完全释放了写锁，那么它就完全转换成了读锁，以后的写操作无法重入，在写锁未完全释放时写操作是可以重入的。 公平模式下无论读锁还是写锁的申请都必须按照AQS锁等待队列先进先出的顺序。非公平模式下读操作插队的条件是锁等待队列head节点后的下一个节点是SHARED型节点，写锁则无条件插队。 读锁不允许newConditon获取Condition接口，而写锁的newCondition接口实现方法同ReentrantLock。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 面试题系列篇-面向对象","date":"2018-10-20T10:07:36.000Z","path":"2018/10/20/Java-面试题系列篇-面向对象/","text":"面向对象面向对象软件开发的优点有哪些？代码开发模块化，更易维护和修改。 代码复用。 增强代码的可靠性和灵活性。 增加代码的可理解性。 面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。 封装的定义和好处有哪些？封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。 下面列出了使用封装的一些好处： 通过隐藏对象的属性来保护对象内部的状态。 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。 禁止对象之间的不良交互提高模块化。 参考这个文档获取更多关于封装的细节和示例。 或： 一是用private把类的细节与外界隔离起来，从而实现数据项和方法的隐藏，而要访问这些数据项和方法唯一的途径就是通过类本身，类才有资格调用它所拥有的资源（方法，数据项属性等等）。所以第一个好处就是数据的安全性提高了。 二是通过隐藏隔离，只允许外部对类做有限的访问，开发者可以自由的改变类的内部实现，而无需修改使用该类的那些程序。只要那些在类外部就能被调用的方法保持其外部特征不变，内部代码就可以自由改变，各取所需，利于分工。 三就是提高了代码的重用性，封装成工具类以后能够减少很多繁琐的步骤。 多态的定义？多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。 继承的定义？继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。 抽象的定义？抽象和封装的不同点？抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。 抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。 简述一下面向对象的”六原则一法则”。答： 单一职责原则： 一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则： 软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则： 面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） 里氏替换原则： 任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则： 接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则： 优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则： 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java-面试题系列篇-编程基础","date":"2018-10-19T08:18:51.000Z","path":"2018/10/19/Java-面试题系列篇-编程基础/","text":"本文主要是对近年来出现的Java面试题进行整理汇总，方便大家更好的准备面试. 编程基础面向对象的特征有哪些方面？答：面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 访问修饰符有哪些？区别？ 修饰符 当前类 同 包 子 类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × String 是最基本的数据类型吗？答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。 float f=3.4;是否正确？答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F。 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 Java有没有goto？答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） int和Integer有什么区别？答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double class AutoUnboxingTest { ​ public static void main(String[] args) { ​ Integer a = new Integer(3); ​ Integer b = 3; // 将3自动装箱成Integer类型 ​ int c = 3; ​ System.out.println(a == b); // false 两个引用没有引用同一对象 ​ System.out.println(a == c); // true a自动拆箱成int类型再和c比较 ​ } } 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： public class Test03 { ​ public static void main(String[] args) { ​ Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; ​ System.out.println(f1 == f2); ​ System.out.println(f3 == f4); ​ } } 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。 ​ public static Integer valueOf(int i) { ​ if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) ​ return IntegerCache.cache[i + (-IntegerCache.low)]; ​ return new Integer(i); ​ } IntegerCache是Integer的内部类，其代码如下所示： /** ​ * Cache to support the object identity semantics of autoboxing for values between ​ * -128 and 127 (inclusive) as required by JLS. ​ * ​ * The cache is initialized on first usage. The size of the cache ​ * may be controlled by the {@code -XX:AutoBoxCacheMax=} option. ​ * During VM initialization, java.lang.Integer.IntegerCache.high property ​ * may be set and saved in the private system properties in the ​ * sun.misc.VM class. ​ */ ​ private static class IntegerCache { ​ static final int low = -128; ​ static final int high; ​ static final Integer cache[]; ​ static { ​ // high value may be configured by property ​ int h = 127; ​ String integerCacheHighPropValue = ​ sun.misc.VM.getSavedProperty(“java.lang.Integer.IntegerCache.high”); ​ if (integerCacheHighPropValue != null) { ​ try { ​ int i = parseInt(integerCacheHighPropValue); ​ i = Math.max(i, 127); ​ // Maximum array size is Integer.MAX_VALUE ​ h = Math.min(i, Integer.MAX_VALUE - (-low) -1); ​ } catch( NumberFormatException nfe) { ​ // If the property cannot be parsed into an int, ignore it. ​ } ​ } ​ high = h; ​ cache = new Integer[(high - low) + 1]; ​ int j = low; ​ for(int k = 0; k &lt; cache.length; k++) ​ cache[k] = new Integer(j++); ​ // range [-128, 127] must be interned (JLS7 5.1.7) ​ assert IntegerCache.high &gt;= 127; ​ } ​ private IntegerCache() {} ​ } 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 &amp;和&amp;&amp;的区别？答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。 String str = new String(“hello”); 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。 补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。 看看下面代码的执行结果是什么并且比较一下Java 7以前和以后的运行结果是否一致。 String s1 = new StringBuilder(“go”) ​ .append(“od”).toString(); System.out.println(s1.intern() == s1); String s2 = new StringBuilder(“ja”) ​ .append(“va”).toString(); System.out.println(s2.intern() == s2); Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？ 答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后向下取整。 switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？答： （1）在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。 （2）从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型， （3）从Java 7开始，expr还可以是字符串（String）。 但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法计算2乘以8？答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。 public class PhoneNumber { ​ private int areaCode; ​ private String prefix; ​ private String lineNumber; ​ @Override ​ public int hashCode() { ​ final int prime = 31; ​ int result = 1; ​ result = prime * result + areaCode; ​ result = prime * result ​ + ((lineNumber == null) ? 0 : lineNumber.hashCode()); ​ result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); ​ return result; ​ } ​ @Override ​ public boolean equals(Object obj) { ​ if (this == obj) ​ return true; ​ if (obj == null) ​ return false; ​ if (getClass() != obj.getClass()) ​ return false; ​ PhoneNumber other = (PhoneNumber) obj; ​ if (areaCode != other.areaCode) ​ return false; ​ if (lineNumber == null) { ​ if (other.lineNumber != null) ​ return false; ​ } else if (!lineNumber.equals(other.lineNumber)) ​ return false; ​ if (prefix == null) { ​ if (other.prefix != null) ​ return false; ​ } else if (!prefix.equals(other.prefix)) ​ return false; ​ return true; ​ } } 数组有没有length()方法？String有没有length()方法？答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 在Java中，如何跳出当前的多重嵌套循环？答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 构造器（constructor）是否可被重写（override）？答：构造器不能被继承，因此不能被重写，但可以被重载。 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 是否可以继承String类？答：String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。 using System; namespace CS01 { ​ class Program { ​ public static void swap(ref int x, ref int y) { ​ int temp = x; ​ x = y; ​ y = temp; ​ } ​ public static void Main (string[] args) { ​ int a = 5, b = 10; ​ swap (ref a, ref b); ​ // a = 10, b = 5; ​ Console.WriteLine (“a = {0}, b = {1}”, a, b); ​ } ​ } } 说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。 String和StringBuilder、StringBuffer的区别？ 答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。 面试题1 - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？ 面试题2 - 请说出下面程序的输出。 class StringEqualTest { ​ public static void main(String[] args) { ​ String s1 = “Programming”; ​ String s2 = new String(“Programming”); ​ String s3 = “Program”; ​ String s4 = “ming”; ​ String s5 = “Program” + “ming”; ​ String s6 = s3 + s4; ​ System.out.println(s1 == s2); ​ System.out.println(s1 == s5); ​ System.out.println(s1 == s6); ​ System.out.println(s1 == s6.intern()); ​ System.out.println(s2 == s2.intern()); ​ } } 补充：解答上面的面试题需要清楚两点：1. String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来区分重载”，快说出你的答案吧！ 描述一下JVM加载class文件的原理机制？答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 char 型变量中能不能存贮一个中文汉字，为什么？ 答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。 补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。 抽象类（abstract class）和接口（interface）有什么异同？答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？ 答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 /** 扑克类（一副扑克） @author 骆昊 * */ public class Poker { ​ private static String[] suites = {“黑桃”, “红桃”, “草花”, “方块”}; ​ private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; ​ private Card[] cards; ​ /** ​ * 构造器 ​ * ​ */ ​ public Poker() { ​ cards = new Card[52]; ​ for(int i = 0; i &lt; suites.length; i++) { ​ for(int j = 0; j &lt; faces.length; j++) { ​ cards[i * 13 + j] = new Card(suites[i], faces[j]); ​ } ​ } ​ } ​ /** ​ * 洗牌 （随机乱序） ​ * ​ */ ​ public void shuffle() { ​ for(int i = 0, len = cards.length; i &lt; len; i++) { ​ int index = (int) (Math.random() * len); ​ Card temp = cards[index]; ​ cards[index] = cards[i]; ​ cards[i] = temp; ​ } ​ } ​ /** ​ * 发牌 ​ * @param index 发牌的位置 ​ * ​ */ ​ public Card deal(int index) { ​ return cards[index]; ​ } ​ /** ​ * 卡片类（一张扑克） ​ * [内部类] ​ * @author 骆昊 ​ * ​ */ ​ public class Card { ​ private String suite; // 花色 ​ private int face; // 点数 ​ public Card(String suite, int face) { ​ this.suite = suite; ​ this.face = face; ​ } ​ @Override ​ public String toString() { ​ String faceStr = “”; ​ switch(face) { ​ case 1: faceStr = “A”; break; ​ case 11: faceStr = “J”; break; ​ case 12: faceStr = “Q”; break; ​ case 13: faceStr = “K”; break; ​ default: faceStr = String.valueOf(face); ​ } ​ return suite + faceStr; ​ } ​ } } 测试代码： class PokerTest { ​ public static void main(String[] args) { ​ Poker poker = new Poker(); ​ poker.shuffle(); // 洗牌 ​ Poker.Card c1 = poker.deal(0); // 发第一张牌 ​ // 对于非静态内部类Card ​ // 只有通过其外部类Poker对象才能创建Card对象 ​ Poker.Card c2 = poker.new Card(“红心”, 1); // 自己创建一张牌 ​ System.out.println(c1); // 洗牌后的第一张 ​ System.out.println(c2); // 打印: 红心A ​ } } 面试题 - 下面的代码哪些地方会产生编译错误？ class Outer { ​ class Inner {} ​ public static void foo() { new Inner(); } ​ public void bar() { new Inner(); } ​ public static void main(String[] args) { ​ new Inner(); ​ } } 注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： new Outer().new Inner(); 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？ 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 阐述静态变量和实例变量的区别。 答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 如何实现对象克隆？ 答：有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class MyUtil { ​ private MyUtil() { ​ throw new AssertionError(); ​ } ​ @SuppressWarnings(“unchecked”) ​ public static T clone(T obj) throws Exception { ​ ByteArrayOutputStream bout = new ByteArrayOutputStream(); ​ ObjectOutputStream oos = new ObjectOutputStream(bout); ​ oos.writeObject(obj); ​ ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ​ ObjectInputStream ois = new ObjectInputStream(bin); ​ return (T) ois.readObject(); ​ // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 ​ // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 ​ } } 下面是测试代码： import java.io.Serializable; /** 人类 @author 骆昊 * */ class Person implements Serializable { ​ private static final long serialVersionUID = -9102017020286042305L; ​ private String name; // 姓名 ​ private int age; // 年龄 ​ private Car car; // 座驾 ​ public Person(String name, int age, Car car) { ​ this.name = name; ​ this.age = age; ​ this.car = car; ​ } ​ public String getName() { ​ return name; ​ } ​ public void setName(String name) { ​ this.name = name; ​ } ​ public int getAge() { ​ return age; ​ } ​ public void setAge(int age) { ​ this.age = age; ​ } ​ public Car getCar() { ​ return car; ​ } ​ public void setCar(Car car) { ​ this.car = car; ​ } ​ @Override ​ public String toString() { ​ return “Person [name=” + name + “, age=” + age + “, car=” + car + “]”; ​ } } /** 小汽车类 @author 骆昊 * */ class Car implements Serializable { ​ private static final long serialVersionUID = -5713945027627603702L; ​ private String brand; // 品牌 ​ private int maxSpeed; // 最高时速 ​ public Car(String brand, int maxSpeed) { ​ this.brand = brand; ​ this.maxSpeed = maxSpeed; ​ } ​ public String getBrand() { ​ return brand; ​ } ​ public void setBrand(String brand) { ​ this.brand = brand; ​ } ​ public int getMaxSpeed() { ​ return maxSpeed; ​ } ​ public void setMaxSpeed(int maxSpeed) { ​ this.maxSpeed = maxSpeed; ​ } ​ @Override ​ public String toString() { ​ return “Car [brand=” + brand + “, maxSpeed=” + maxSpeed + “]”; ​ } } class CloneTest { ​ public static void main(String[] args) { ​ try { ​ Person p1 = new Person(“Hao LUO”, 33, new Car(“Benz”, 300)); ​ Person p2 = MyUtil.clone(p1); // 深度克隆 ​ p2.getCar().setBrand(“BYD”); ​ // 修改克隆的Person对象p2关联的汽车对象的品牌属性 ​ // 原来的Person对象p1关联的汽车不会受到任何影响 ​ // 因为在克隆Person对象时其关联的汽车对象也被克隆了 ​ System.out.println(p1); ​ } catch (Exception e) { ​ e.printStackTrace(); ​ } ​ } } 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 String s = new String(“xyz”);创建了几个字符串对象？答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？ 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ 答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 Java 中的final关键字有哪些用法？ 答： (1)修饰类：表示该类不能被继承； (2)修饰方法：表示方法不能被重写； (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 指出下面程序的运行结果。class A { ​ static { ​ System.out.print(“1”); ​ } ​ public A() { ​ System.out.print(“2”); ​ } } class B extends A{ ​ static { ​ System.out.print(“a”); ​ } ​ public B() { ​ System.out.print(“b”); ​ } } public class Hello { ​ public static void main(String[] args) { ​ A ab = new B(); ​ ab = new B(); ​ } } 答：执行结果：1a2b2b。 创建对象时构造器的调用顺序是： 先初始化静态成员， 然后调用父类构造器， 再初始化非静态成员， 最后调用自身构造器。 提示：如果不能给出此题的正确答案，说明之前第21题Java类加载机制还没有完全理解，赶紧再看看吧。 数据类型之间的转换： - 如何将字符串转换为基本数据类型？ - 如何将基本数据类型转换为字符串？答： 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串 如何实现字符串的反转及替换？答：方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： ​ public static String reverse(String originStr) { ​ if(originStr == null || originStr.length() &lt;= 1) ​ return originStr; ​ return reverse(originStr.substring(1)) + originStr.charAt(0); ​ } 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？答：代码如下所示： String s1 = “你好”; String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”); 日期和时间： - 如何取得年月日、小时分钟秒？ - 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？ - 如何取得某月的最后一天？ - 如何格式化日期？ 答：问题1：创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。 public class DateTimeTest { ​ public static void main(String[] args) { ​ Calendar cal = Calendar.getInstance(); ​ System.out.println(cal.get(Calendar.YEAR)); ​ System.out.println(cal.get(Calendar.MONTH)); // 0 - 11 ​ System.out.println(cal.get(Calendar.DATE)); ​ System.out.println(cal.get(Calendar.HOUR_OF_DAY)); ​ System.out.println(cal.get(Calendar.MINUTE)); ​ System.out.println(cal.get(Calendar.SECOND)); ​ // Java 8 ​ LocalDateTime dt = LocalDateTime.now(); ​ System.out.println(dt.getYear()); ​ System.out.println(dt.getMonthValue()); // 1 - 12 ​ System.out.println(dt.getDayOfMonth()); ​ System.out.println(dt.getHour()); ​ System.out.println(dt.getMinute()); ​ System.out.println(dt.getSecond()); ​ } } 问题2：以下方法均可获得该毫秒数。 Calendar.getInstance().getTimeInMillis(); System.currentTimeMillis(); Clock.systemDefaultZone().millis(); // Java 8 问题3：代码如下所示。 Calendar time = Calendar.getInstance(); time.getActualMaximum(Calendar.DAY_OF_MONTH); 问题4：利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。 import java.text.SimpleDateFormat; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.util.Date; class DateFormatTest { ​ public static void main(String[] args) { ​ SimpleDateFormat oldFormatter = new SimpleDateFormat(“yyyy/MM/dd”); ​ Date date1 = new Date(); ​ System.out.println(oldFormatter.format(date1)); ​ // Java 8 ​ DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(“yyyy/MM/dd”); ​ LocalDate date2 = LocalDate.now(); ​ System.out.println(date2.format(newFormatter)); ​ } } 补充：Java的时间日期API一直以来都是被诟病的东西，为了解决这一问题，Java 8中引入了新的时间日期API，其中包括LocalDate、LocalTime、LocalDateTime、Clock、Instant等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。如果不理解这些内容，可以参考我的另一篇文章《关于Java并发编程的总结和思考》。 打印昨天的当前时刻。答： import java.util.Calendar; class YesterdayCurrent { ​ public static void main(String[] args){ ​ Calendar cal = Calendar.getInstance(); ​ cal.add(Calendar.DATE, -1); ​ System.out.println(cal.getTime()); ​ } } 在Java 8中，可以用下面的代码实现相同的功能。 import java.time.LocalDateTime; class YesterdayCurrent { ​ public static void main(String[] args) { ​ LocalDateTime today = LocalDateTime.now(); ​ LocalDateTime yesterday = today.minusDays(1); ​ System.out.println(yesterday); ​ } } 比较一下Java和JavaSciprt。答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 代码格式不一样。 补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 什么时候用断言（assert）？ 答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示： assert(a &gt; 0); // throws an AssertionError if a &lt;= 0 1 断言可以有两种形式：assert Expression1;assert Expression1 : Expression2 ;Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。 注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。 Error和Exception有什么区别？ 答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： class StackOverflowErrorTest { ​ public static void main(String[] args) { ​ main(null); ​ } } 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?答：会执行，在方法返回调用者前执行。 注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？ 答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。 运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在catch中忽略掉捕获到的异常 列出一些你常见的运行时异常？答： ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 阐述final、finally、finalize的区别。 答： final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 类ExampleA继承Exception，类ExampleB继承ExampleA。 有如下代码片断：try { ​ throw new ExampleB(“b”) } catch（ExampleA e）{ ​ System.out.println(“ExampleA”); } catch（Exception e）{ ​ System.out.println(“Exception”); } 请问执行此段代码的输出是什么？ 答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常） 面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书） class Annoyance extends Exception {} class Sneeze extends Annoyance {} class Human { ​ public static void main(String[] args) ​ throws Exception { ​ try { ​ try { ​ throw new Sneeze(); ​ } ​ catch ( Annoyance a ) { ​ System.out.println(“Caught Annoyance”); ​ throw a; ​ } ​ } ​ catch ( Sneeze s ) { ​ System.out.println(“Caught Sneeze”); ​ return ; ​ } ​ finally { ​ System.out.println(“Hello World!”); ​ } ​ } } List、Set、Map是否继承自Collection接口？答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 阐述ArrayList、Vector、LinkedList的存储性能和特性。答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。 Collection和Collections的区别？答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Map、Set三个接口存取元素时，各有什么特点？ 答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。例子1： public class Student implements Comparable { ​ private String name; // 姓名 ​ private int age; // 年龄 ​ public Student(String name, int age) { ​ this.name = name; ​ this.age = age; ​ } ​ @Override ​ public String toString() { ​ return “Student [name=” + name + “, age=” + age + “]”; ​ } ​ @Override ​ public int compareTo(Student o) { ​ return this.age - o.age; // 比较年龄(年龄的升序) ​ } } import java.util.Set; import java.util.TreeSet; class Test01 { ​ public static void main(String[] args) { ​ Set set = new TreeSet&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) ​ set.add(new Student(“Hao LUO”, 33)); ​ set.add(new Student(“XJ WANG”, 32)); ​ set.add(new Student(“Bruce LEE”, 60)); ​ set.add(new Student(“Bob YANG”, 22)); ​ for(Student stu : set) { ​ System.out.println(stu); ​ } // 输出结果: // Student [name=Bob YANG, age=22] // Student [name=XJ WANG, age=32] // Student [name=Hao LUO, age=33] // Student [name=Bruce LEE, age=60] ​ } } 例子2： public class Student { ​ private String name; // 姓名 ​ private int age; // 年龄 ​ public Student(String name, int age) { ​ this.name = name; ​ this.age = age; ​ } ​ /** ​ * 获取学生姓名 ​ */ ​ public String getName() { ​ return name; ​ } ​ /** ​ * 获取学生年龄 ​ */ ​ public int getAge() { ​ return age; ​ } ​ @Override ​ public String toString() { ​ return “Student [name=” + name + “, age=” + age + “]”; ​ } } import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; class Test02 { ​ public static void main(String[] args) { ​ List list = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) ​ list.add(new Student(“Hao LUO”, 33)); ​ list.add(new Student(“XJ WANG”, 32)); ​ list.add(new Student(“Bruce LEE”, 60)); ​ list.add(new Student(“Bob YANG”, 22)); ​ // 通过sort方法的第二个参数传入一个Comparator接口对象 ​ // 相当于是传入一个比较对象大小的算法到sort方法中 ​ // 由于Java中没有函数指针、仿函数、委托这样的概念 ​ // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 ​ Collections.sort(list, new Comparator () { ​ @Override ​ public int compare(Student o1, Student o2) { ​ return o1.getName().compareTo(o2.getName()); // 比较学生姓名 ​ } ​ }); ​ for(Student stu : list) { ​ System.out.println(stu); ​ } // 输出结果: // Student [name=Bob YANG, age=22] // Student [name=Bruce LEE, age=60] // Student [name=Hao LUO, age=33] // Student [name=XJ WANG, age=32] ​ } } Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。 线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 请说出与线程同步以及线程调度相关的方法。 答： wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 提示：关于Java多线程和并发编程的问题，建议大家看我的另一篇文章《关于Java并发编程的总结和思考》。 补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。 银行账户类： /** 银行账户 @author 骆昊 * */ public class Account { ​ private double balance; // 账户余额 ​ /** ​ * 存款 ​ * @param money 存入金额 ​ */ ​ public void deposit(double money) { ​ double newBalance = balance + money; ​ try { ​ Thread.sleep(10); // 模拟此业务需要一段处理时间 ​ } ​ catch(InterruptedException ex) { ​ ex.printStackTrace(); ​ } ​ balance = newBalance; ​ } ​ /** ​ * 获得账户余额 ​ */ ​ public double getBalance() { ​ return balance; ​ } } 存钱线程类： /** 存钱线程 @author 骆昊 * */ public class AddMoneyThread implements Runnable { ​ private Account account; // 存入账户 ​ private double money; // 存入金额 ​ public AddMoneyThread(Account account, double money) { ​ this.account = account; ​ this.money = money; ​ } ​ @Override ​ public void run() { ​ account.deposit(money); ​ } } 测试类： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Test01 { ​ public static void main(String[] args) { ​ Account account = new Account(); ​ ExecutorService service = Executors.newFixedThreadPool(100); ​ for(int i = 1; i &lt;= 100; i++) { ​ service.execute(new AddMoneyThread(account, 1)); ​ } ​ service.shutdown(); ​ while(!service.isTerminated()) {} ​ System.out.println(“账户余额: “ + account.getBalance()); ​ } } 在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下（很可能是1元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： 在银行账户的存款（deposit）方法上同步（synchronized）关键字 /** 银行账户 @author 骆昊 * */ public class Account { ​ private double balance; // 账户余额 ​ /** ​ * 存款 ​ * @param money 存入金额 ​ */ ​ public synchronized void deposit(double money) { ​ double newBalance = balance + money; ​ try { ​ Thread.sleep(10); // 模拟此业务需要一段处理时间 ​ } ​ catch(InterruptedException ex) { ​ ex.printStackTrace(); ​ } ​ balance = newBalance; ​ } ​ /** ​ * 获得账户余额 ​ */ ​ public double getBalance() { ​ return balance; ​ } } 在线程调用存款方法时对银行账户进行同步 /** 存钱线程 @author 骆昊 * */ public class AddMoneyThread implements Runnable { ​ private Account account; // 存入账户 ​ private double money; // 存入金额 ​ public AddMoneyThread(Account account, double money) { ​ this.account = account; ​ this.money = money; ​ } ​ @Override ​ public void run() { ​ synchronized (account) { ​ account.deposit(money); ​ } ​ } } 通过Java 5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** 银行账户 @author 骆昊 * */ public class Account { ​ private Lock accountLock = new ReentrantLock(); ​ private double balance; // 账户余额 ​ /** ​ * 存款 ​ * ​ * @param money ​ * 存入金额 ​ */ ​ public void deposit(double money) { ​ accountLock.lock(); ​ try { ​ double newBalance = balance + money; ​ try { ​ Thread.sleep(10); // 模拟此业务需要一段处理时间 ​ } ​ catch (InterruptedException ex) { ​ ex.printStackTrace(); ​ } ​ balance = newBalance; ​ } ​ finally { ​ accountLock.unlock(); ​ } ​ } ​ /** ​ * 获得账户余额 ​ */ ​ public double getBalance() { ​ return balance; ​ } } 按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。当然也可以使用Semaphore或CountdownLatch来实现同步。 编写多线程程序有几种实现方式？答：Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class MyTask implements Callable { ​ private int upperBounds; ​ public MyTask(int upperBounds) { ​ this.upperBounds = upperBounds; ​ } ​ @Override ​ public Integer call() throws Exception { ​ int sum = 0; ​ for(int i = 1; i &lt;= upperBounds; i++) { ​ sum += i; ​ } ​ return sum; ​ } } class Test { ​ public static void main(String[] args) throws Exception { ​ List&lt;Future&gt; list = new ArrayList&lt;&gt;(); ​ ExecutorService service = Executors.newFixedThreadPool(10); ​ for(int i = 0; i &lt; 10; i++) { ​ list.add(service.submit(new MyTask((int) (Math.random() * 100)))); ​ } ​ int sum = 0; ​ for(Future future : list) { ​ // while(!future.isDone()) ; ​ sum += future.get(); ​ } ​ System.out.println(sum); ​ } } synchronized关键字的用法？答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。在第60题的例子中已经展示了synchronized关键字的用法。 举例说明同步和异步。答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 启动一个线程是调用run()还是start()方法？答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 什么是线程池（thread pool）？ 答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 第60题的例子中演示了通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。 线程的基本状态以及状态之间的关系？答： 说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。 简述synchronized 和java.util.concurrent.locks.Lock的异同？答：Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。 Java中如何实现序列化，有什么意义？答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。 Java中有几种类型的流？ 答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。 面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案） import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public final class MyUtil { ​ private MyUtil() { ​ throw new AssertionError(); ​ } ​ public static void fileCopy(String source, String target) throws IOException { ​ try (InputStream in = new FileInputStream(source)) { ​ try (OutputStream out = new FileOutputStream(target)) { ​ byte[] buffer = new byte[4096]; ​ int bytesToRead; ​ while((bytesToRead = in.read(buffer)) != -1) { ​ out.write(buffer, 0, bytesToRead); ​ } ​ } ​ } ​ } ​ public static void fileCopyNIO(String source, String target) throws IOException { ​ try (FileInputStream in = new FileInputStream(source)) { ​ try (FileOutputStream out = new FileOutputStream(target)) { ​ FileChannel inChannel = in.getChannel(); ​ FileChannel outChannel = out.getChannel(); ​ ByteBuffer buffer = ByteBuffer.allocate(4096); ​ while(inChannel.read(buffer) != -1) { ​ buffer.flip(); ​ outChannel.write(buffer); ​ buffer.clear(); ​ } ​ } ​ } ​ } } 注意：上面用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。 写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。答：代码如下： import java.io.BufferedReader; import java.io.FileReader; public final class MyUtil { ​ // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) ​ private MyUtil() { ​ throw new AssertionError(); ​ } ​ /** ​ * 统计给定文件中给定字符串的出现次数 ​ * ​ * @param filename 文件名 ​ * @param word 字符串 ​ * @return 字符串在文件中出现的次数 ​ */ ​ public static int countWordInFile(String filename, String word) { ​ int counter = 0; ​ try (FileReader fr = new FileReader(filename)) { ​ try (BufferedReader br = new BufferedReader(fr)) { ​ String line = null; ​ while ((line = br.readLine()) != null) { ​ int index = -1; ​ while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) { ​ counter++; ​ line = line.substring(index + word.length()); ​ } ​ } ​ } ​ } catch (Exception ex) { ​ ex.printStackTrace(); ​ } ​ return counter; ​ } } 如何用Java代码列出一个目录下所有的文件？答：如果只要求列出当前文件夹下的文件，代码如下所示： import java.io.File; class Test12 { ​ public static void main(String[] args) { ​ File f = new File(“/Users/Hao/Downloads”); ​ for(File temp : f.listFiles()) { ​ if(temp.isFile()) { ​ System.out.println(temp.getName()); ​ } ​ } ​ } } 如果需要对文件夹继续展开，代码如下所示： import java.io.File; class Test12 { ​ public static void main(String[] args) { ​ showDirectory(new File(“/Users/Hao/Downloads”)); ​ } ​ public static void showDirectory(File f) { ​ _walkDirectory(f, 0); ​ } ​ private static void _walkDirectory(File f, int level) { ​ if(f.isDirectory()) { ​ for(File temp : f.listFiles()) { ​ _walkDirectory(temp, level + 1); ​ } ​ } ​ else { ​ for(int i = 0; i &lt; level - 1; i++) { ​ System.out.print(“\\t”); ​ } ​ System.out.println(f.getName()); ​ } ​ } } 在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示： class ShowFileTest { ​ public static void main(String[] args) throws IOException { ​ Path initPath = Paths.get(“/Users/Hao/Downloads”); ​ Files.walkFileTree(initPath, new SimpleFileVisitor() { ​ @Override ​ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) ​ throws IOException { ​ System.out.println(file.getFileName().toString()); ​ return FileVisitResult.CONTINUE; ​ } ​ }); ​ } } 用Java的套接字编程实现一个多线程的回显（echo）服务器。 答： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; public class EchoServer { ​ private static final int ECHO_SERVER_PORT = 6789; ​ public static void main(String[] args) { ​ try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) { ​ System.out.println(“服务器已经启动…”); ​ while(true) { ​ Socket client = server.accept(); ​ new Thread(new ClientHandler(client)).start(); ​ } ​ } catch (IOException e) { ​ e.printStackTrace(); ​ } ​ } ​ private static class ClientHandler implements Runnable { ​ private Socket client; ​ public ClientHandler(Socket client) { ​ this.client = client; ​ } ​ @Override ​ public void run() { ​ try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); ​ PrintWriter pw = new PrintWriter(client.getOutputStream())) { ​ String msg = br.readLine(); ​ System.out.println(“收到” + client.getInetAddress() + “发送的: “ + msg); ​ pw.println(msg); ​ pw.flush(); ​ } catch(Exception ex) { ​ ex.printStackTrace(); ​ } finally { ​ try { ​ client.close(); ​ } catch (IOException e) { ​ e.printStackTrace(); ​ } ​ } ​ } ​ } } 注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; import java.util.Scanner; public class EchoClient { ​ public static void main(String[] args) throws Exception { ​ Socket client = new Socket(“localhost”, 6789); ​ Scanner sc = new Scanner(System.in); ​ System.out.print(“请输入内容: “); ​ String msg = sc.nextLine(); ​ sc.close(); ​ PrintWriter pw = new PrintWriter(client.getOutputStream()); ​ pw.println(msg); ​ pw.flush(); ​ BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); ​ System.out.println(br.readLine()); ​ client.close(); ​ } } 如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。 import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; public class EchoServerNIO { ​ private static final int ECHO_SERVER_PORT = 6789; ​ private static final int ECHO_SERVER_TIMEOUT = 5000; ​ private static final int BUFFER_SIZE = 1024; ​ private static ServerSocketChannel serverChannel = null; ​ private static Selector selector = null; // 多路复用选择器 ​ private static ByteBuffer buffer = null; // 缓冲区 ​ public static void main(String[] args) { ​ init(); ​ listen(); ​ } ​ private static void init() { ​ try { ​ serverChannel = ServerSocketChannel.open(); ​ buffer = ByteBuffer.allocate(BUFFER_SIZE); ​ serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); ​ serverChannel.configureBlocking(false); ​ selector = Selector.open(); ​ serverChannel.register(selector, SelectionKey.OP_ACCEPT); ​ } catch (Exception e) { ​ throw new RuntimeException(e); ​ } ​ } ​ private static void listen() { ​ while (true) { ​ try { ​ if (selector.select(ECHO_SERVER_TIMEOUT) != 0) { ​ Iterator it = selector.selectedKeys().iterator(); ​ while (it.hasNext()) { ​ SelectionKey key = it.next(); ​ it.remove(); ​ handleKey(key); ​ } ​ } ​ } catch (Exception e) { ​ e.printStackTrace(); ​ } ​ } ​ } ​ private static void handleKey(SelectionKey key) throws IOException { ​ SocketChannel channel = null; ​ try { ​ if (key.isAcceptable()) { ​ ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); ​ channel = serverChannel.accept(); ​ channel.configureBlocking(false); ​ channel.register(selector, SelectionKey.OP_READ); ​ } else if (key.isReadable()) { ​ channel = (SocketChannel) key.channel(); ​ buffer.clear(); ​ if (channel.read(buffer) &gt; 0) { ​ buffer.flip(); ​ CharBuffer charBuffer = CharsetHelper.decode(buffer); ​ String msg = charBuffer.toString(); ​ System.out.println(“收到” + channel.getRemoteAddress() + “的消息：” + msg); ​ channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); ​ } else { ​ channel.close(); ​ } ​ } ​ } catch (Exception e) { ​ e.printStackTrace(); ​ if (channel != null) { ​ channel.close(); ​ } ​ } ​ } } import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.charset.CharacterCodingException; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import java.nio.charset.CharsetEncoder; public final class CharsetHelper { ​ private static final String UTF_8 = “UTF-8”; ​ private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); ​ private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); ​ private CharsetHelper() { ​ } ​ public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException{ ​ return encoder.encode(in); ​ } ​ public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException{ ​ return decoder.decode(in); ​ } } XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？答：XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 你在项目中哪些地方用到了XML？ 答：XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。 补充：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。 UML什么是UML？答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。 UML中有哪些常用的图？答：UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 用例图：类图：时序图： RMI（远程方法调用）什么是RMI？Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。 RMI体系结构的基本原则是什么？RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。 RMI体系结构分哪几层？RMI体系结构分以下几层： 存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。 远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。 传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 RMI中的远程接口(Remote Interface)扮演了什么样的角色？远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 java.rmi.Naming类扮演了什么样的角色？java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。 RMI的绑定(Binding)是什么意思？绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。 Naming类的bind()和rebind()方法有什么区别？bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 让RMI程序能正确运行有哪些步骤？为了让RMI程序能正确运行必须要包含以下几个步骤： 编译所有的源文件。 使用rmic生成stub。 启动rmiregistry。 启动RMI服务器。 运行客户端程序。 RMI的stub扮演了什么样的角色？远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤： 初始化到包含了远程对象的JVM的连接。 序列化参数到远程的JVM。 等待方法调用和执行的结果。 反序列化返回的值或者是方法没有执行成功情况下的异常。 把值返回给调用者。 什么是分布式垃圾回收(DGC)？它是如何工作的？DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。 Object类Object 类中有哪些方法？作用是什么？在 object 类中有 11 个方法，分别是： clone() //创建并返回此对象的副本 equals(Object obj) //指示一些其他对象是否等于此。 finalize() //当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。 getClass() //返回此 Object的运行时类。 hashCode() //返回对象的哈希码值。 notify() //唤醒正在等待对象监视器的单个线程。 notifyAll() //唤醒正在等待对象监视器的所有线程。 toString() //返回对象的字符串表示形式。 wait() //导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。 wait(long timeout) //导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过。 wait(long timeout, int nanos) //导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，或一定量的实时时间。 ### ### ###","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 主类结构","date":"2018-08-06T08:35:18.000Z","path":"2018/08/06/Java-主类结构/","text":"Java 语言是面向对象的程序设计语言，Java 程序的基本组成单元是类类体中又包括属性与方法两部分。 每一个应用程序都必须包含一个 main() 方法，含有 main()方法的类被称为主类。 12345678910111213141516package com.darklovy.Number;public class First &#123; private static String s1 = &quot;你好&quot;; public static void main(String[] args) &#123; String s2 = &quot;Java&quot;; //测试 System.out.println(s1); System.out.println(s2); &#125;&#125;运行结果：你好Java 包声明一个 Java 应用程序是由若干个类组成的，在上面的例子中 package com.darklovy.Number; 声明该类所在的包。package为包的关键字。 声明成员变量和局部变量 全局变量：通常将类的属性成为类的全局变量 局部变量：方法中的属性成为局部变量。 全局变量声明在类体中，局部变量声明在方法体中，全局变量和局部变量都有各自的生命周期或者说是应用范围 编写主方法main()方法是类体中的主方法。该方法从 { 到 } 结束。public static void分别是 main()方法的权限修饰符、静态修饰符和返回值修饰符。 Java 程序中的 main()方法必须声明为 public static void Stirng[] args是一个字符串类型的数组，它是 main()方法的参数。main()方法是程序开始执行的位置。 导入 API 类库在 Java 语言中可以通过 import关键字导入相关的库。 Java 语言是严格区分大小写的。例如，不能将关键字 class 等同于 Class 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"eclipse 安装与配置","date":"2018-08-06T08:30:33.000Z","path":"2018/08/06/eclipse-安装与配置/","text":"下载链接： http://www.eclipse.org/downloads/eclipse-packages/ eclipse配置 123456789101112131. 配置工作空间的编码格式 window -&gt; preference -&gt; General -&gt; Workspace -&gt; Text File encoding2. eclipse 配置 Tomcat 服务器 window -&gt; preference -&gt; server -&gt; Runtime environment -&gt; add3. Java 代码自动提示 Window &gt; Preferences &gt; Java &gt; Editor &gt; Content Assist “Auto Activation triggers for java”这个选项就是指触发代码提示的的选项， 把“.”修改成&quot;.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;4. XML 代码自动提示 Window &gt; Preferences &gt; Xml &gt; Xml Files &gt; Editor &gt; Content Assist &gt; Auto activation &gt; Prompt when these characters are inserted ，设置框中默认是 &lt;=: ， 改为： &lt;=:.abcdefghijklmnopqrstuvwxyz(, 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"java JDK 安装与配置","date":"2018-08-05T10:53:35.000Z","path":"2018/08/05/java-JDK-安装与配置/","text":"JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 注意： 121. 电脑的系统版本X86（32位系统）、X86_X64（64系统）2. 安装JDK的目录最好不要有中文目录，或者带有特殊符号的目录 双击安装包，选择安装安装JDK的目录即可开始安装。 配置JDK的环境变量1234567系统环境变量： JAVA_HOME：JDK安装的根目录 Path：%JAVA_HOME%\\bin;java -version:显示安装JDK的版本号，JDK的环境配置成功JDK java开发套件 javac.exejre java的运行环境，没有编译源文件的执行程序（javac.exe） 编写一个测试案例12编译：javac 源文件.java执行：java 类名 在 F:\\projects\\eclipse-workspace 目录下新建 Hello.java 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;This is a java Application.&quot;); &#125;&#125; 打开控制台 12345C:\\Users\\ttxxl&gt;F:F:\\&gt;cd F:\\projects\\eclipse-workspaceF:\\projects\\eclipse-workspace&gt;javac Hello.javaF:\\projects\\eclipse-workspace&gt;java HelloThis is a java Application. 如果正常编译和执行Hello输出，代表JDK环境安装成功。 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 语言特性","date":"2018-08-05T10:52:26.000Z","path":"2018/08/05/Java-语言特性/","text":"本文简单的介绍了 Java 语言的特性。 简单Java 语言的语法简单明了，容易掌握，而且是纯面向对象的语言。 语法规则类似于 C++， C程序设计人员可以很容易地掌握 Java 语言的语法。 Java 语言对 C++ 进行了简化和提高。使用接口取代了多重继承、取消了指针、实现了垃圾自动回收，简化程序员的资源释放管理工作。 Java 提供了丰富的类库和 API 文档以及第三方开发包，还有大量的开源项目。 面向对象面向对象是 Java 语言的基础，也是 Java 语言的重要特性，它本身就是一种纯面向对象的程序设计语言。Java 提倡万物皆对象，语法汇总不能在类外面定义单独的数据和函数。Java 语言最外部的数据类型就是对象，所有的元素都要通过类和对象类访问。 分布性Java 的分布包括操作分布和数据分布，其中操作分布是指在多个不同的主机上布置相关操作，而数据分布是将数据分别存放在多个不同的主机上，这些主机是网路中的不同成员。Java可以凭借 URL（统一资源定位符）对象访问网络对象，访问方式与访问本地系统相同。 可移植性Java 程序具有与体系结构无关的特性，可以很方便地一直到网络上的不同计算机中。同时，Java 的类库中也实现了针对不同平台的接口。使这些类库可以移植。 解释型运行 Java 程序需要解释器，任何移植了 Java 解释器的计算机或其他设备都可以用 Java 字节码进行解释执行，字节码独立于平台，它本身携带了许多编译时的信息，使得连接过程更加简单，开发过程更加迅速，更具探索性、 安全性Java 语言删除了类似 C 语言中的指针和内存释放等语法，有效地避免了非法操作内存、Java 程序代码要经过代码校验、指针校验等很多测试步骤才能够运行，所以未经允许的 Java 程序不可能出现损害系统平台的行为，而且使用 Java 可以编写防病毒和防修改的系统。 健壮性Java 程序的设计目标之一，是编写多方面的、可靠的应用程序，Java 将检查程序在编译和运行时的错误，并消除错误、类型检查能帮助用户检查出许多在开发早期出现的错误。集成开发工具的出现也使编译和运行 Java 程序更加容易。 多线程多线程能够使应用程序在同一时间并行执行多项任务，而且相应的同步机制可以保证不同线程能够正确地共享数据，使用多线程，可以带来更好的交互能力和实时能力。 高性能Java 编译后的字节码实在解释器中运行的，所以它的速度较多数交互式应用程序提高了很多。另外，字节码可以程序运行时被翻译成特定平台的机器指令，从而进一步提高运行速度。 动态Java 可以动态调整库中方法和增加变量，而客户端却不需要任何更改。在 Java 中进行动态调整是非常简单和直接的。 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"Java 简介","date":"2018-08-05T09:36:43.000Z","path":"2018/08/05/Java-简介/","text":"Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 Java分为三个体系： Java SE(Java2 Platform Standard Edition，java平台标准版) Java EE (Java 2 Platform,Enterprise Edition，java平台企业版) Java ME(Java 2 Platform Micro Edition，java平台微型版)。 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字”2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 Java 应用领域借助于 Java，程序开发人员可以自由地使用现有的硬件和软件系统平台。因为 Java 是独立于平台的，它还可以应用于计算机之外的领域，Java 程序可以在便携式计算机、电视、电话、手机和其他的大量电子设备上运行。 Java 的应用领域主要有以下几个方面： 桌面应用系统开发 嵌入式系统开发 电子商务应用 企业级应用开发 交互式系统开发 多媒体系统开发 分布式系统开发 Web 应用系统开发 Java 无处不在，其发展速度要快于在它之前的任何一种计算机语言。 Java 版本自从 Sun 公司推出 Java 以来，就力图使之无所不能。Java 发展至今，按照应用范围可分为 3 个版本。 Java SE Java SE 是 Java 的标准版，主要用于桌面应用程序的开发，同时也是 Java 的基础，它包含 Java 语言基础，JDBC（Java 数据库连接性）操作、I/O（输入/输出、网络通信、多线程等技术。 Java EE Java EE 是 Java 的企业版，主要用于开发企业级分布式的网络程序，如电子商务网站和ERP（企业资源规划）系统，其核心为 EJB（企业 Java 组件模型）。 Java ME Java ME 主要用于嵌入式系统开发，如掌上电脑，手机等移动电子设备，现在大部分手机厂商所生产的手机都支持Java 技术。 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[{"name":"Java","slug":"Java","permalink":"https://www.ttxxly.top/tags/Java/"}]},{"title":"hexo的安装与配置","date":"2018-08-02T15:18:20.000Z","path":"2018/08/02/hexo的安装与配置/","text":"本文主要介绍在 github pages 和 Coding pages 上搭建 Hexo 博客以及相关配置优化等. 123456789101112131415161718192021安装流程： 1. 安装Node.js 2. 安装Git → 安装Hexo 3. 安装主题 4. 本地测试运行 5. 在github与coding上创建pages仓库 6. 部署到远程仓库中 7. 自定义域名访问配置与优化 1. 添加标签页面 2. 添加分类页面 3. 添加自定义页面 4. 文章末尾追加版权信息 5. 开启打赏功能 6. 友情链接 7. 自定义字体 8. 自定义图标和侧栏头像 9. 添加 Rss 订阅 10. MathJax支持错误解决 1. 关于网站图标不更新问题 安装HexoNode.js、GIt安装 参考 https://hexo.io/zh-cn/docs/index.html安装hexo 打开 git bash 输入以下命令 1npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，请特别的注意看注释。 1234hexo init &lt;folder&gt; #folder指我们要安装的博客根目录 #hexo init blog 指的是在当前文件夹下新建blog目录作为博客的根目录cd &lt;folder&gt;npm install #安装所有的依赖包 安装主题 将主题文件拷贝至站点目录的 themes 目录下 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改配置文件打开 站点配置文件， Ctrl +F 搜索 theme 字段，并将其值更改为 next如果显示的是繁体中文，那么在站点配置文件中设置 language: zh-CN 本地预览 12hexo g # 等同于hexo generate，生成静态文件hexo s # 等同于hexo server，在本地服务器运行 打开浏览器输入 http://localhost:4000 能够访问说明部署成功。 注册 Github 并创建Pages 在 https://github.com/ 上面注册一个账号 新建仓库，仓库名为你账号用户名.github.io 设置 SSH 远程连接 设置Git的user name和email：(如果是第一次的话) 12git config --global user.name &quot;ttxxly&quot;git config --global user.email &quot;ttxxly@gmail.com&quot; 生成密钥 1ssh-keygen -t rsa -C &quot;humingx@yeah.net&quot; 连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。复制 id_rsa.pub内容到github上。 部署到 github在 博客的配置文件（不是主题配置文件） _config.yml 中 末尾添加 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:ttxxly/ttxxly.github.io.git,master coding: git@git.coding.net:ttxxly/ttxxly.coding.me.git,master 再然后打开 Git bash 输入 hexo d 就是可以提交内容到GitHub上，然后就可以通过仓库名ttxxly.github.io来访问。 自定义域名访问 在 blog\\source目录下新建 CNAME文件 12#### 在 CNAME 文件 中 填写自定义域名, 格式如下ttxxly.top 配置与优化添加标签页面123456/*必看！！！！ 确认站点配置文件_config.yml中有： tag_dir： tags （有注释的去掉注释） 确认主题配置文件_config.yml中有： tags: /tags*/hexo new page \"tags\" 编辑站点中 source/tags/index.md 文件： 123title: tagsdate: 2017-3-16 14:08:51type: \"tags\" 如果站点启用多说或者Disqus，会在默认页面添加评论，关闭评论那么还需要添加: 1comments： false 添加分类页面12345/*确认站点配置文件里有 category_dir: categories确认主题配置文件里有 categories: /categories*/hexo new page \"categories\" 编辑站点的 source/categories/index.md 文件： 123title: categoriesdate: 2015-10-20 06:49:50type: \"categories\" 如果站点启用多说或者Disqus，会在默认页面添加评论，关闭评论那么还需要添加: 1comments： false 添加自定义页面1hexo new page \"title\" 如果你不想在该页面显示评论，那么我们需要打开 blog\\source\\logs\\index.md 在date的 下一行添加 comments: false(注意冒号后面有一个空格) 找到 \\next\\_config.yml 下的 menu ， 把 title 加进去。 然后在下面 menu_icons 中加入你想让其显示的图标图标传送 在 /themes/hexo-theme-next/languages/zh-Hans.yml 文件中（这里默认你使用的是简体中文，若是其他语言更改相应的yml就行），在 memu 下加一句即可： 1title: 标题 文章末尾追加版权信息打开 themes/next/layout/_macro/reward.swig ，在最上面添加如下代码： 12345678910111213&lt;div align=\"center\"&gt; &#123;% if not is_index %&#125; &lt;div class=\"\"&gt; &lt;p&gt; &lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt; &lt;a href=\"&#123;&#123; url_for(page.path) &#125;&#125;\" title=\"&#123;&#123; page.title &#125;&#125;\"&gt;&#123;&#123; url_for(page.path) &#125;&#125;&lt;/a&gt; &lt;br/&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 开启打赏功能在 主题配置文件 中： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechat-reward.pngalipay: /images/alipay-reward.jpg 友情链接在 主题配置文件 中 实例： 12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 自定义字体http://theme-next.iissnan.com/theme-settings.html#fonts-customization 12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 官方文档：自定义字体 在 source/css/_variables/custom.styl 文件中 1234567891011121314// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族 如果不生效 请在同目录下的 base.style 下 修改成你期望的字体族$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif// 代码字体$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 13px 注：上面的那种方式是更改首选字体，下面的方式会覆盖上面的那一种方式 自定义图标和侧栏头像图标：在 source 目录下，放图标文件，命名为 favicon.ico侧栏头像： 编辑 站点配置文件 _config.yml ，新增字段 avatar，值设置成头像的链接地址。 1234567其中，头像的链接地址可以是：完整的互联网 URL，例如：https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460站点内的地址，例如：/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。 添加RSS订阅安装订阅插件： 1npm install hexo-generator-feed 编辑网站根目录下的 _config.yml，添加以下代码开启 123456789# RSS订阅支持plugin:- hexo-generator-feed# Feed Atomfeed:type: atompath: atom.xmllimit: 20 将订阅添加到菜单栏中 找到 \\next\\_config.yml 下的 menu ， 把 rss 加进去。 123menu: home: / rss: 然后在下面 menu_icons 中加入你想让其显示的图标图标传送 1234menu_icons: logs: th-list projects: ra rss: rss 在 /themes/hexo-theme-next/languages/zh-Hans.yml 文件中（这里默认你使用的是简体中文，若是其他语言更改相应的yml就行），在 memu 下加一句即可： 12345678910111213menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 logs: 日志 projects: 项目 rss: 订阅 MathJax支持https://github.com/hexojs/hexo-math 错误解答关于网站图标不更新问题可以查看下GitHub网站上图标是否更新，因为git提交时忽略大小写的，可能文件没有更新，先将图标文件删除，在重新上传就可以了。 感兴趣的话可以点击下面的链接，关注我的微信公众号和我的知识星球。 https://www.ttxxly.top/images/qrcode_darklovy.jpg https://www.ttxxly.top/images/qrcode_ttxxly123.jpg https://www.ttxxly.top/images/ZSXQ_darklovy.png","tags":[]}]