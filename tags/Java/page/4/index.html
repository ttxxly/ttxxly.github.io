<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Tag: Java | Darklovy</title>
  <meta name="description" content>
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="Darklovy">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Darklovy">
<meta property="og:url" content="https://www.ttxxly.top/tags/Java/page/4/index.html">
<meta property="og:site_name" content="Darklovy">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Darklovy">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				Darklovy
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN'>
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : Java'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2019/01/01/Java-类构造方法/">
        Java 类构造方法
      </a>
    </h2>
    
    <time>
      Jan 1, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <p>在 类 中除了成员方法之外，还存在一种特殊类型的方法，那就是构造方法。构造方法是一个与类同名的方法，对象的创建就是通过构造方法完成的。每当类实例化一个对象时，类都会自动覅用构造方法。</p>
<p>构造方法的特点如下：</p>
<ul>
<li>构造方法没有返回值</li>
<li>构造方法的名称要与本类的名称相同</li>
</ul>
<blockquote>
<p>在定义构造方法时，构造方法没有返回值，但这与普通美哦与返回值的方法不同，普通没有返回值的方法使用 public void methodEx() 这种形式进行定义，但构造方法并不需要使用 void 关键字进行修饰。</p>
</blockquote>
<p>构造方法的定义语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">book</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//构造方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyThting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnyThting</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"this 调用有参构造方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"无参构造方法"</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnyThting</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参构造方法"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="下面哪个选项的说法是正确的？"><a href="#下面哪个选项的说法是正确的？" class="headerlink" title="下面哪个选项的说法是正确的？"></a>下面哪个选项的说法是正确的？</h4><p>A. 构造函数不能被重载<br>B. 构造函数不能被覆盖<br>C. 一个构造函数可以返回一个私有的或一个对象的引用<br>D. 构造函数代码执行时是从当前的类层级到它祖先的类</p>
<p><strong>解析：</strong><br>重载构造函数是一个主要的技术，可以允许多种方式初始化一个类。<br>通过定义，构造函数是没有返回值的。所以选项C是错误的，这种说法并没有任何意义。<br>选项D中构造函数代码的执行是从它最老的祖先类开始向下执行调用。可以写一个继承一个基类的类来测试，当创建一个子类的时候，会发现它的祖先类的构造函数先被调用。<br><strong>答案：</strong> B</p>
<h4 id="下列有关派生类调用父类构造函数的描述中正确的是哪个？"><a href="#下列有关派生类调用父类构造函数的描述中正确的是哪个？" class="headerlink" title="下列有关派生类调用父类构造函数的描述中正确的是哪个？"></a>下列有关派生类调用父类构造函数的描述中正确的是哪个？</h4><p>A.派生类定义了自己的构造函数，就不会调用父类的构造函数<br>B.派生类必须通过super调用父类的含有参数的构造函数<br>C.派生类将会继承父类中所有的构造函数<br>D.创建派生类对象时，先调用派生类自己的构造函数，然后调用父类的构造函数</p>
<p><strong>解析：</strong><br>派生类被构造时一定会先调用父类的构造函数，排除选项A、D。<br>你可以选择调用哪个构造函数，可以决定调用哪一个，但不能都不调用（至少必选一个），排除选项C。<br>若不指定，就会调用无参数的构造函数，以下代码调用的是无参构造函数，得到 <code>A without any parameter B with a parameter</code>的结果。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"A without any parameter  "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"A with a parameter"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"B without any parameters.  "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"B with a parameter"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">  B a =<span class="keyword">new</span> B(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果选定调用A(int i)，则会得到A with a parameter B with a parameter的结果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"A without any parameter  "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"A with a parameter"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"B without any parameters.  "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(i);</span><br><span class="line">  System.out.println(<span class="string">"B with a parameter"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">  B a =<span class="keyword">new</span> B(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>答案：</strong> B</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2019/01/01/Java-this-和-super-关键字/">
        Java this 和 super 关键字
      </a>
    </h2>
    
    <time>
      Jan 1, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <p>本文大致介绍了 java 中的两个关键字，它们分别是 this 和 super。</p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this 是指向对象本身的一个指针。this 只能在类中的非静态方法中使用，静态方法 和静态代码中绝对不能出现 this 关键字。</p>
<h4 id="调用本类的构造方法"><a href="#调用本类的构造方法" class="headerlink" title="调用本类的构造方法"></a>调用本类的构造方法</h4><p>仅仅在类的构造函数中调用本类的其他构造函数。用法是 <code>this(参数列表)</code>,这一句必须处于构造函数的第一句，同时一个构造函数内部只能调用另一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"无参数构造函数！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>);<span class="comment">//调用参数为int型的构造函数</span></span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表示类中属性和方法"><a href="#表示类中属性和方法" class="headerlink" title="表示类中属性和方法"></a>表示类中属性和方法</h4><p>用this来访问类中的属性和方法。比如函数参数或者参数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用”this.成员变量名”来访问成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">        System.out.print(x);<span class="comment">//打印2</span></span><br><span class="line">        System.out.print(<span class="keyword">this</span>.x);<span class="comment">//打印1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表示当前对象"><a href="#表示当前对象" class="headerlink" title="表示当前对象"></a>表示当前对象</h4><p>在函数中，需要引用该函数所属类的当前对象时候，直接使用this。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        C c1 = <span class="keyword">new</span> C();</span><br><span class="line">        c1.tell();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>);<span class="comment">//打印当前对象的字符串表示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匿名类和内部类"><a href="#匿名类和内部类" class="headerlink" title="匿名类和内部类"></a>匿名类和内部类</h4><p>在匿名类或者内部类中用this时，这个this指的是匿名类或内部类本身。这是如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。</p>
<p><strong>例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Hello.<span class="keyword">this</span>.run();<span class="comment">//调用外部类的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//这里有分号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><blockquote>
<p>super关键和this作用类似，是使被屏蔽的成员变量或者成员方法变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。</p>
</blockquote>
<h4 id="在子类构造方法中调用父类的构造方法"><a href="#在子类构造方法中调用父类的构造方法" class="headerlink" title="在子类构造方法中调用父类的构造方法"></a>在子类构造方法中调用父类的构造方法</h4><p>用super(参数列表)的方式调用，参数不是必须的。同时，还要注意super(参数列表)这条语句只能在子类构造方法中的第一行 。</p>
<p><strong>例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//调用父类构造方法，打印A</span></span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="访问父类中被覆盖的同名变量或者方法"><a href="#访问父类中被覆盖的同名变量或者方法" class="headerlink" title="访问父类中被覆盖的同名变量或者方法"></a>访问父类中被覆盖的同名变量或者方法</h4><p>当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类变量覆盖同名父类变量时，可以使用super.成员变量名引用父类成员变量。同时，若子类的成员方法覆盖了父类的成员方法时，也可以使用super.方法名(参数列表)的方式访问父类的方法。</p>
<p><strong>例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//可以直接赋值，不用通过构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">super</span>.a);<span class="comment">//访问父类的a变量，前提是父类的a变量是公有的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();<span class="comment">//调用父类的say()方法而不是子类的say()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2019/01/01/Java-局部变量以及它的有效范围/">
        Java 局部变量以及它的有效范围
      </a>
    </h2>
    
    <time>
      Jan 1, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <p>局部变量是在方法被执行时创建，在方法执行结束时被销毁。局部变量在使用时必须进行赋值操作或被初始化，否则会出现编译错误。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span> ;    <span class="comment">//局部变量</span></span><br><span class="line">    setName(<span class="string">"Java"</span>);</span><br><span class="line">    <span class="keyword">return</span> id + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将 id 这个局部变量的初始值去掉，编译器将出现错误。</p>
<h3 id="局部变量的有效范围"><a href="#局部变量的有效范围" class="headerlink" title="局部变量的有效范围"></a>局部变量的有效范围</h3><p>可以将局部变量的有效范围称为变量的作用域，局部变量的有效范围从该变量的声明开始到该变量的结束为止。</p>
<p><strong>在作用范围外使用局部变量是一个常见的错误，因为在作用域外没有声明局部变量的代码</strong> </p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2019/01/01/Java-修饰符/">
        Java 修饰符
      </a>
    </h2>
    
    <time>
      Jan 1, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <p>Java 语言提供了很多修饰符，主要分为以下两类：</p>
<ul>
<li>访问修饰符</li>
<li>非访问修饰符</li>
</ul>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>在 Java 中有以下四种访问修饰符。</p>
<ul>
<li><code>public</code></li>
<li><code>protected</code></li>
<li><code>default</code></li>
<li><code>private</code></li>
</ul>
<h4 id="public-公有访问修饰符"><a href="#public-公有访问修饰符" class="headerlink" title="public - 公有访问修饰符"></a><code>public</code> - 公有访问修饰符</h4><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>
<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。</p>
<p>由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<p>以下函数使用了公有访问控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arguments)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 程序的 <code>main()</code> 方法必须设置成公有的，否则 java 解释器将不能运行该类。</p>
<h4 id="protected-受保护的访问修饰符"><a href="#protected-受保护的访问修饰符" class="headerlink" title="protected - 受保护的访问修饰符"></a><code>protected</code> - 受保护的访问修饰符</h4><p><code>protected</code> 需要从以下两个点来分析说明</p>
<ul>
<li><p>子类与基类在同一包中：被声明为 <code>protected</code> 的变量、方法和构造器能被同一个包中的任何其他类访问。</p>
</li>
<li><p>子类与基类不在同一包中：子类实例可以访问其从基类继承而来的 <code>protected</code> 方法，而不能访问基类实例的 <code>protected</code> 方法。</p>
</li>
</ul>
<p><code>protected</code> 可以修饰数据成员、构造方法、方法成员，<strong>不能修饰类（内部类除外）</strong></p>
<p><strong>接口以及接口的成员变量和成员方法不能声明为 <code>protected</code></strong></p>
<h4 id="默认访问修饰符-不使用关键字"><a href="#默认访问修饰符-不使用关键字" class="headerlink" title="默认访问修饰符 - 不使用关键字"></a>默认访问修饰符 - 不使用关键字</h4><p>使用默认访问修饰符声明的变量和方法，对同一个包的类是可见的。</p>
<p>接口里的变量都隐式声明为 <code>public static final</code> ，而接口里的方法默认情况下访问权限为 <code>public</code>.</p>
<h4 id="private-私有访问修饰符"><a href="#private-私有访问修饰符" class="headerlink" title="private - 私有访问修饰符"></a><code>private</code> - 私有访问修饰符</h4><p>私有访问修饰符是最严格的访问级别，被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>
<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>
<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4><p>方法继承规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能， java 也提供了许多非访问修饰符。</p>
<ul>
<li><code>static</code> 修饰符</li>
<li><code>final</code> 修饰符</li>
<li><code>abstract</code> 修饰符</li>
<li><code>synchronized</code> 修饰符</li>
<li><code>volatile</code> 修饰符</li>
<li>….</li>
</ul>
<h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a><code>static</code> 修饰符</h4><ul>
<li>静态变量：<br>  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为 static 变量</li>
<li>静态方法<br>  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。</li>
</ul>
<h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><ul>
<li>final 变量：<br>  变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</li>
<li>final 方法：<br>  类中的 final 方法可以被子类继承，但是不能被子类修改。<br>  声明 final 方法的主要目的是防止该方法的内容被修改。</li>
<li>final 类：<br>  final 类不能被继承，没有类能够继承 final 类的任何特性。</li>
</ul>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/28/Java-变量与常量/">
        Java 变量与常量
      </a>
    </h2>
    
    <time>
      Oct 28, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <p>在程序执行过程中，其值不能被改变的量称为常量，其值能被改变的量被称为变量。变量与常量的命名都必须使用合法的标识符。</p>
<h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符可以简单地理解为一个名字，用来标识类名、方法名、数组名、文件名的有效字符序列。</p>
<p><strong>Java 语言规定标识符由任意顺序的字母、下划线、美元符号和数字组成，并且第一个字符不能是数字。</strong><br><strong>标识符不能是 Java 中的保留字，并且在 Java 语言中的字母是严格区分大小写的。</strong></p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>关键字是 Java 语言中已经被赋予特定意义的一些单词，不可以把这些字作为标识符来使用。</p>
<p><img src="/images/2018-10-28/1.png" alt></p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>变量饿使用是程序谁中一个十分重要的环；。定义变量就是要告诉编译器（compiler）这个变量的数据类型，这样编译器才知道许哟啊配置多少空间给它，以及它能够存储怎样的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">char</span> char1 = <span class="string">'Y'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>对变量的命名，应该遵循下面的规则</strong></p>
<ul>
<li>变量名必须是一个有效的标识符</li>
<li>变量名不能重复</li>
<li>变量名应该是有意义的</li>
</ul>
<p><em>注：在 Java 语言中是允许使用汉字或其他语言文字作为变量名，但不建议这样做。</em></p>
<h3 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h3><p>在程序运行过程中一直不会改变的量称为常量（constant），通常也称为 “final 变量”。常量在整个程序中通常只能被赋值一次。在为所有的对象共享值时，常量时非常有用的。</p>
<h4 id="声明常量的标准语言以及例子"><a href="#声明常量的标准语言以及例子" class="headerlink" title="声明常量的标准语言以及例子"></a>声明常量的标准语言以及例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 数据类型 常量名称[=值];</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> p1 = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h3><p>由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，该变量会被释放掉，也就是说变量有它的生命周期。</p>
<p>按照变量的有效范围将变量分为成员变量和局部变量。</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>在类体中定义的变量被称为成员变量，成员变量在整个类中都有效。类的成员变量又可以分为静态变量和实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">var</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">45</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在成员变量的类型前面加上关键字 static 后，这样的变量就被称为静态变量。对于静态变量，除了能在定义它的类存取，还可以以“类名.静态变量”的方式在其他类中使用。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在类的方体中定义的变量称为局部变量。布局变量只在当前代码块中有效。</p>
<p>在类的方法中声明的变量，包括方法的参数，都属于局部变量。局部变量的生命周期取决于方法，当单发被调用时，Java 虚拟机为方法中的局部变量分配内存空间，当该方法的调用结束后，则会释放方法中局部变量占用的内存空间，局部变量也将会销毁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">val</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> times = <span class="number">3</span>;<span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">4</span>;<span class="comment">//定义局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"Times 的值为："</span>+times);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/26/Java-基本数据类型/">
        Java 基本数据类型
      </a>
    </h2>
    
    <time>
      Oct 26, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <p>在 Java 中有 8 种基本数据类型来存储数值、字符和布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数值型：</span><br><span class="line">    整数类型：<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">int</span>、<span class="keyword">long</span></span><br><span class="line">    浮点类型：<span class="keyword">float</span>、<span class="keyword">double</span></span><br><span class="line">字符型：<span class="keyword">char</span></span><br><span class="line">布尔型：<span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型用来存储整数数值，即没有小数部分的数值。可以是正数，也可以是负数。整数数据在<br>Java 程序中有 3 种表示方式，分别为 十进制、八进制和十六进制。</p>
<h4 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h4><p>十进制的表现形式是最常见的，如 120、0、-127.</p>
<p><em>注意：不能以 0 作为十进制数的开头（0 除外）</em></p>
<h4 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h4><p>如 0123（转换成十进制就是 83）、-0123（转换成十进制是 -83）。</p>
<p><em>注意：八进制必须以 0 开头</em></p>
<h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>如 0x25（转换成十进制数是 37）、0Xb1e（转换成十进制是 45086）</p>
<p><em>注意： 十六进制必须以 0X 或 0x 开头</em></p>
<p>整型数据根据它所占内存大小的不同，可分为 byte、short、int、long 4种类型，他们具有不同的取值范围，如下表所示。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存空间（8位=1字节）</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8位</td>
<td>-128～127</td>
</tr>
<tr>
<td>short</td>
<td>16位</td>
<td>-32768～32767</td>
</tr>
<tr>
<td>int</td>
<td>32位</td>
<td>-2147483648～2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64位</td>
<td>-9223372036854775808～9223372036854775807</td>
</tr>
</tbody>
</table>
<p>下面以 int 型变量为例讲解整型变量的定义。</p>
<h4 id="定义-int-型变量，示例代码如下："><a href="#定义-int-型变量，示例代码如下：" class="headerlink" title="定义 int 型变量，示例代码如下："></a>定义 int 型变量，示例代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//定义 int 型变量 x</span></span><br><span class="line"><span class="keyword">int</span> x,y;<span class="comment">//定义 int 型变量 x、y</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">450</span>, y = -<span class="number">463</span>; <span class="comment">//定义 int 型变量 x、y 并赋初值</span></span><br></pre></td></tr></table></figure>
<p><em>注意1：定义以上 4 种类型变量时，需要注意变量的取值范围，超出相应范围就会出错。</em><br><em>注意2: 对于 long 型数值，若赋的初值大于 int 型的最大值或小于 int 型的最小值，则需要在数值后加 L 或 l，表示该值是长整型，如 <code>long num = 2147483650L</code>。</em></p>
<h4 id="运算操作，输出和"><a href="#运算操作，输出和" class="headerlink" title="运算操作，输出和"></a>运算操作，输出和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> mybyte = <span class="number">124</span>;</span><br><span class="line">        <span class="keyword">short</span> myshort = <span class="number">32564</span>;</span><br><span class="line">        <span class="keyword">int</span> myint = <span class="number">45784612</span>;</span><br><span class="line">        <span class="keyword">long</span> mylong = <span class="number">4678951</span>;</span><br><span class="line">        <span class="keyword">long</span> result = mybyte + myshort + myint + mylong;</span><br><span class="line">        System.out.println(<span class="string">"结果为："</span>+ result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果为：</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">92606751</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型表示有小数部分的数字。Java 语言中浮点类型可分为单精度浮点类型（float）和双精度浮点型（double），它们具有不同的取值范围，如下表所示。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存空间（8位=1字节）</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32位</td>
<td>1.4E-45～3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64位</td>
<td>4.9E-324～1.797693234862315E308</td>
</tr>
</tbody>
</table>
<p>在默认情况下，小数都被看作是 double 型，若使用 float 型小数，则需要在小数后面加上F或f。</p>
<h4 id="定义浮点类型变量，示例代码如下："><a href="#定义浮点类型变量，示例代码如下：" class="headerlink" title="定义浮点类型变量，示例代码如下："></a>定义浮点类型变量，示例代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">13.23f</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">354.12</span>d;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">23456.2345</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><h4 id="char-型"><a href="#char-型" class="headerlink" title="char 型"></a>char 型</h4><p>字符类型（char）用于存储单个字符，占用 16 位（两个字节）的内存空间。在定义字符型变量时，要以单引号表示，如 <code>&#39;s&#39;</code> 表示一个字符，而 <code>&quot;s&quot;</code>则表示一个字符串。</p>
<p>使用 <code>char</code> 关键字可定义字符变量，下面举例说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">注意：字符 a 在 unicode 表中的排序位置是 <span class="number">97</span> ，所以上面的语句等同于：</span><br><span class="line"><span class="keyword">char</span> x = <span class="number">97</span>;</span><br></pre></td></tr></table></figure>
<p>同 c 和 C++ 语言一样，Java 语言也可以把字符作为整数对待。由于unicode 编码采用无符号编码，可以存储 65536 个字符（0x0000 ～ 0xffff），所以 Java 中的字符几乎可以处理所有国家的语言文字。</p>
<p><strong>在控制台输出 unicode 表中的字符以及在表中字符对应的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">gess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> word = <span class="string">'d'</span>, word2 = <span class="string">'@'</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">23045</span>, p2 = <span class="number">45213</span>;</span><br><span class="line">        System.out.println(<span class="string">"d 在 unicode 表中的顺序位置是："</span>+(<span class="keyword">int</span>)word);</span><br><span class="line">        System.out.println(<span class="string">"@ 在 unicode 表中的顺序位置是："</span>+(<span class="keyword">int</span>)word2);</span><br><span class="line">        System.out.println(<span class="string">"unicode 表中的第 23045 位是："</span>+(<span class="keyword">char</span>)p);</span><br><span class="line">        System.out.println(<span class="string">"unicode 表中的第 45213 位是："</span>+(<span class="keyword">char</span>)p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">d 在 unicode 表中的顺序位置是：<span class="number">100</span></span><br><span class="line">@ 在 unicode 表中的顺序位置是：<span class="number">64</span></span><br><span class="line">unicode 表中的第 <span class="number">23045</span> 位是：娅</span><br><span class="line">unicode 表中的第 <span class="number">45213</span> 位是： ?</span><br></pre></td></tr></table></figure>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>转义字符是一种特殊的字符变量，它以反斜杠 <code>&quot;\&quot;</code> 开头，后跟一个或多个字符。转义字符具有特殊的含义，不同于字符原有的意义，故称 “转义”。Java 中的转义字符如下表所示：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\ddd</td>
<td>1～3位八进制数所表示的字符，如\123</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>4 位十六进制数所表示的字符，如 \u0052</td>
</tr>
<tr>
<td>\’</td>
<td>单引号字符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠字符</td>
</tr>
<tr>
<td>\t</td>
<td>垂直制表符，将光标移动下一个制表符的位置</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
</tbody>
</table>
<p>将转义字符赋值给字符变量时，与字符常量值一样需要使用单引号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'\\'</span>;</span><br><span class="line"><span class="keyword">char</span> char1 = <span class="string">"\u2605"</span>;</span><br><span class="line">System.out.println(c1);</span><br><span class="line">System.out.println(char1);</span><br></pre></td></tr></table></figure>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型又称逻辑类型，通过关键值 boolean 来定义布尔类型变量。只有 true 和 false 两个值，它们分别代表布尔逻辑中的 真 和 假。</p>
<p>布尔类型不能与整数类型进行转换。布尔类型通常被用在流程控制中作为判断条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line"><span class="keyword">boolean</span> b1,b2;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/20/Java-面试题系列篇-编程大题/">
        Java 面试题系列篇-编程大题
      </a>
    </h2>
    
    <time>
      Oct 20, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="Java-编程题"><a href="#Java-编程题" class="headerlink" title="Java 编程题"></a>Java 编程题</h2><h3 id="如何读取eclipse中-src目录下的文件？至少两种"><a href="#如何读取eclipse中-src目录下的文件？至少两种" class="headerlink" title="如何读取eclipse中 src目录下的文件？至少两种"></a>如何读取eclipse中 src目录下的文件？至少两种</h3><p><a href="http://note.youdao.com/noteshare?id=f60ff6c6169c0f5211410a8ff3350000&amp;sub=8CA55EE3DA474C98A6C33F1988387FC6" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=f60ff6c6169c0f5211410a8ff3350000&amp;sub=8CA55EE3DA474C98A6C33F1988387FC6</a></p>
<h3 id="有两个list-集合怎么取无重复并集？"><a href="#有两个list-集合怎么取无重复并集？" class="headerlink" title="有两个list 集合怎么取无重复并集？"></a>有两个list 集合怎么取无重复并集？</h3><h3 id="如何将系统时间转化为-2017-5-28-格式？"><a href="#如何将系统时间转化为-2017-5-28-格式？" class="headerlink" title="如何将系统时间转化为 2017/5/28 格式？"></a>如何将系统时间转化为 2017/5/28 格式？</h3><p><a href="http://note.youdao.com/noteshare?id=b634c901a7b2739d3d9c439c57ce99b8&amp;sub=34424049F77F421E9249AE3622E4A8DE" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=b634c901a7b2739d3d9c439c57ce99b8&amp;sub=34424049F77F421E9249AE3622E4A8DE</a></p>
<h3 id="页面二级级联菜单如何实现？如-第一个下拉列表为省，第二个下拉列表为市。"><a href="#页面二级级联菜单如何实现？如-第一个下拉列表为省，第二个下拉列表为市。" class="headerlink" title="页面二级级联菜单如何实现？如 第一个下拉列表为省，第二个下拉列表为市。"></a>页面二级级联菜单如何实现？如 第一个下拉列表为省，第二个下拉列表为市。</h3><h3 id="请简述如何模拟实现-IOC-和-DI？-代码或者具体细节步骤？"><a href="#请简述如何模拟实现-IOC-和-DI？-代码或者具体细节步骤？" class="headerlink" title="请简述如何模拟实现 IOC 和 DI？ 代码或者具体细节步骤？"></a>请简述如何模拟实现 IOC 和 DI？ 代码或者具体细节步骤？</h3>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/20/Java-面试题系列篇-虚拟机/">
        Java 面试题系列篇-虚拟机
      </a>
    </h2>
    
    <time>
      Oct 20, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="虚拟机-（JVM）"><a href="#虚拟机-（JVM）" class="headerlink" title="虚拟机 （JVM）"></a>虚拟机 （JVM）</h2><h3 id="【JVM】你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？"><a href="#【JVM】你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？" class="headerlink" title="【JVM】你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？"></a>【JVM】<strong>你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？</strong></h3><p><a href="https://blog.csdn.net/chenleixing/article/details/46706039/" target="_blank" rel="noopener">https://blog.csdn.net/chenleixing/article/details/46706039/</a></p>
<h3 id="【JVM】Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机制是什么意思？有什么好处？"><a href="#【JVM】Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机制是什么意思？有什么好处？" class="headerlink" title="【JVM】Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机制是什么意思？有什么好处？"></a>【JVM】<strong>Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机制是什么意思？有什么好处？</strong></h3><p>启动Bootstrap类加载、扩展Extension类加载、系统System类加载。</p>
<p>父子关系如下：</p>
<p>启动类加载器 ，由C++ 实现，没有父类；</p>
<p>扩展类加载器，由Java语言实现，父类加载器为null；</p>
<p>系统类加载器，由Java语言实现，父类加载器为扩展类加载器；</p>
<p>自定义类加载器，父类加载器肯定为AppClassLoader。</p>
<p>双亲委派机制：类加载器收到类加载请求，自己不加载，向上委托给父类加载，父类加载不了，再自己加载。</p>
<p>优势避免Java核心API篡改。</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/73413292/" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/73413292/</a></p>
<h3 id="【JVM】如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？"><a href="#【JVM】如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？" class="headerlink" title="【JVM】如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？"></a>【JVM】<strong>如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？</strong></h3><p>自定义类加载的意义：</p>
<p>加载特定路径的class文件</p>
<p>加载一个加密的网络class文件</p>
<p>热部署加载class文件</p>
<h3 id="【JVM】jstack-是⼲什么的-jstat-呢？如果线上程序周期性地出现卡顿，你怀疑可-能是-GC-导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么-部分？"><a href="#【JVM】jstack-是⼲什么的-jstat-呢？如果线上程序周期性地出现卡顿，你怀疑可-能是-GC-导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么-部分？" class="headerlink" title="【JVM】jstack 是⼲什么的? jstat 呢？如果线上程序周期性地出现卡顿，你怀疑可 能是 GC 导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么 部分？"></a>【JVM】<strong>jstack 是⼲什么的? jstat 呢？如果线上程序周期性地出现卡顿，你怀疑可 能是 GC 导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么 部分？</strong></h3><p>jstack 用来查询 Java 进程的堆栈信息。</p>
<p>jvisualvm 监控内存泄露，跟踪垃圾回收、执行时内存、cpu分析、线程分析。</p>
<p>详见Java jvisualvm简要说明，可参考 线上FullGC频繁的排查。</p>
<p>Java jvisualvm简要说明</p>
<p><a href="https://blog.csdn.net/a19881029/article/details/8432368/" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/8432368/</a></p>
<p>线上FullGC频繁的排查</p>
<p><a href="https://blog.csdn.net/wilsonpeng3/article/details/70064336/" target="_blank" rel="noopener">https://blog.csdn.net/wilsonpeng3/article/details/70064336/</a></p>
<h3 id="【JVM】StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？"><a href="#【JVM】StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？" class="headerlink" title="【JVM】StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？"></a>【JVM】<strong>StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？</strong></h3><p>栈内存溢出，一般由栈内存的局部变量过爆了，导致内存溢出。出现在递归方法，参数个数过多，递归过深，递归没有出口。</p>
<h3 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a>什么是垃圾回收？</h3><p>垃圾回收是Java中自动内存管理的另一种叫法。垃圾回收的目的是为程序保持尽可能多的可用堆（heap）。 JVM会删除堆上不再需要从堆引用的对象。</p>
<h3 id="用一个例子解释垃圾回收？"><a href="#用一个例子解释垃圾回收？" class="headerlink" title="用一个例子解释垃圾回收？"></a>用一个例子解释垃圾回收？</h3><p>比方说，下面这个方法就会从函数调用。</p>
<p>void method(){</p>
<p>​    Calendar calendar = new GregorianCalendar(2000,10,30);</p>
<p>​    System.out.println(calendar);</p>
<p>}</p>
<p>通过函数第一行代码中参考变量calendar，在堆上创建了GregorianCalendar类的一个对象。</p>
<p>函数结束执行后，引用变量calendar不再有效。因此，在方法中没有创建引用到对象。</p>
<p>JVM认识到这一点，会从堆中删除对象。这就是所谓的垃圾回收。</p>
<h3 id="什么时候运行垃圾回收？"><a href="#什么时候运行垃圾回收？" class="headerlink" title="什么时候运行垃圾回收？"></a>什么时候运行垃圾回收？</h3><p>垃圾回收在JVM突发奇想和心血来潮时运行（没有那么糟糕）。运行垃圾收集的可能情况是：</p>
<p>堆可用内存不足</p>
<p>CPU空闲</p>
<h3 id="垃圾回收的最佳做法？"><a href="#垃圾回收的最佳做法？" class="headerlink" title="垃圾回收的最佳做法？"></a>垃圾回收的最佳做法？</h3><p>用编程的方式，我们可以要求（记住这只是一个请求——不是一个命令）JVM通过调用System.gc()方法来运行垃圾回收。</p>
<p>当内存已满，且堆上没有对象可用于垃圾回收时，JVM可能会抛出OutOfMemoryException。</p>
<p>对象在被垃圾回收从堆上删除之前，会运行finalize()方法。我们建议不要用finalize()方法写任何代码。</p>
<h3 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h3><p>答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。</p>
<p>import java.util.Arrays;</p>
<p>import java.util.EmptyStackException;</p>
<p>public class MyStack<t> {</t></p>
<p>​    private T[] elements;</p>
<p>​    private int size = 0;</p>
<p>​    private static final int INIT_CAPACITY = 16;</p>
<p>​    public MyStack() {</p>
<p>​        elements = (T[]) new Object[INIT_CAPACITY];</p>
<p>​    }</p>
<p>​    public void push(T elem) {</p>
<p>​        ensureCapacity();</p>
<p>​        elements[size++] = elem;</p>
<p>​    }</p>
<p>​    public T pop() {</p>
<p>​        if(size == 0) </p>
<p>​            throw new EmptyStackException();</p>
<p>​        return elements[–size];</p>
<p>​    }</p>
<p>​    private void ensureCapacity() {</p>
<p>​        if(elements.length == size) {</p>
<p>​            elements = Arrays.copyOf(elements, 2 * size + 1);</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p>
<h3 id="GC是什么？为什么要有GC？"><a href="#GC是什么？为什么要有GC？" class="headerlink" title="GC是什么？为什么要有GC？"></a>GC是什么？为什么要有GC？</h3><p>答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<p>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： </p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 </li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 </li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</li>
</ul>
<p>与垃圾回收相关的JVM参数：</p>
<p>-Xms / -Xmx — 堆的初始大小 / 堆的最大大小</p>
<p>-Xmn — 堆中年轻代的大小</p>
<p>-XX:-DisableExplicitGC — 让System.gc()不产生任何作用</p>
<p>-XX:+PrintGCDetails — 打印GC的细节</p>
<p>-XX:+PrintGCDateStamps — 打印GC操作的时间戳</p>
<p>-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小</p>
<p>-XX:NewRatio — 可以设置老生代和新生代的比例</p>
<p>-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布</p>
<p>-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值</p>
<p>-XX:TargetSurvivorRatio：设置幸存区的目标使用率</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/20/Java-面试题系列篇-SpringMVC-框架/">
        Java 面试题系列篇-SpringMVC 框架
      </a>
    </h2>
    
    <time>
      Oct 20, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="SpringMVC-框架"><a href="#SpringMVC-框架" class="headerlink" title="SpringMVC 框架"></a>SpringMVC 框架</h2><h3 id="如何在Web项目中配置Spring-MVC？"><a href="#如何在Web项目中配置Spring-MVC？" class="headerlink" title="如何在Web项目中配置Spring MVC？"></a>如何在Web项目中配置Spring MVC？</h3><p>答：要使用Spring MVC需要在Web项目配置文件中配置其前端控制器DispatcherServlet，如下所示：</p>
<p><web-app></web-app></p>
<p>​    <servlet></servlet></p>
<p>​        <servlet-name>example</servlet-name></p>
<p>​        <servlet-class></servlet-class></p>
<p>​            org.springframework.web.servlet.DispatcherServlet</p>
<p>​        </p>
<p>​        <load-on-startup>1</load-on-startup></p>
<p>​    </p>
<p>​    <servlet-mapping></servlet-mapping></p>
<p>​        <servlet-name>example</servlet-name></p>
<p>​        <url-pattern>*.html</url-pattern></p>
<p>​    </p>
<p></p>
<p>说明：上面的配置中使用了*.html的后缀映射，这样做一方面不能够通过URL推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。</p>
<h3 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h3><p>答：Spring MVC的工作原理如下图所示：<br>① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。<br>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。<br>③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。<br>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。<br>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。<br>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。<br>⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。<br>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p>
<h3 id="大型网站在架构上应当考虑哪些问题？"><a href="#大型网站在架构上应当考虑哪些问题？" class="headerlink" title="大型网站在架构上应当考虑哪些问题？"></a>大型网站在架构上应当考虑哪些问题？</h3><p>答： </p>
<ul>
<li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。 </li>
<li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。 </li>
<li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。 </li>
<li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。 </li>
<li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。 </li>
<li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。”；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。 </li>
<li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</li>
</ul>
<h3 id="你用过的网站前端优化的技术有哪些？"><a href="#你用过的网站前端优化的技术有哪些？" class="headerlink" title="你用过的网站前端优化的技术有哪些？"></a>你用过的网站前端优化的技术有哪些？</h3><p>答：<br>① 浏览器访问优化： </p>
<ul>
<li>减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） </li>
<li>使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 </li>
<li>启用压缩 </li>
<li>CSS前置，JavaScript后置 </li>
<li>减少Cookie传输<br>② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。<br>③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</li>
</ul>
<h3 id="你使用过的应用服务器优化技术有哪些？"><a href="#你使用过的应用服务器优化技术有哪些？" class="headerlink" title="你使用过的应用服务器优化技术有哪些？"></a>你使用过的应用服务器优化技术有哪些？</h3><p>答：<br>① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题： </p>
<ul>
<li>频繁修改的数据； </li>
<li>数据不一致与脏读； </li>
<li>缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）； </li>
<li>缓存预热； </li>
<li>缓存穿透（恶意持续请求不存在的数据）。<br>② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。<br>③ 使用集群。<br>④ 代码优化： </li>
<li>多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。 </li>
<li>非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。 </li>
<li>资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。</li>
</ul>
<h3 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</h3><p> 答： </p>
<ul>
<li>XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 </li>
<li>SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 </li>
<li>CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。</li>
</ul>
<p>补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。</p>
<h3 id="什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别？"><a href="#什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别？" class="headerlink" title="什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？"></a>什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</h3><p>答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。</p>
<p>贫血模型 </p>
<p>充血模型 </p>
<p>贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点： </p>
<ul>
<li>它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。 </li>
<li>它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。 </li>
<li>事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。<br>然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文《贫血领域模型是如何导致糟糕的软件产生》对这个问题做了比较细致的阐述。</li>
</ul>
<h3 id="谈一谈测试驱动开发（TDD）的好处以及你的理解。"><a href="#谈一谈测试驱动开发（TDD）的好处以及你的理解。" class="headerlink" title="谈一谈测试驱动开发（TDD）的好处以及你的理解。"></a>谈一谈测试驱动开发（TDD）的好处以及你的理解。</h3><p>答：TDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括： </p>
<ul>
<li>更清晰的代码 — 只写需要的代码 </li>
<li>更好的设计 </li>
<li>更出色的灵活性 — 鼓励程序员面向接口编程 </li>
<li>更快速的反馈 — 不会到系统上线时才知道bug的存在</li>
</ul>
<p>补充：敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。</p>
<p>TDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。关于实施TDD的详细步骤请参考另一篇文章《测试驱动开发之初窥门径》。<br>在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类： </p>
<ul>
<li>虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表 </li>
<li>存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态 </li>
<li>伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多） </li>
<li>模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应<br>Java世界中实现模拟替身的第三方工具非常多，包括EasyMock、Mockito、jMock等。</li>
</ul>
<h3 id="什么是可变参数？"><a href="#什么是可变参数？" class="headerlink" title="什么是可变参数？"></a>什么是可变参数？</h3><p>可变参数允许调用参数数量不同的方法。请看下面例子中的求和方法。此方法可以调用1个int参数，或2个int参数，或多个int参数。</p>
<p> //int(type) followed … (three dot’s) is syntax of a variable argument. </p>
<p>​    public int sum(int… numbers) {</p>
<p>​        //inside the method a variable argument is similar to an array.</p>
<p>​        //number can be treated as if it is declared as int[] numbers;</p>
<p>​        int sum = 0;</p>
<p>​        for (int number: numbers) {</p>
<p>​            sum += number;</p>
<p>​        }</p>
<p>​        return sum;</p>
<p>​    }</p>
<p>​    public static void main(String[] args) {</p>
<p>​        VariableArgumentExamples example = new VariableArgumentExamples();</p>
<p>​        //3 Arguments</p>
<p>​        System.out.println(example.sum(1, 4, 5));//10</p>
<p>​        //4 Arguments</p>
<p>​        System.out.println(example.sum(1, 4, 5, 20));//30</p>
<p>​        //0 Arguments</p>
<p>​        System.out.println(example.sum());//0</p>
<p>}</p>
<h3 id="断言的用途？"><a href="#断言的用途？" class="headerlink" title="断言的用途？"></a>断言的用途？</h3><p>断言是在Java 1.4中引入的。它能让你验证假设。如果断言失败（即返回false），就会抛出AssertionError（如果启用断言）。基本断言如下所示。</p>
<p>private int computerSimpleInterest(int principal,float interest,int years){</p>
<p>​    assert(principal&gt;0);</p>
<p>​    return 100;</p>
<p>}</p>
<h3 id="什么时候使用断言？"><a href="#什么时候使用断言？" class="headerlink" title="什么时候使用断言？"></a>什么时候使用断言？</h3><p>断言不应该用于验证输入数据到一个public方法或命令行参数。IllegalArgumentException会是一个更好的选择。在public方法中，只用断言来检查它们根本不应该发生的情况。</p>
<h3 id="什么是初始化数据块？"><a href="#什么是初始化数据块？" class="headerlink" title="什么是初始化数据块？"></a>什么是初始化数据块？</h3><p>初始化数据块——当创建对象或加载类时运行的代码。</p>
<p>有两种类型的初始化数据块：</p>
<p>静态初始化器：加载类时运行的的代码</p>
<p>实例初始化器：创建新对象时运行的代码</p>
<h3 id="什么是静态初始化器？"><a href="#什么是静态初始化器？" class="headerlink" title="什么是静态初始化器？"></a>什么是静态初始化器？</h3><p>请看下面的例子：static{ 和 }之间的代码被称为静态初始化器。它只有在第一次加载类时运行。只有静态变量才可以在静态初始化器中进行访问。虽然创建了三个实例，但静态初始化器只运行一次。</p>
<p>/**</p>
<ul>
<li><p>Java学习交流QQ群：589809992 我们一起学Java！</p>
<p>*/</p>
</li>
</ul>
<p>public class InitializerExamples {</p>
<p>​    static int count;</p>
<p>​    int i;</p>
<p>​    static{</p>
<p>​        //This is a static initializers. Run only when Class is first loaded.</p>
<p>​        //Only static variables can be accessed</p>
<p>​        System.out.println(“Static Initializer”);</p>
<p>​        //i = 6;//COMPILER ERROR</p>
<p>​        System.out.println(“Count when Static Initializer is run is “ + count);</p>
<p>​    }</p>
<p>​    public static void main(String[] args) {</p>
<p>​        InitializerExamples example = new InitializerExamples();</p>
<p>​        InitializerExamples example2 = new InitializerExamples();</p>
<p>​        InitializerExamples example3 = new InitializerExamples();</p>
<p>​    }</p>
<p>}</p>
<p>示例输出</p>
<p>Static Initializer</p>
<p>Count when Static Initializer is run is 0.</p>
<h3 id="什么是实例初始化块？"><a href="#什么是实例初始化块？" class="headerlink" title="什么是实例初始化块？"></a>什么是实例初始化块？</h3><p>让我们来看一个例子：每次创建类的实例时，实例初始化器中的代码都会运行。</p>
<p>/**</p>
<ul>
<li><p>Java学习交流QQ群：589809992 我们一起学Java！</p>
<p>*/</p>
</li>
</ul>
<p>public class InitializerExamples {</p>
<p>​    static int count;</p>
<p>​    int i;</p>
<p>​    {</p>
<p>​        //This is an instance initializers. Run every time an object is created.</p>
<p>​        //static and instance variables can be accessed</p>
<p>​        System.out.println(“Instance Initializer”);</p>
<p>​        i = 6;</p>
<p>​        count = count + 1;</p>
<p>​        System.out.println(“Count when Instance Initializer is run is “ + count);</p>
<p>​    }</p>
<p>​    public static void main(String[] args) {</p>
<p>​        InitializerExamples example = new InitializerExamples();</p>
<p>​        InitializerExamples example1 = new InitializerExamples();</p>
<p>​        InitializerExamples example2 = new InitializerExamples();</p>
<p>​    }</p>
<p>}</p>
<p>示例输出</p>
<p>Instance Initializer</p>
<p>​      Count when Instance Initializer is run is 1</p>
<p>​      Instance Initializer</p>
<p>​      Count when Instance Initializer is run is 2</p>
<p>​      Instance Initializer</p>
<p>​      Count when Instance Initializer is run is 3</p>
<h3 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h3><p>正则表达式能让解析、扫描和分割字符串变得非常容易。Java中常用的正则表达式——Patter，Matcher和Scanner类。</p>
<h3 id="什么是令牌化？"><a href="#什么是令牌化？" class="headerlink" title="什么是令牌化？"></a>什么是令牌化？</h3><p>令牌化是指在分隔符的基础上将一个字符串分割为若干个子字符串。例如，分隔符；分割字符串ac;bd;def;e为四个子字符串ac，bd，def和e。</p>
<p>分隔符自身也可以是一个常见正则表达式。</p>
<p>String.split(regex)函数将regex作为参数。</p>
<h3 id="给出令牌化的例子？"><a href="#给出令牌化的例子？" class="headerlink" title="给出令牌化的例子？"></a>给出令牌化的例子？</h3><p>private static void tokenize(String string,String regex) {</p>
<p>​    String[] tokens = string.split(regex);</p>
<p>​    System.out.println(Arrays.toString(tokens));</p>
<p>}</p>
<p>tokenize(“ac;bd;def;e”,”;”);//[ac, bd, def, e]</p>
<h3 id="如何使用扫描器类（Scanner-Class）令牌化？"><a href="#如何使用扫描器类（Scanner-Class）令牌化？" class="headerlink" title="如何使用扫描器类（Scanner Class）令牌化？"></a>如何使用扫描器类（Scanner Class）令牌化？</h3><p>private static void tokenizeUsingScanner(String string,String regex) {</p>
<p>​    Scanner scanner = new Scanner(string);</p>
<p>​    scanner.useDelimiter(regex);</p>
<p>​    List<string> matches = new ArrayList<string>();</string></string></p>
<p>​    while(scanner.hasNext()){</p>
<p>​        matches.add(scanner.next());</p>
<p>​    }</p>
<p>​    System.out.println(matches);</p>
<p>}</p>
<p>tokenizeUsingScanner(“ac;bd;def;e”,”;”);//[ac, bd, def, e]</p>
<h3 id="如何添加小时-hour-到一个日期对象（Date-Objects）？"><a href="#如何添加小时-hour-到一个日期对象（Date-Objects）？" class="headerlink" title="如何添加小时(hour)到一个日期对象（Date Objects）？"></a>如何添加小时(hour)到一个日期对象（Date Objects）？</h3><p>现在，让我们如何看看添加小时到一个date对象。所有在date上的日期操作都需要通过添加毫秒到date才能完成。例如，如果我们想增加6个小时，那么我们需要将6小时换算成毫秒。6小时= 6  60  60 * 1000毫秒。请看以下的例子。</p>
<p>Date date = new Date();</p>
<p>//Increase time by 6 hrs</p>
<p>date.setTime(date.getTime() + 6 <em> 60 </em> 60 * 1000);</p>
<p>System.out.println(date);</p>
<p>//Decrease time by 6 hrs</p>
<p>date = new Date();</p>
<p>date.setTime(date.getTime() - 6 <em> 60 </em> 60 * 1000);</p>
<p>System.out.println(date);</p>
<h3 id="如何格式化日期对象？"><a href="#如何格式化日期对象？" class="headerlink" title="如何格式化日期对象？"></a>如何格式化日期对象？</h3><p>格式化日期需要使用DateFormat类完成。让我们看几个例子。</p>
<p>//Formatting Dates</p>
<p>System.out.println(DateFormat.getInstance().format(</p>
<p>​        date));//10/16/12 5:18 AM</p>
<p>带有区域设置的格式化日期如下所示：</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.FULL, new Locale(“it”, “IT”))</p>
<p>​        .format(date));//marted“ 16 ottobre 2012</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.FULL, Locale.ITALIAN)</p>
<p>​        .format(date));//marted“ 16 ottobre 2012</p>
<p>//This uses default locale US</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.FULL).format(date));//Tuesday, October 16, 2012</p>
<p>System.out.println(DateFormat.getDateInstance()</p>
<p>​        .format(date));//Oct 16, 2012</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.SHORT).format(date));//10/16/12</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.MEDIUM).format(date));//Oct 16, 2012</p>
<p>System.out.println(DateFormat.getDateInstance(</p>
<p>​        DateFormat.LONG).format(date));//October 16, 2012</p>
<h3 id="Java中日历类（Calendar-Class）的用途？"><a href="#Java中日历类（Calendar-Class）的用途？" class="headerlink" title="Java中日历类（Calendar Class）的用途？"></a>Java中日历类（Calendar Class）的用途？</h3><p>Calendar类在Java中用于处理日期。Calendar类提供了增加和减少天数、月数和年数的简便方法。它还提供了很多与日期有关的细节（这一年的哪一天？哪一周？等等）</p>
<h3 id="如何在Java中获取日历类（Calendar-Class）的实例？"><a href="#如何在Java中获取日历类（Calendar-Class）的实例？" class="headerlink" title="如何在Java中获取日历类（Calendar Class）的实例？"></a>如何在Java中获取日历类（Calendar Class）的实例？</h3><p>Calendar类不能通过使用new Calendar创建。得到Calendar类实例的最好办法是在Calendar中使用getInstance() static方法。</p>
<p>//Calendar calendar = new Calendar(); //COMPILER ERROR</p>
<p>Calendar calendar = Calendar.getInstance();</p>
<h3 id="解释一些日历类（Calendar-Class）中的重要方法？"><a href="#解释一些日历类（Calendar-Class）中的重要方法？" class="headerlink" title="解释一些日历类（Calendar Class）中的重要方法？"></a>解释一些日历类（Calendar Class）中的重要方法？</h3><p>在Calendar对象上设置日（day），月（month）或年（year）不难。对Day，Month或Year调用恰当Constant的set方法。下一个参数就是值。</p>
<p>calendar.set(Calendar.DATE, 24);</p>
<p>calendar.set(Calendar.MONTH, 8);//8 - September</p>
<p>calendar.set(Calendar.YEAR, 2010);</p>
<p>calendar get方法</p>
<p>要获取一个特定日期的信息——2010年9月24日。我们可以使用calendar get方法。已被传递的参数表示我们希望从calendar中获得的值—— 天或月或年或……你可以从calendar获取的值举例如下：</p>
<p>System.out.println(calendar.get(Calendar.YEAR));//2010</p>
<p>System.out.println(calendar.get(Calendar.MONTH));//8</p>
<p>System.out.println(calendar.get(Calendar.DATE));//24</p>
<p>System.out.println(calendar.get(Calendar.WEEK_OF_MONTH));//4</p>
<p>System.out.println(calendar.get(Calendar.WEEK_OF_YEAR));//39</p>
<p>System.out.println(calendar.get(Calendar.DAY_OF_YEAR));//267</p>
<p>System.out.println(calendar.getFirstDayOfWeek());//1 -&gt; Calendar.SUNDAY</p>
<h3 id="数字格式化类（Number-Format-Class）的用途？"><a href="#数字格式化类（Number-Format-Class）的用途？" class="headerlink" title="数字格式化类（Number Format Class）的用途？"></a>数字格式化类（Number Format Class）的用途？</h3><p>数字格式用于格式化数字到不同的区域和不同格式中。</p>
<p>使用默认语言环境的数字格式</p>
<p>System.out.println(NumberFormat.getInstance().format(321.24f));//321.24</p>
<p>使用区域设置的数字格式</p>
<p>使用荷兰语言环境格式化数字：</p>
<p>System.out.println(NumberFormat.getInstance(new Locale(“nl”)).format(4032.3f));//4.032,3</p>
<p>使用德国语言环境格式化数字：</p>
<p>System.out.println(NumberFormat.getInstance(Locale.GERMANY).format(4032.3f));//4.032,3</p>
<p>使用默认语言环境格式化货币</p>
<p>System.out.println(NumberFormat.getCurrencyInstance().format(40324.31f));//$40,324.31</p>
<p>使用区域设置格式化货币</p>
<p>使用荷兰语言环境格式化货币：</p>
<p>System.out.println(NumberFormat.getCurrencyInstance(new Locale(“nl”)).format(40324.31f));/</p>
<h3 id="后台从前端页面获取到表单数据的方法？请具体到细节，如Servlet如何接收？SpringMVC怎么接收或Structs2？"><a href="#后台从前端页面获取到表单数据的方法？请具体到细节，如Servlet如何接收？SpringMVC怎么接收或Structs2？" class="headerlink" title="后台从前端页面获取到表单数据的方法？请具体到细节，如Servlet如何接收？SpringMVC怎么接收或Structs2？"></a>后台从前端页面获取到表单数据的方法？请具体到细节，如Servlet如何接收？SpringMVC怎么接收或Structs2？</h3><h3 id="Spring-中-IOC-和-DI-的区别以及关系是什么、AOP是怎么实现的？"><a href="#Spring-中-IOC-和-DI-的区别以及关系是什么、AOP是怎么实现的？" class="headerlink" title="Spring 中 IOC 和 DI 的区别以及关系是什么、AOP是怎么实现的？"></a>Spring 中 IOC 和 DI 的区别以及关系是什么、AOP是怎么实现的？</h3>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2018/10/20/Java-面试题系列篇-Struts-框架/">
        Java 面试题系列篇-struts 框架
      </a>
    </h2>
    
    <time>
      Oct 20, 2018
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="Struts-框架"><a href="#Struts-框架" class="headerlink" title="Struts 框架"></a>Struts 框架</h2><h3 id="Struts2-中action-是多实例还是单实例的？为什么？"><a href="#Struts2-中action-是多实例还是单实例的？为什么？" class="headerlink" title="Struts2 中action 是多实例还是单实例的？为什么？"></a>Struts2 中action 是多实例还是单实例的？为什么？</h3><h3 id="Struts2-中的拦截器如何配置？"><a href="#Struts2-中的拦截器如何配置？" class="headerlink" title="Struts2 中的拦截器如何配置？"></a>Struts2 中的拦截器如何配置？</h3><h3 id="SSH-框架或-SSM-框架整合思想是什么？关键-jar-包是哪几个？请具体阐述-jar-包的作用？"><a href="#SSH-框架或-SSM-框架整合思想是什么？关键-jar-包是哪几个？请具体阐述-jar-包的作用？" class="headerlink" title="SSH 框架或 SSM 框架整合思想是什么？关键 jar 包是哪几个？请具体阐述 jar 包的作用？"></a>SSH 框架或 SSM 框架整合思想是什么？关键 jar 包是哪几个？请具体阐述 jar 包的作用？</h3><h3 id="页面数据分页如何实现？"><a href="#页面数据分页如何实现？" class="headerlink" title="页面数据分页如何实现？"></a>页面数据分页如何实现？</h3>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/Java/">Java</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/tags/Java/page/3/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
    <a class="next" rel="next" href="/tags/Java/page/5/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<div class='header'>Darklovy</div>
<div class='content'>
<div class='desc'>Tempora mutantur, nos et mutamur in illis ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://ccoooss.com">
            <div class='name'>ClassicOldSong</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://frantic1048.logdown.com/">
            <div class='name'>Frantic1048</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://hclmaster.github.io/">
            <div class='name'>Hclmaster</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://whst.github.io/">
            <div class='name'>WANG Hsü-Tung</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/Android/" style="font-size: 14px; color: #808080">Android</a> <a href="/tags/HTML/" style="font-size: 14px; color: #808080">HTML</a> <a href="/tags/Java/" style="font-size: 20px; color: #000">Java</a> <a href="/tags/Python/" style="font-size: 14px; color: #808080">Python</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/stkevintan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/kevinsfork" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
